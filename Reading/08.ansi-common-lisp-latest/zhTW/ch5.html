<!DOCTYPE HTML>

  <html xmlns="http://www.w3.org/1999/xhtml" lang="zh">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
<title>第五章：控制流程 &mdash; ANSI Common Lisp 中文版</title>
    
<!-- RTD <head> -->
<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript" src="//media.readthedocs.org/javascript/underscore.js"></script>
<script type="text/javascript" src="//media.readthedocs.org/javascript/doctools.js"></script>

<script type="text/javascript">
  // This is included here for Javascript that doesn't have access to the templates.
  var doc_version = "latest";
  var doc_slug = "ansi-common-lisp";
</script>

<script type="text/javascript" src="//media.readthedocs.org/javascript/rtd.js"></script>
<!-- end RTD <head> -->

    <link rel="stylesheet" href="../_static/han.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/rosefinch.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/main.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:       '../',
        VERSION:        '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX:    '.html',
        HAS_SOURCE:     true
      };
    </script>
    <script type="text/javascript" src="../_static/han.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src=../_static/jquery.dimensions.js"></script>
  <script type="text/javascript" src="../_static/main.js"></script><link rel="top" title="ANSI Common Lisp 中文版" href="../index.html" /></head>

  <body><div class="navbar navbar-static-top navbar-inverse">
        <div id="top-bar" class="navbar-inner">

          <h1 id="logo">ANSI Common Lisp 中文版<a href="../index.html" class="brand">ANSI Common Lisp 中文版</a></h1>
          <ul class="nav"></ul><a href="https://github.com/acl-translation/acl-chinese"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub"></a>
        </div>
      </div><div class="content container-fluid">
        <div class="row-fluid"><div class="document span9"><article >
                <div class="documentwrapper"><div class="body"><div class="section" id="id1">
<h1>第五章：控制流程<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>2.2 節介紹了 Common Lisp 的求值規則，直到現在你應該很熟悉了。本章的運算元都有一個共同點，就是它們都違反了求值規則。他們讓你決定在程式當中何時要求值。如果普通的函數呼叫是 Lisp 程式的樹葉的話，那這些運算元就是用來建造樹枝。</p>
<div class="section" id="blocks">
<h2>5.1 區塊 (Blocks)<a class="headerlink" href="#blocks" title="永久链接至标题">¶</a></h2>
<p>Common Lisp 有三個創造區塊 (block) 的基本運算元： <tt class="docutils literal"><span class="pre">progn</span></tt> , <tt class="docutils literal"><span class="pre">block</span></tt> 以及 <tt class="docutils literal"><span class="pre">tagbody</span></tt> 。我們已經看過 <tt class="docutils literal"><span class="pre">progn</span></tt> 了。在 <tt class="docutils literal"><span class="pre">progn</span></tt> 主體中的表達式會依序求值，並回傳最後一個表達式的值：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;a&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;b&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="mi">11</span> <span class="mi">12</span><span class="p">))</span>
<span class="nv">ab</span>
<span class="mi">23</span>
</pre></div>
</td></tr></table></div>
<p>由於只回傳最後一個表達式的值，代表著使用 <tt class="docutils literal"><span class="pre">progn</span></tt> （或任何區塊）意味著副作用。</p>
<p>一個 <tt class="docutils literal"><span class="pre">block</span></tt> 像是帶有名字及緊急出口的 <tt class="docutils literal"><span class="pre">progn</span></tt> 。第一個參數應為符號。這變成了區塊的名字。在主體中的任何地方，你可以停止求值，並透過使用 <tt class="docutils literal"><span class="pre">return-from</span></tt> 指定區塊的名字，來立即回傳一個數值：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">block</span> <span class="nv">head</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Here we go.&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="k">return-from</span> <span class="nv">head</span> <span class="ss">&#39;idea</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;We&#39;ll never see this.&quot;</span><span class="p">))</span>
<span class="nv">Here</span> <span class="nv">we</span> <span class="nv">go.</span>
<span class="nv">IDEA</span>
</pre></div>
</td></tr></table></div>
<p>呼叫 <tt class="docutils literal"><span class="pre">return-from</span></tt> 允許你的程式從程式碼的任何地方，突然但優雅地退出。第二個傳給 <tt class="docutils literal"><span class="pre">return-from</span></tt> 的參數，用來作為以第一個參數為名的區塊的回傳值。在 <tt class="docutils literal"><span class="pre">return-from</span></tt> 之後的表達式不會被求值。</p>
<p>也有一個 <tt class="docutils literal"><span class="pre">return</span></tt> 巨集，它把傳入的參數當做封閉區塊 <tt class="docutils literal"><span class="pre">nil</span></tt> 的回傳值：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">block</span> <span class="no">nil</span>
    <span class="p">(</span><span class="nb">return</span> <span class="mi">27</span><span class="p">))</span>
<span class="mi">27</span>
</pre></div>
</td></tr></table></div>
<p>許多接受一個表達式主體的 Common Lisp 運算元，皆被隱含在一個叫做 <tt class="docutils literal"><span class="pre">nil</span></tt> 的區塊裡。比如，所有由 <tt class="docutils literal"><span class="pre">do</span></tt> 建構的迭代函數：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A &quot;</span> <span class="nv">x</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">x</span> <span class="ss">&#39;c</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">return</span> <span class="ss">&#39;done</span><span class="p">)))</span>
<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span>
<span class="nv">DONE</span>
</pre></div>
</td></tr></table></div>
<p>使用 <tt class="docutils literal"><span class="pre">defun</span></tt> 定義的函數主體，都被隱含在一個與函數同名的區塊，所以你可以：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">foo</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">return-from</span> <span class="nv">foo</span> <span class="mi">27</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>在一個顯式或隱式的 <tt class="docutils literal"><span class="pre">block</span></tt> 外，不論是 <tt class="docutils literal"><span class="pre">return-from</span></tt> 或 <tt class="docutils literal"><span class="pre">return</span></tt> 都不會工作。</p>
<p>使用 <tt class="docutils literal"><span class="pre">return-from</span></tt> ，我們可以寫出一個更好的 <tt class="docutils literal"><span class="pre">read-integer</span></tt> 版本：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">read-integer</span> <span class="p">(</span><span class="nv">str</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">accum</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">pos</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">str</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">i</span> <span class="p">(</span><span class="nb">digit-char-p</span> <span class="p">(</span><span class="nb">char</span> <span class="nv">str</span> <span class="nv">pos</span><span class="p">))))</span>
        <span class="p">(</span><span class="k">if</span> <span class="nv">i</span>
            <span class="p">(</span><span class="nb">setf</span> <span class="nv">accum</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">accum</span> <span class="mi">10</span><span class="p">)</span> <span class="nv">i</span><span class="p">))</span>
            <span class="p">(</span><span class="k">return-from</span> <span class="nv">read-integer</span> <span class="no">nil</span><span class="p">))))</span>
    <span class="nv">accum</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>68 頁的版本在建構整數之前，需要檢查所有的字元。現在兩個步驟可以結合，因為如果我們遇到非數字的字元時，我們可以捨棄計算結果。出現在主體的原子（atom）被解讀為標籤（labels)；把這樣的標籤傳給 <tt class="docutils literal"><span class="pre">go</span></tt> ，會把控制權交給標籤後的表達式。以下是一個非常醜的程式片段，用來印出一至十的數字：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">tagbody</span>
    <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="mi">0</span><span class="p">)</span>
    <span class="nv">top</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A &quot;</span> <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">)</span> <span class="p">(</span><span class="k">go</span> <span class="nv">top</span><span class="p">)))</span>
<span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>這個運算元主要用來實現其它的運算元，不是你自己會使用的東西。大多數迭代運算元都有隱含一個 <tt class="docutils literal"><span class="pre">tagbody</span></tt> ，所以可能可以在主體裡（雖然很少想要）使用標籤及 <tt class="docutils literal"><span class="pre">go</span></tt> 。</p>
<p>你如何決定要使用哪一個區塊建構元（block construct）？幾乎任何時候，你會使用 <tt class="docutils literal"><span class="pre">progn</span></tt> 。如果你想要突然退出的話，使用 <tt class="docutils literal"><span class="pre">block</span></tt> 來取代。多數程式設計師永遠不會顯式地使用 <tt class="docutils literal"><span class="pre">tagbody</span></tt> 。</p>
</div>
<div class="section" id="context">
<h2>5.2 語境 (Context)<a class="headerlink" href="#context" title="永久链接至标题">¶</a></h2>
<p>另一個我們用來替表達式分組的運算元是 <tt class="docutils literal"><span class="pre">let</span></tt> 。它接受一個程式碼主體，但允許我們在主體內設置新變數：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">7</span><span class="p">)</span>
        <span class="p">(</span><span class="nv">y</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Number&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>一個像是 <tt class="docutils literal"><span class="pre">let</span></tt> 的運算元創造出一個新的詞法語境（lexical context）。在這個語境裡有兩個新變數，然而在外部語境的變數也因此變得不可視了。</p>
<p>概念上說，一個 <tt class="docutils literal"><span class="pre">let</span></tt> 表達式像是一個函數呼叫。在 2.14 節證明過，可以用名字來參照一個函數，也可以從字面上藉由使用一個 lambda 表達式來參照。由於一個 lambda 表達式像是函數的名字，我們可以像使用函數名那樣，把 lambda 表達式作為函數呼叫的第一個參數：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span> <span class="mi">3</span><span class="p">)</span>
<span class="mi">4</span>
</pre></div>
</td></tr></table></div>
<p>前述的 <tt class="docutils literal"><span class="pre">let</span></tt> 表達式實際上等同於：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Number&quot;</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
 <span class="mi">7</span>
 <span class="mi">20</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>有關 <tt class="docutils literal"><span class="pre">let</span></tt> 的任何問題，應該是如何把責任交給 <tt class="docutils literal"><span class="pre">lambda</span></tt> ，因為進入一個 <tt class="docutils literal"><span class="pre">let</span></tt> 如同於執行一個函數呼叫。</p>
<p>這個模型清楚的告訴我們，由 <tt class="docutils literal"><span class="pre">let</span></tt> 創造的變數的值，不能依賴其它由同一個 <tt class="docutils literal"><span class="pre">let</span></tt> 所創造的變數。舉例來說，如果我們試著：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">2</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>在 <tt class="docutils literal"><span class="pre">(+</span> <span class="pre">x</span> <span class="pre">1)</span></tt> 中的 <tt class="docutils literal"><span class="pre">x</span></tt> 不是前一行所設置的值，因為整個表達式等同於：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span> <span class="mi">2</span>
                        <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>這裡明顯看到 <tt class="docutils literal"><span class="pre">(+</span> <span class="pre">x</span> <span class="pre">1)</span></tt> 作為參數傳給函數，不能參照函數內的參數 <tt class="docutils literal"><span class="pre">x</span></tt> 。</p>
<p>所以如果你真的想要新的變數的值，依賴由同一個表達式所設立的另一個變數？在這個情況，你會使用一個變形版本 <tt class="docutils literal"><span class="pre">let*</span></tt> ：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="mi">3</span>
</pre></div>
</td></tr></table></div>
<p>一個 <tt class="docutils literal"><span class="pre">let*</span></tt> 功能上等同於一系列巢狀的 <tt class="docutils literal"><span class="pre">let</span></tt> 。這個特別的例子等同於：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">y</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p><tt class="docutils literal"><span class="pre">let</span></tt> 與 <tt class="docutils literal"><span class="pre">let*</span></tt> 將變數初始值都設為 <tt class="docutils literal"><span class="pre">nil</span></tt> 。這樣的變數不需要依附在列表內:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="no">NIL</span> <span class="no">NIL</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><tt class="docutils literal"><span class="pre">destructuring-bind</span></tt> 巨集是通用化的 <tt class="docutils literal"><span class="pre">let</span></tt> 。與其接受單一變數，它接受一個模式 (pattern) –– 一個或多個變數所形成的樹 –– 並將它們與某個實際的樹所對應的部份做綁定。舉例來說：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">destructuring-bind</span> <span class="p">(</span><span class="nv">w</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="o">.</span> <span class="nv">z</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">E</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>若給定的樹（第二個參數）沒有匹配模式（第一個參數）時，會產生錯誤。</p>
</div>
<div class="section" id="conditionals">
<h2>5.3 條件 (Conditionals)<a class="headerlink" href="#conditionals" title="永久链接至标题">¶</a></h2>
<p>最簡單的條件式是 <tt class="docutils literal"><span class="pre">if</span></tt> ；其餘的條件式都是基於 <tt class="docutils literal"><span class="pre">if</span></tt> 所建造的。第二簡單的條件式是 <tt class="docutils literal"><span class="pre">when</span></tt> ，它接受一個測試表達式 (test expression)與一個程式碼主體。若測試表達式求值回傳真時，則對主體求值。所以</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">oddp</span> <span class="nv">that</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Hmm, that&#39;s odd.&quot;</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="nv">that</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>等效於</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">oddp</span> <span class="nv">that</span><span class="p">)</span>
    <span class="p">(</span><span class="k">progn</span>
      <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;Hmm, that&#39;s odd.&quot;</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">+</span> <span class="nv">that</span> <span class="mi">1</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p><tt class="docutils literal"><span class="pre">when</span></tt> 的相反是 <tt class="docutils literal"><span class="pre">unless</span></tt> ；它接受同樣的參數，但主體僅在測試表達式回傳假時，才對主體求值。</p>
<p>所有條件式的母體 (從正反兩面看) 是 <tt class="docutils literal"><span class="pre">cond</span></tt> ，它帶有兩個新的優點：它允許多重條件式，與每個條件式相關的程式碼是隱式的 <tt class="docutils literal"><span class="pre">progn</span></tt> 。它預期在我們需要在一個 <tt class="docutils literal"><span class="pre">if</span></tt> 中使用另一個 <tt class="docutils literal"><span class="pre">if</span></tt> 的情況下使用。 舉例來說，這個偽 member 函數</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-member</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">obj</span><span class="p">)</span>
          <span class="nv">lst</span>
          <span class="p">(</span><span class="nv">our-member</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>也可以定義成：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-member</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">lst</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
        <span class="p">((</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">obj</span><span class="p">)</span> <span class="nv">lst</span><span class="p">)</span>
        <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">our-member</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>事實上，Common Lisp 的實現大概會把 <tt class="docutils literal"><span class="pre">cond</span></tt> 翻譯成 <tt class="docutils literal"><span class="pre">if</span></tt> 的形式。</p>
<p>總得來說呢， <tt class="docutils literal"><span class="pre">cond</span></tt> 接受零個或多個參數。每一個參數必須是一個具有條件式伴隨著零個或多個表達式的列表。當 <tt class="docutils literal"><span class="pre">cond</span></tt> 表達式被求值時，測試條件式依序求值，直到某個測試條件式回傳真才停止。當回傳真時，與其關聯的表達式會被依序求值，而最後一個回傳的數值會作為 <tt class="docutils literal"><span class="pre">cond</span></tt> 的回傳值。如果符合的條件式之後沒有表達式的話：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">(</span><span class="mi">99</span><span class="p">))</span>
<span class="mi">99</span>
</pre></div>
</td></tr></table></div>
<p>則會返回條件式的值。</p>
<p>由於 <tt class="docutils literal"><span class="pre">cond</span></tt> 子句的 <tt class="docutils literal"><span class="pre">t</span></tt> 條件永遠成立，通常我們把它放在最後，作為預設的條件式。如果沒有子句符合時，則 <tt class="docutils literal"><span class="pre">cond</span></tt> 返回 <tt class="docutils literal"><span class="pre">nil</span></tt> ，但利用 <tt class="docutils literal"><span class="pre">nil</span></tt> 回傳值是一種很差的風格 (這種問題可能發生的例子，請看 292 頁)。譯註: <strong>Appendix A, unexpected nil</strong> 小節。</p>
<p>當你想要把一個數值與一系列的常數比較時，有 <tt class="docutils literal"><span class="pre">case</span></tt> 可以用。我們可以使用 <tt class="docutils literal"><span class="pre">case</span></tt> 來定義一個函數，回傳每個月份中的天數：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">month-length</span> <span class="p">(</span><span class="nv">mon</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">case</span> <span class="nv">mon</span>
    <span class="p">((</span><span class="nv">jan</span> <span class="nv">mar</span> <span class="nv">may</span> <span class="nv">jul</span> <span class="nv">aug</span> <span class="nv">oct</span> <span class="nv">dec</span><span class="p">)</span> <span class="mi">31</span><span class="p">)</span>
    <span class="p">((</span><span class="nv">apr</span> <span class="nv">jun</span> <span class="nv">sept</span> <span class="nv">nov</span><span class="p">)</span> <span class="mi">30</span><span class="p">)</span>
    <span class="p">(</span><span class="nv">feb</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">leap-year</span><span class="p">)</span> <span class="mi">29</span> <span class="mi">28</span><span class="p">))</span>
    <span class="p">(</span><span class="nv">otherwise</span> <span class="s">&quot;unknown month&quot;</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>一個 <tt class="docutils literal"><span class="pre">case</span></tt> 表達式由一個參數開始，此參數會被拿來與每個子句的鍵值做比較。接著是零個或多個子句，每個子句由一個或一串鍵值開始，跟隨著零個或多個表達式。鍵值被視為常數；它們不會被求值。第一個參數的值被拿來與子句中的鍵值做比較 (使用 <tt class="docutils literal"><span class="pre">eql</span></tt> )。如果匹配時，子句剩餘的表達式會被求值，並將最後一個求值作為 <tt class="docutils literal"><span class="pre">case</span></tt> 的回傳值。</p>
<p>預設子句的鍵值可以是 <tt class="docutils literal"><span class="pre">t</span></tt> 或 <tt class="docutils literal"><span class="pre">otherwise</span></tt> 。如果沒有子句符合時，或是子句只包含鍵值時，</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">case</span> <span class="mi">99</span> <span class="p">(</span><span class="mi">99</span><span class="p">))</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>則 <tt class="docutils literal"><span class="pre">case</span></tt> 回傳 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</p>
<p><tt class="docutils literal"><span class="pre">typecase</span></tt> 巨集與 <tt class="docutils literal"><span class="pre">case</span></tt> 相似，除了每個子句中的鍵值應為型別修飾符 (type specifiers)，以及第一個參數與鍵值比較的函數使用 <tt class="docutils literal"><span class="pre">typep</span></tt> 而不是 <tt class="docutils literal"><span class="pre">eql</span></tt> (一個 <tt class="docutils literal"><span class="pre">typecase</span></tt> 的例子在 107 頁)。 譯註: 6.5 小節。</p>
</div>
<div class="section" id="iteration">
<h2>5.4 迭代 (Iteration)<a class="headerlink" href="#iteration" title="永久链接至标题">¶</a></h2>
<p>最基本的迭代運算元是 <tt class="docutils literal"><span class="pre">do</span></tt> ，它在 2.13 節介紹過。由於 <tt class="docutils literal"><span class="pre">do</span></tt> 包含了隱式的 <tt class="docutils literal"><span class="pre">block</span></tt> 及 <tt class="docutils literal"><span class="pre">tagbody</span></tt> ，我們現在知道是可以在 <tt class="docutils literal"><span class="pre">do</span></tt> 主體內使用 <tt class="docutils literal"><span class="pre">return</span></tt> , <tt class="docutils literal"><span class="pre">return-from</span></tt> 以及 <tt class="docutils literal"><span class="pre">go</span></tt> 。</p>
<p>2.13 節提到 <tt class="docutils literal"><span class="pre">do</span></tt> 的第一個參數必須是一個變數規格說明的列表，每個可以是如下形式：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nv">variable</span>  <span class="nv">initial</span>  <span class="nv">update</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><tt class="docutils literal"><span class="pre">initial</span></tt> 與 <tt class="docutils literal"><span class="pre">update</span></tt> 形式是選擇性的。若 <tt class="docutils literal"><span class="pre">update</span></tt> 形式忽略時，每次迭代時不會更新變數。若 <tt class="docutils literal"><span class="pre">initial</span></tt> 形式也忽略時，變數會使用 <tt class="docutils literal"><span class="pre">nil</span></tt> 來初始化。</p>
<p>在 23 頁的例子中（譯註: 2.13 節），</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">show-squares</span> <span class="p">(</span><span class="nv">start</span> <span class="nv">end</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">i</span> <span class="nv">start</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
       <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">i</span> <span class="nv">end</span><span class="p">)</span> <span class="ss">&#39;done</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A ~A~%&quot;</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">i</span> <span class="nv">i</span><span class="p">))))</span>
</pre></div>
</td></tr></table></div>
<p><tt class="docutils literal"><span class="pre">update</span></tt> 形式參照到由 <tt class="docutils literal"><span class="pre">do</span></tt> 所創造的變數。一般都是這麼用。如果一個 <tt class="docutils literal"><span class="pre">do</span></tt> 的 <tt class="docutils literal"><span class="pre">update</span></tt> 形式，沒有至少參照到一個自己創造的變數時，反而很奇怪。</p>
<p>當超過一個變數被更新時，問題來了，如果一個 <tt class="docutils literal"><span class="pre">update</span></tt> 形式，參照到一個擁有自己的 <tt class="docutils literal"><span class="pre">update</span></tt> 形式的變數時，它會被更新呢或是獲得前一次迭代的值？使用 <tt class="docutils literal"><span class="pre">do</span></tt> 的話，它獲得後者的值：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="ss">&#39;a</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">y</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
        <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">x</span> <span class="mi">5</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;(~A ~A)  &quot;</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
<span class="p">(</span><span class="mi">1</span> <span class="nv">A</span><span class="p">)</span>  <span class="p">(</span><span class="mi">2</span> <span class="mi">1</span><span class="p">)</span>  <span class="p">(</span><span class="mi">3</span> <span class="mi">2</span><span class="p">)</span>  <span class="p">(</span><span class="mi">4</span> <span class="mi">3</span><span class="p">)</span>  <span class="p">(</span><span class="mi">5</span> <span class="mi">4</span><span class="p">)</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>每一次迭代時， <tt class="docutils literal"><span class="pre">x</span></tt> 獲得先前的值加一； <tt class="docutils literal"><span class="pre">y</span></tt> 也獲得 <tt class="docutils literal"><span class="pre">x</span></tt> 的前一次數值。</p>
<p>但也有一個 <tt class="docutils literal"><span class="pre">do*</span></tt> ，它有著 <tt class="docutils literal"><span class="pre">let</span></tt> 與 <tt class="docutils literal"><span class="pre">let*</span></tt> 同樣的關係。任何 <tt class="docutils literal"><span class="pre">initial</span></tt> 或 <tt class="docutils literal"><span class="pre">update</span></tt> 形式可以參照到前一個子句的變數，並會獲得當下的值：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">do*</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">y</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
     <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">x</span> <span class="mi">5</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;(~A ~A) &quot;</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">5</span><span class="p">)</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>除了 <tt class="docutils literal"><span class="pre">do</span></tt> 與 <tt class="docutils literal"><span class="pre">do*</span></tt> 之外，也有幾個特別用途的迭代運算元。要迭代一個列表的元素，我們可以使用 <tt class="docutils literal"><span class="pre">dolist</span></tt> :</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="ss">&#39;done</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A &quot;</span> <span class="nv">x</span><span class="p">))</span>
<span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span>
<span class="nv">DONE</span>
</pre></div>
</td></tr></table></div>
<p>當迭代結束時，初始列表內的第三個元素 (譯註: <tt class="docutils literal"><span class="pre">done</span></tt> ) ，會被求值並作為 <tt class="docutils literal"><span class="pre">dolist</span></tt> 的回傳值。預設是 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</p>
<p>有著同樣的精神的是 <tt class="docutils literal"><span class="pre">dotimes</span></tt> ，給定某個 <tt class="docutils literal"><span class="pre">n</span></tt> ，從整數 <tt class="docutils literal"><span class="pre">0</span></tt> 迭代至 <tt class="docutils literal"><span class="pre">n-1</span></tt> :</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">x</span> <span class="mi">5</span> <span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A &quot;</span> <span class="nv">x</span><span class="p">))</span>
<span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span>
<span class="mi">5</span>
</pre></div>
</td></tr></table></div>
<p>使用 <tt class="docutils literal"><span class="pre">dolist</span></tt> ，初始列表內的第三個元素是選擇性的，預設是 <tt class="docutils literal"><span class="pre">nil</span></tt> 。注意它可以參照到迭代裡的變數。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>do 的重點 (THE POINT OF do)</p>
<p>在 “The Evolution of Lisp” 裡，Steele 與 Garbriel 陳述了 do 的重點，
表達的實在太好了，值得整個在這裡引用過來：</p>
<p>撇開爭論語法不談，有件事要說明的是，在任何一個程式語言中，一個迴圈若一次只能更新一個變數是毫無用處的。
幾乎在任何情況下，會有一個變數用來產生下個值，而另一個變數用來累積結果。如果迴圈語法只能產生變數，
那麼累積結果就得藉由賦值語句來“手動”實現…或有其他的副作用。具有多變數的 do 迴圈，體現了產生與累積的
本質對稱性，允許可以沒有副作用地表達迭代過程：</p>
<div class="highlight-cl"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">factorial</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">j</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">j</span> <span class="mi">1</span><span class="p">))</span>
       <span class="p">(</span><span class="nv">f</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">j</span> <span class="nv">f</span><span class="p">)))</span>
    <span class="p">((</span><span class="nb">=</span> <span class="nv">j</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">f</span><span class="p">)))</span>
</pre></div>
</div>
<p class="last">當然在 step 形式裡實現所有的實際工作，一個沒有主體的 do 迴圈形式是較不尋常的。</p>
</div>
<p>函數 <tt class="docutils literal"><span class="pre">mapc</span></tt> 和 <tt class="docutils literal"><span class="pre">mapcar</span></tt> 很像，但不會 <tt class="docutils literal"><span class="pre">cons</span></tt> 一個新列表作為回傳值，所以使用它的唯一原因是為了副作用。它比 <tt class="docutils literal"><span class="pre">dolist</span></tt> 來得靈活，因為它可以同時遍歷多個列表：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapc</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A ~A  &quot;</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">))</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="nv">hip</span> <span class="nv">flip</span> <span class="nv">slip</span><span class="p">)</span>
      <span class="o">&#39;</span><span class="p">(</span><span class="nv">hop</span> <span class="nv">flop</span> <span class="nv">slop</span><span class="p">))</span>
<span class="nv">HIP</span> <span class="nv">HOP</span>  <span class="nv">FLIP</span> <span class="nv">FLOP</span>  <span class="nv">SLIP</span> <span class="nv">SLOP</span>
<span class="p">(</span><span class="nv">HIP</span> <span class="nv">FLIP</span> <span class="nv">SLIP</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>它總是回傳第二個參數。</p>
</div>
<div class="section" id="multiple-values">
<h2>5.5 多值 (Multiple Values)<a class="headerlink" href="#multiple-values" title="永久链接至标题">¶</a></h2>
<p>曾有人這麼說，為了要強調函數式程式設計的重要性，每個 Lisp 表達式都回傳一個值。現在事情不是這麼簡單了；在 Common Lisp 裡，一個表達式可以回傳零個或多個數值。最多可以回傳幾個值取決於各家實現，但至少可以回傳 19 個值。</p>
<p>多值允許一個函數計算多件事情來回傳它們，而不用建造一個包含它們的結構。舉例來說，內建的 <tt class="docutils literal"><span class="pre">get-decoded-time</span></tt> 回傳 9 個數值來表示現在的時間：秒，分，時，日期，月，天以及另外兩個。</p>
<p>多值也讓查詢函數可以分辨出 <tt class="docutils literal"><span class="pre">nil</span></tt> 及查詢失敗的情況。這也是為什麼 <tt class="docutils literal"><span class="pre">gethash</span></tt> 回傳兩個值。因為它使用第二個數值來指出成功或失敗，我們可以在雜湊表裡儲存 <tt class="docutils literal"><span class="pre">nil</span></tt> ，就像我們可以儲存別的數值那樣。</p>
<p><tt class="docutils literal"><span class="pre">values</span></tt> 函數回傳多個數值。它一個不少地回傳你作為數值所傳入的參數：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">values</span> <span class="ss">&#39;a</span> <span class="no">nil</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">))</span>
<span class="nv">A</span>
<span class="no">NIL</span>
<span class="mi">6</span>
</pre></div>
</td></tr></table></div>
<p>如果一個 <tt class="docutils literal"><span class="pre">values</span></tt> 表達式是函數主體最後求值的表達式，它所回傳的數值變成函數的回傳值。多值可以原封不地透過任何數量的回傳來傳遞：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">()</span> <span class="p">(</span><span class="nb">values</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))))</span>
<span class="mi">1</span>
<span class="mi">2</span>
</pre></div>
</td></tr></table></div>
<p>然而若只預期一個回傳值時，第一個之外的值會被捨棄：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">values</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="nv">x</span><span class="p">)</span>
<span class="mi">1</span>
</pre></div>
</td></tr></table></div>
<p>藉由不帶參數使用 <tt class="docutils literal"><span class="pre">values</span></tt> ，是可能不回傳值的。在這個情況下，預期一個回傳值的話，會獲得 <tt class="docutils literal"><span class="pre">nil</span></tt> :</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">values</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">values</span><span class="p">)))</span>
    <span class="nv">x</span><span class="p">)</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>要接收多個數值，我們使用 <tt class="docutils literal"><span class="pre">multiple-value-bind</span></tt> :</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">list</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="no">NIL</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>如果變數的數量大於數值的數量，剩餘的變數會是 <tt class="docutils literal"><span class="pre">nil</span></tt> 。如果數值的數量大於變數的數量，多餘的值會被捨棄。所以只想印出時間我們可以這麼寫:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">m</span> <span class="nv">h</span><span class="p">)</span> <span class="p">(</span><span class="nb">get-decoded-time</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;~A:~A:~A&quot;</span> <span class="nv">h</span> <span class="nv">m</span> <span class="nv">s</span><span class="p">))</span>
<span class="s">&quot;4:32:13&quot;</span>
</pre></div>
</td></tr></table></div>
<p>你可以藉由 <tt class="docutils literal"><span class="pre">multiple-value-call</span></tt> 將多值作為參數傳遞到第二個函數：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">multiple-value-call</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="p">(</span><span class="nb">values</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="mi">6</span>
</pre></div>
</td></tr></table></div>
<p>也有一個函數是 <tt class="docutils literal"><span class="pre">multiple-value-list</span></tt> :</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">multiple-value-list</span> <span class="p">(</span><span class="nb">values</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>看起來像是使用 <tt class="docutils literal"><span class="pre">#'list</span></tt> 作為第一個參數的來呼叫 <tt class="docutils literal"><span class="pre">multiple-value-call</span></tt> 。</p>
</div>
<div class="section" id="aborts">
<h2>5.6 中止 (Aborts)<a class="headerlink" href="#aborts" title="永久链接至标题">¶</a></h2>
<p>你可以使用 <tt class="docutils literal"><span class="pre">return</span></tt> 在任何時候離開一個 <tt class="docutils literal"><span class="pre">block</span></tt> 。有時候我們想要做更極端的事，在數個函數呼叫中將控制權轉移回來。要達成這件事我們使用 <tt class="docutils literal"><span class="pre">catch</span></tt> 與 <tt class="docutils literal"><span class="pre">throw</span></tt> 。一個 <tt class="docutils literal"><span class="pre">catch</span></tt> 表達式接受一個標籤 (tag)，標籤可以是任何種類的物件，伴隨著一個表達式主體：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">super</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">catch</span> <span class="ss">&#39;abort</span>
    <span class="p">(</span><span class="nv">sub</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;We&#39;ll never see this.&quot;</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">sub</span> <span class="p">()</span>
  <span class="p">(</span><span class="k">throw</span> <span class="ss">&#39;abort</span> <span class="mi">99</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>表達式依序求值，就像它們是在 <tt class="docutils literal"><span class="pre">progn</span></tt> 裡一樣。在這段程式碼裡的任何地方，一個帶有特定標籤的 <tt class="docutils literal"><span class="pre">throw</span></tt> 會導致 <tt class="docutils literal"><span class="pre">catch</span></tt> 表達式直接回傳：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">super</span><span class="p">)</span>
<span class="mi">99</span>
</pre></div>
</td></tr></table></div>
<p>一個帶有給定標籤的 <tt class="docutils literal"><span class="pre">throw</span></tt> ，為了要到達匹配標籤的 <tt class="docutils literal"><span class="pre">catch</span></tt> ，會將控制權轉移 (因此殺掉進程)給任何有別的標籤的 <tt class="docutils literal"><span class="pre">catch</span></tt> 。如果沒有一個 <tt class="docutils literal"><span class="pre">catch</span></tt> 符合欲匹配的標籤時， <tt class="docutils literal"><span class="pre">throw</span></tt> 會產生一個錯誤。</p>
<p>呼叫 <tt class="docutils literal"><span class="pre">error</span></tt> 同時中斷了執行，本來會將控制權轉移到呼叫樹 (calling tree)的更高點，取而代之的是它將控制權轉移給 Lisp 錯誤處理器 (error handler)。通常會導致呼叫一個中斷迴圈 (break loop)。以下是一個假設的 Common Lisp 實現可能會發生的事情：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span>
    <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;Oops!&quot;</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="s">&quot;After the error.&quot;</span><span class="p">))</span>
<span class="nv">Error:</span> <span class="nv">Oops!</span>
       <span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace</span>
<span class="nv">&gt;&gt;</span>
</pre></div>
</td></tr></table></div>
<p>譯註：2 個 <tt class="docutils literal"><span class="pre">&gt;&gt;</span></tt> 顯示出我們進入中斷循環了。</p>
<p>關於錯誤與狀態的更多訊息，參見 14.6 小節及附錄 A。</p>
<p>有時候你想要程式碼防止被 <tt class="docutils literal"><span class="pre">throw</span></tt> 與 <tt class="docutils literal"><span class="pre">error</span></tt> 打斷。藉由使用 <tt class="docutils literal"><span class="pre">unwind-protect</span></tt> ，你可以確保像是前述的中斷不會讓你的程式停在一個不一致的狀態。一個 <tt class="docutils literal"><span class="pre">unwind-protect</span></tt> 接受任何數量的參數並回傳第一個參數的值。然而即便是第一個參數的求值被打斷時，剩下的表達式仍會被求值：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
<span class="mi">1</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">catch</span> <span class="ss">&#39;abort</span>
    <span class="p">(</span><span class="k">unwind-protect</span>
      <span class="p">(</span><span class="k">throw</span> <span class="ss">&#39;abort</span> <span class="mi">99</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
<span class="mi">99</span>
<span class="nb">&gt;</span> <span class="nv">x</span>
<span class="mi">2</span>
</pre></div>
</td></tr></table></div>
<p>在這裡，即便 <tt class="docutils literal"><span class="pre">throw</span></tt> 將控制權交回監測的 <tt class="docutils literal"><span class="pre">catch</span></tt> ， <tt class="docutils literal"><span class="pre">unwind-protect</span></tt> 確保控制權移交時，第二個表達式有被求值。無論何時，一個確切的動作要伴隨著某種清理或重置時， <tt class="docutils literal"><span class="pre">unwind-protect</span></tt> 可能會是有用的。在 121 頁提到了一個例子。</p>
</div>
<div class="section" id="example-date-arithmetic">
<h2>5.7 範例：日期運算 (Example: Date Arithmetic)<a class="headerlink" href="#example-date-arithmetic" title="永久链接至标题">¶</a></h2>
<p>在某些應用裡，能夠做日期的加減是很有用的––舉例來說，能夠算出從 1997 年 12 月 17 日，六十天之後是 1998 年 2 月 15 日。在這個小節裡，我們會編寫一個實用的工具來做日期運算。我們會將日期轉成整數，起始點設置在 2000 年 1 月 1 日。我們會使用內建的 <tt class="docutils literal"><span class="pre">+</span></tt> 與 <tt class="docutils literal"><span class="pre">-</span></tt> 函數來處理這些數字，而當我們轉換完畢時，將結果轉回一個日期。</p>
<p>要將日期轉成數字，我們需要從日期的單位中，算出總天數有多少。舉例來說，2004 年 11 月 13 日的天數總和，是從起始點至 2004 年有多少天，加上從 2004 年到 2004 年 11 月有多少天，再加上 13 天。</p>
<p>有一個我們需要的東西是，一張列出非潤年每月份有多少天的表格。我們可以使用 Lisp 來推出這個表格的內容。我們從列出每月份的長度開始：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">mon</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">31</span> <span class="mi">28</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span><span class="p">))</span>
<span class="p">(</span><span class="mi">31</span> <span class="mi">28</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>我們可以藉由套用 <tt class="docutils literal"><span class="pre">+</span></tt> 函數至這個列表來測試總長度：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="nv">mon</span><span class="p">)</span>
<span class="mi">365</span>
</pre></div>
</td></tr></table></div>
<p>現在如果我們反轉這個列表並使用 <tt class="docutils literal"><span class="pre">maplist</span></tt> 來應用 <tt class="docutils literal"><span class="pre">+</span></tt> 函數至每下一個 <tt class="docutils literal"><span class="pre">cdr</span></tt> 上，我們可以獲得從每個月份開始所累積的天數：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">nom</span> <span class="p">(</span><span class="nb">reverse</span> <span class="nv">mon</span><span class="p">))</span>
<span class="p">(</span><span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">30</span> <span class="mi">31</span> <span class="mi">28</span> <span class="mi">31</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">sums</span> <span class="p">(</span><span class="nb">maplist</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
                          <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">+</span> <span class="nv">x</span><span class="p">))</span>
                      <span class="nv">nom</span><span class="p">))</span>
<span class="p">(</span><span class="mi">365</span> <span class="mi">334</span> <span class="mi">304</span> <span class="mi">273</span> <span class="mi">243</span> <span class="mi">212</span> <span class="mi">181</span> <span class="mi">151</span> <span class="mi">120</span> <span class="mi">90</span> <span class="mi">59</span> <span class="mi">31</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>這些數字體現了從二月一號開始已經過了 31 天，從三月一號開始已經過了 59 天…等等。</p>
<p>我們剛剛建立的這個列表，可以轉換成一個向量，見圖 5.1，它包含了轉換日期至整數的程式碼。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defconstant</span> <span class="nv">month</span>
  <span class="o">#(</span><span class="mi">0</span> <span class="mi">31</span> <span class="mi">59</span> <span class="mi">90</span> <span class="mi">120</span> <span class="mi">151</span> <span class="mi">181</span> <span class="mi">212</span> <span class="mi">243</span> <span class="mi">273</span> <span class="mi">304</span> <span class="mi">334</span> <span class="mi">365</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defconstant</span> <span class="nv">yzero</span> <span class="mi">2000</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">leap?</span> <span class="p">(</span><span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">y</span> <span class="mi">4</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">y</span> <span class="mi">400</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">y</span> <span class="mi">100</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">date-&gt;num</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">d</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">month-num</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">year-num</span> <span class="nv">y</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">month-num</span> <span class="p">(</span><span class="nv">m</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">month</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">))</span>
     <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">m</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nv">leap?</span> <span class="nv">y</span><span class="p">))</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">year-num</span> <span class="p">(</span><span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">d</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;=</span> <span class="nv">y</span> <span class="nv">yzero</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">y</span> <span class="nv">yzero</span><span class="p">)</span> <span class="nv">d</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">incf</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">yzero</span> <span class="nv">i</span><span class="p">))))</span>
        <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">yzero</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">d</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">incf</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="nv">i</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">year-days</span> <span class="p">(</span><span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">leap?</span> <span class="nv">y</span><span class="p">)</span> <span class="mi">366</span> <span class="mi">365</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p><strong>圖 5.1 日期運算：轉換日期至數字</strong></p>
<p>一個典型 Lisp 程式的生命週期有四個階段：先寫好，然後讀入，接著編譯，最後執行。有件 Lisp 非常獨特的事情之一是，在這四個階段時， Lisp 一直都在那裡。你可以在你的程式編譯 (參見 10.2 小節)或讀入時 (參見 14.3 小節) 來呼叫 Lisp。我們推導出 <tt class="docutils literal"><span class="pre">month</span></tt> 的方法示範了，你如何在撰寫一個程式時使用 Lisp。</p>
<p>效率通常只跟第四個階段有關係，執行期 (run-time)。在前三個階段，你可以隨意的使用列表擁有的威力與彈性，不需要擔心效率。</p>
<p>若你使用圖 5.1 的程式碼來推出一個時光機器 (time machine)，當你抵達時，人們大概會不同意你的日期。即使是相對近的現在，歐洲的日期曾有過偏移，因為人們會獲得更精準的每年有多長的概念。在說英語的國家，最後一次的不連續性出現在 1752 年，日期從 9 月 2 日跳到 9 月 14 日。</p>
<p>每年有幾天取決於它是否是潤年。我們說某一年是潤年，如果這年可以被四整除，除非這年可以被 100 整除，則此年非潤年––而要是它可以被 400 整除，則是潤年。所以 1904 年是潤年，1900 年不是，而 1600 年是。</p>
<p>要決定某一個數是否可以被另一個數除，我們使用函數 <tt class="docutils literal"><span class="pre">mod</span></tt> ，它回傳相除後的餘數：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mod</span> <span class="mi">23</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">3</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mod</span> <span class="mi">25</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">0</span>
</pre></div>
</td></tr></table></div>
<p>如果第一個參數除以第二個參數的餘數為 0，則第一個參數是可以被第二個參數整除的。函數 <tt class="docutils literal"><span class="pre">leap?</span></tt> 使用了這個方法，來決定它的參數是否是一個潤年：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nv">leap?</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1904</span> <span class="mi">1900</span> <span class="mi">1600</span><span class="p">))</span>
<span class="p">(</span><span class="no">T</span> <span class="no">NIL</span> <span class="no">T</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>我們用來轉換日期至整數的函數是 <tt class="docutils literal"><span class="pre">date-&gt;num</span></tt> 。它回傳日期中每個單位的天數總和。要找到從某月份開始的天數和，我們呼叫 <tt class="docutils literal"><span class="pre">month-num</span></tt> ，它在 <tt class="docutils literal"><span class="pre">month</span></tt> 中查詢天數，如果是在潤年的二月之後，則加一。</p>
<p>要找到從某年開始的天數和， <tt class="docutils literal"><span class="pre">date-&gt;num</span></tt> 呼叫 <tt class="docutils literal"><span class="pre">year-num</span></tt> ，它回傳某年一月一日相對於起始點 (2000.01.01)所代表的天數。這個函數的工作方式是從傳入的參數 <tt class="docutils literal"><span class="pre">y</span></tt> 年開始，朝著起始年 (2000)往上或往下數。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">num-&gt;date</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">left</span><span class="p">)</span> <span class="p">(</span><span class="nv">num-year</span> <span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">m</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nv">num-month</span> <span class="nv">left</span> <span class="nv">y</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">values</span> <span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">num-year</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">do*</span> <span class="p">((</span><span class="nv">y</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">yzero</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">d</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))))</span>
           <span class="p">((</span><span class="nb">&lt;=</span> <span class="nv">d</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">))))</span>
      <span class="p">(</span><span class="nb">do*</span> <span class="p">((</span><span class="nv">y</span> <span class="nv">yzero</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">prev</span> <span class="mi">0</span> <span class="nv">d</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))))</span>
           <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">d</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">prev</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">num-month</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">leap?</span> <span class="nv">y</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">n</span> <span class="mi">59</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="mi">2</span> <span class="mi">29</span><span class="p">))</span>
            <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">n</span> <span class="mi">59</span><span class="p">)</span> <span class="p">(</span><span class="nv">nmon</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="p">(</span><span class="no">t</span>        <span class="p">(</span><span class="nv">nmon</span> <span class="nv">n</span><span class="p">)))</span>
      <span class="p">(</span><span class="nv">nmon</span> <span class="nv">n</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">nmon</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">m</span> <span class="p">(</span><span class="nb">position</span> <span class="nv">n</span> <span class="nv">month</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">&lt;</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">values</span> <span class="nv">m</span> <span class="p">(</span><span class="nb">+</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="p">(</span><span class="nb">svref</span> <span class="nv">month</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">m</span> <span class="mi">1</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">date+</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">num-&gt;date</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">date-&gt;num</span> <span class="nv">d</span> <span class="nv">m</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">n</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p><strong>圖 5.2 日期運算：轉換數字至日期</strong></p>
<p>圖 5.2 展示了程式碼的下半部份。函數 <tt class="docutils literal"><span class="pre">num-&gt;date</span></tt> 將整數轉換回日期。它呼叫了 <tt class="docutils literal"><span class="pre">num-year</span></tt> 函數，以日期的格式回傳年以及剩餘的天數。它將剩餘的天數傳給 <tt class="docutils literal"><span class="pre">num-month</span></tt> ，分解出月與日。</p>
<p>和 <tt class="docutils literal"><span class="pre">year-num</span></tt> 一樣， <tt class="docutils literal"><span class="pre">num-year</span></tt> 從起始年往上或下數，一次數一年。它持續累積天數，直到它獲得一個絕對值大於或等於 <tt class="docutils literal"><span class="pre">n</span></tt>  的數。如果它往下數，那麼它可以回傳當前迭代中的數值。不然它會超過年份，然後必須回傳前次迭代的數值。這也是為什麼要使用 <tt class="docutils literal"><span class="pre">prev</span></tt> ， <tt class="docutils literal"><span class="pre">prev</span></tt> 在每次迭代時會被存入 <tt class="docutils literal"><span class="pre">days</span></tt> 在前次迭代的數值。</p>
<p>函數 <tt class="docutils literal"><span class="pre">num-month</span></tt> 以及它的副程式 (subroutine) <tt class="docutils literal"><span class="pre">nmon</span></tt> 的行為像是相反地 <tt class="docutils literal"><span class="pre">month-num</span></tt> 。他們從常數向量 <tt class="docutils literal"><span class="pre">month</span></tt> 的數值到位置，然而 <tt class="docutils literal"><span class="pre">month-num</span></tt> 從位置到數值。</p>
<p>圖 5.2 的前兩個函數可以合而為一。與其回傳數值給另一個函數， <tt class="docutils literal"><span class="pre">num-year</span></tt> 可以直接呼叫 <tt class="docutils literal"><span class="pre">num-month</span></tt> 。現在分成兩個的程式碼比較容易交互測試，但是現在它可以工作了，下一步或許是把它合而為一。</p>
<p>有了 <tt class="docutils literal"><span class="pre">date-&gt;num</span></tt> 與 <tt class="docutils literal"><span class="pre">num-&gt;date</span></tt> ，日期運算是很簡單的。我們在 <tt class="docutils literal"><span class="pre">date+</span></tt> 裡使用它們，可以從特定的日期做加減。如果我們想透過 <tt class="docutils literal"><span class="pre">date+</span></tt> 來知道 1997 年 12 月 17 日六十天之後的日期:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">multiple-value-list</span> <span class="p">(</span><span class="nv">date+</span> <span class="mi">17</span> <span class="mi">12</span> <span class="mi">1997</span> <span class="mi">60</span><span class="p">))</span>
<span class="p">(</span><span class="mi">15</span> <span class="mi">2</span> <span class="mi">1988</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>我們得到 1988 年 2 月 15 日。</p>
</div>
<div class="section" id="chapter-5-summary">
<h2>Chapter 5 總結 (Summary)<a class="headerlink" href="#chapter-5-summary" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li>Common Lisp 有三個基本的區塊建構子： <tt class="docutils literal"><span class="pre">progn</span></tt> ；允許返回的 <tt class="docutils literal"><span class="pre">block</span></tt> ；以及允許 <tt class="docutils literal"><span class="pre">goto</span></tt> 的 <tt class="docutils literal"><span class="pre">tagbody</span></tt> 。很多內建的運算元都隱含著區塊。</li>
<li>進入一個新的詞法語境概念上等同於函數呼叫。</li>
<li>Common Lisp 提供了適合不同情況的條件式。每個都可以使用 <tt class="docutils literal"><span class="pre">if</span></tt> 來定義。</li>
<li>有數個相似迭代運算元的變種。</li>
<li>表達式可以回傳多個數值。</li>
<li>計算過程可以被中斷以及保護，保護可使其免於中斷所造成的後果。</li>
</ol>
</div>
<div class="section" id="chapter-5-exercises">
<h2>Chapter 5 練習 (Exercises)<a class="headerlink" href="#chapter-5-exercises" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li>將下列表達式翻譯成沒有使用 <tt class="docutils literal"><span class="pre">let</span></tt> 與 <tt class="docutils literal"><span class="pre">let*</span></tt> ，並使同樣的表達式不被求值 2 次。</li>
</ol>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">w</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">))</span>
           <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">w</span> <span class="nv">z</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="nv">w</span> <span class="nv">y</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<ol class="arabic simple" start="2">
<li>使用 <tt class="docutils literal"><span class="pre">cond</span></tt> 重寫 29 頁的 <tt class="docutils literal"><span class="pre">mystery</span></tt> 函數。（譯註: 第二章的練習第 5 題的 (b) 部分)</li>
<li>定義一個回傳其參數平方的函數，而當參數是一個正整數且小於等於 5 時，不要計算其平方。</li>
<li>使用 <tt class="docutils literal"><span class="pre">case</span></tt> 與 <tt class="docutils literal"><span class="pre">svref</span></tt> 重寫 <tt class="docutils literal"><span class="pre">month-num</span></tt> (圖 5.1)。</li>
<li>定義一個迭代與遞迴版本的函數，接受一個物件 x 與向量 v，並回傳一個列表，包含了向量 v 當中，所有直接在 x 之前的物件：</li>
</ol>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">precedes</span> <span class="sc">#\a</span> <span class="s">&quot;abracadabra&quot;</span><span class="p">)</span>
<span class="p">(</span><span class="sc">#\c</span> <span class="sc">#\d</span> <span class="sc">#\r</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<ol class="arabic simple" start="6">
<li>定義一個迭代與遞迴版本的函數，接受一個物件與列表，並回傳一個新的列表，在原本列表的物件之間加上傳入的物件：</li>
</ol>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">intersperse</span> <span class="ss">&#39;-</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nb">-</span> <span class="nv">B</span> <span class="nb">-</span> <span class="nv">C</span> <span class="nb">-</span> <span class="nv">D</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<ol class="arabic simple" start="7">
<li>定義一個接受一系列數字的函數，並在若且唯若每一對 (pair)數字的差為一時，回傳真，使用</li>
</ol>
<div class="highlight-cl"><pre>(a) 遞迴
(b) do
(c) mapc 與 return</pre>
</div>
<ol class="arabic simple" start="8">
<li>定義一個單遞迴函數，回傳兩個值，分別是向量的最大與最小值。</li>
<li>圖 3.12 的程式在找到一個完整的路徑時仍持續遊遍佇列。在搜索範圍大時，這可能會產生問題。</li>
</ol>
<div class="highlight-cl"><pre>(a) 使用 catch 與 throw 來變更程式，使其找到第一個完整路徑時，直接回傳它。
(b) 重寫一個做到同樣事情的程式，但不使用 catch 與 throw。</pre>
</div>
</div>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'acl-chinese';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                  </div></div>
              </article><div class="clearer"></div>
          </div><div class="span3">
                <div class="sphinxsidebar">
      <div id="sidenav" class="box sphinxsidebarwrapper">


<h4><a href="../index.html">內容目录</a></h4>
  <ul>
<li><a class="reference internal" href="#">第五章：控制流程</a><ul>
<li><a class="reference internal" href="#blocks">5.1 區塊 (Blocks)</a></li>
<li><a class="reference internal" href="#context">5.2 語境 (Context)</a></li>
<li><a class="reference internal" href="#conditionals">5.3 條件 (Conditionals)</a></li>
<li><a class="reference internal" href="#iteration">5.4 迭代 (Iteration)</a></li>
<li><a class="reference internal" href="#multiple-values">5.5 多值 (Multiple Values)</a></li>
<li><a class="reference internal" href="#aborts">5.6 中止 (Aborts)</a></li>
<li><a class="reference internal" href="#example-date-arithmetic">5.7 範例：日期運算 (Example: Date Arithmetic)</a></li>
<li><a class="reference internal" href="#chapter-5-summary">Chapter 5 總結 (Summary)</a></li>
<li><a class="reference internal" href="#chapter-5-exercises">Chapter 5 練習 (Exercises)</a></li>
</ul>
</li>
</ul>

  
    <h3>本页</h3>
    <ul class="this-page-menu">
      
      
        <li><a href="https://github.com/acl-translation/acl-chinese/blob/redirect-to-new-domain/zhTW/ch5.rst">
          Show on GitHub</a></li>
        <li><a href="https://github.com/acl-translation/acl-chinese/edit/redirect-to-new-domain/zhTW/ch5.rst">
          Edit on GitHub</a></li>
      
    </ul>
  
</div>
    </div>
              </div></div>
      </div>
<footer class="container-fluid">
        <hr />&copy; 版权所有 2012, Juanito Fatas Huang.最后更新日期是 Apr 22, 2013.使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.</footer>
 <!-- End original user content -->


<br>
<br>
<br>


<style type="text/css">
  .rtd-badge {
    position: fixed;
    display: block;
    bottom: 5px;
    height: 40px;
    text-indent: -9999em;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
    -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
  }
  #version_menu {
    position: fixed;
    display: none;
    bottom: 11px;
    right: 166px;
    list-style-type: none;
    margin: 0;
  }
  .footer_popout:hover #version_menu {
    display: block;
  }
  #version_menu li {
    display: block;
    float: right;
  }
  #version_menu li a {
    display: block;
    padding: 6px 10px 4px 10px;
    margin: 7px 7px 0 0;
    font-weight: bold;
    font-size: 14px;
    height: 20px;
    line-height: 17px;
    text-decoration: none;
    color: #fff;
    background: #8ca1af url(../images/gradient-light.png) bottom left repeat-x;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    box-shadow: 0 1px 1px #465158;
    -moz-box-shadow: 0 1px 1px #465158;
    -webkit-box-shadow: 0 1px 1px #465158;
    text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
  }
  #version_menu li a:hover {
    text-decoration: none;
    background-color: #697983;
    box-shadow: 0 1px 0px #465158;
    -moz-box-shadow: 0 1px 0px #465158;
    -webkit-box-shadow: 0 1px 0px #465158;
  }
  .rtd-badge.rtd {
    background: #3b4449 url(//media.readthedocs.org//images/badge-rtd.png) scroll 0px -46px no-repeat;
    border: 1px solid #282E32;
    width: 41px;
    right: 5px;
  }
  .footer_popout:hover .rtd-badge.rtd {
    background-position: top left;
    width: 160px;
  }
  .rtd-badge.revsys { background: #465158 url(//media.readthedocs.org//images/badge-revsys.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 290px;
    right: 173px;
  }
  .rtd-badge.revsys-inline-sponsored {
    position: inherit;
    margin-left: auto;
    margin-right: 175px;
    margin-bottom: 5px;
    background: #465158 url(//media.readthedocs.org//images/badge-revsys.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 290px;
    right: 173px;
  }
  .rtd-badge.revsys-inline {
    position: inherit;
    margin-left: auto;
    margin-right: 175px;
    margin-bottom: 5px;
    background: #465158 url(//media.readthedocs.org//images/badge-revsys-sm.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 205px;
    right: 173px;
  }

</style>
<div class="rtd_doc_footer">
  <div class="footer_popout">
    <a href="//readthedocs.org/projects/ansi-common-lisp/?fromdocs=ansi-common-lisp" class="rtd-badge rtd"> Brought to you by Read the Docs</a>
    <ul id="version_menu">
      
        <li><a href="/en/latest/">latest</a></li>
      
    </ul>
  </div>
</div>
<!-- RTD Analytics Code -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


<!-- User Analytics Code -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-26995626-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</body>
</html>