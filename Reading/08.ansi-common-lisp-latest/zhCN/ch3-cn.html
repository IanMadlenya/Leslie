<!DOCTYPE HTML>

  <html xmlns="http://www.w3.org/1999/xhtml" lang="zh">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
<title>第三章：列表 &mdash; ANSI Common Lisp 中文版</title>
    
<!-- RTD <head> -->
<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript" src="//media.readthedocs.org/javascript/underscore.js"></script>
<script type="text/javascript" src="//media.readthedocs.org/javascript/doctools.js"></script>

<script type="text/javascript">
  // This is included here for Javascript that doesn't have access to the templates.
  var doc_version = "latest";
  var doc_slug = "ansi-common-lisp";
</script>

<script type="text/javascript" src="//media.readthedocs.org/javascript/rtd.js"></script>
<!-- end RTD <head> -->

    <link rel="stylesheet" href="../_static/han.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/rosefinch.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/main.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:       '../',
        VERSION:        '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX:    '.html',
        HAS_SOURCE:     true
      };
    </script>
    <script type="text/javascript" src="../_static/han.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src=../_static/jquery.dimensions.js"></script>
  <script type="text/javascript" src="../_static/main.js"></script><link rel="top" title="ANSI Common Lisp 中文版" href="../index.html" /></head>

  <body><div class="navbar navbar-static-top navbar-inverse">
        <div id="top-bar" class="navbar-inner">

          <h1 id="logo">ANSI Common Lisp 中文版<a href="../index.html" class="brand">ANSI Common Lisp 中文版</a></h1>
          <ul class="nav"></ul><a href="https://github.com/acl-translation/acl-chinese"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub"></a>
        </div>
      </div><div class="content container-fluid">
        <div class="row-fluid"><div class="document span9"><article >
                <div class="documentwrapper"><div class="body"><div class="section" id="id1">
<h1>第三章：列表<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>列表是 Lisp 的基本数据结构之一。在最早的 Lisp 方言里，他们是唯一的数据结构： “Lisp” 这个名字起初是 “LISt Processor” 的缩写。但 Lisp 已经超越这个缩写很久了。 Common Lisp 是一个有着各式各样数据结构的通用性程序语言(general-purpose programming language)。</p>
<p>Lisp 程序开发通常呼应着开发 Lisp 语言自身。在最初版本的 Lisp 程序，你可能使用很多列表。然而之后的版本，你可能换到快速、特定的数据结构。本章描述了你可以用列表所做的很多事情，以​​及使用它们来演示一些普遍的 Lisp 概念。</p>
<div class="section" id="conses">
<h2>3.1 构建 (Conses)<a class="headerlink" href="#conses" title="永久链接至标题">¶</a></h2>
<p>在 2.4 节我们介绍了 <tt class="docutils literal"><span class="pre">cons</span></tt> , <tt class="docutils literal"><span class="pre">car</span></tt> , 以及 <tt class="docutils literal"><span class="pre">cdr</span></tt> ，基本的 List 操作函数。 <tt class="docutils literal"><span class="pre">cons</span></tt> 真正所做的事情是，把两个对象结合成一个有两部分的对象，称之为 <em>Cons</em> 对象。概念上来说，一个 <em>Cons</em> 是一对指针；第一个是 <tt class="docutils literal"><span class="pre">car</span></tt> ，第二个是 <tt class="docutils literal"><span class="pre">cdr</span></tt> 。</p>
<p><em>Cons</em> 对象提供了一个方便的表示法，来表示任何类型的对象。一个 <em>Cons</em> 对象里的一对指针，可以指向任何类型的对象，包括 <em>Cons</em> 对象本身。它利用到我们之后可以用 <tt class="docutils literal"><span class="pre">cons</span></tt> 来构建列表的可能性。</p>
<p>我们往往不会把列表想成是成对的，但它们可以这样被定义。任何非空的列表，都可以被视为一对由列表第一个元素及列表其余元素所组成的列表。 Lisp 列表体现了这个概念。我们使用 <em>Cons</em> 的一半来指向列表的第一个元素，然后用另一半指向列表其余的元素(可能是别的 <em>Cons</em> 或 <tt class="docutils literal"><span class="pre">nil</span></tt> )。 Lisp 的惯例是使用 <tt class="docutils literal"><span class="pre">car</span></tt> 代表列表的第一个元素，而用 <tt class="docutils literal"><span class="pre">cdr</span></tt> 代表列表的其余的元素。所以现在 <tt class="docutils literal"><span class="pre">car</span></tt> 是列表的第一个元素的同义词，而 <tt class="docutils literal"><span class="pre">cdr</span></tt> 是列表的其余的元素的同义词。列表不是不同的对象，而是像 <em>Cons</em> 这样的方式连结起来。</p>
<p>当我们想在 <tt class="docutils literal"><span class="pre">nil</span></tt> 上面建立东西时，</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="no">nil</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="figure">
<img alt="../_images/Figure-3.1.png" src="../_images/Figure-3.1.png" />
</div>
<p>图 3.1 一个元素的列表</p>
<p>产生的列表由一个 <em>Cons</em> 所组成，见图 3.1。这种表达 <em>Cons</em> 的方式叫做箱子表示法 (box notation)，因为每一个 Cons 是用一个箱子表示，内含一个 <tt class="docutils literal"><span class="pre">car</span></tt> 和 <tt class="docutils literal"><span class="pre">cdr</span></tt> 的指针。当我们调用 <tt class="docutils literal"><span class="pre">car</span></tt> 与 <tt class="docutils literal"><span class="pre">cdr</span></tt> 时，我们得到指针指向的地方：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span>
<span class="nv">A</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>当我们构建一个多元素的列表时，我们得到一串 <em>Cons</em> (a chain of conses):</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>产生的结构见图 3.2。现在当我们想得到列表的 <tt class="docutils literal"><span class="pre">cdr</span></tt> 时，它是一个两个元素的列表。</p>
<div class="figure">
<img alt="../_images/Figure-3.2.png" src="../_images/Figure-3.2.png" />
</div>
<p>图 3.2 三个元素的列表</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>在一个有多个元素的列表中， <tt class="docutils literal"><span class="pre">car</span></tt> 指针让你取得元素，而 <tt class="docutils literal"><span class="pre">cdr</span></tt> 让你取得列表内其余的东西。</p>
<p>一个列表可以有任何类型的对象作为元素，包括另一个列表：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">z</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">)</span> <span class="ss">&#39;d</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span> <span class="nv">D</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>当这种情况发生时，它的结构如图 3.3 所示；第二个 <em>Cons</em> 的 <tt class="docutils literal"><span class="pre">car</span></tt> 指针也指向一个列表：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">z</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="figure">
<img alt="../_images/Figure-3.3.png" src="../_images/Figure-3.3.png" />
</div>
<p>图 3.3 嵌套列表</p>
<p>前两个我们构建的列表都有三个元素；只不过 <tt class="docutils literal"><span class="pre">z</span></tt> 列表的第二个元素也刚好是一个列表。像这样的列表称为<em>嵌套</em>列表，而像 <tt class="docutils literal"><span class="pre">y</span></tt> 这样的列表称之为<em>平坦</em>列表 (<em>flat</em>list)。</p>
<p>如果参数是一个 <em>Cons</em> 对象，函数 <tt class="docutils literal"><span class="pre">consp</span></tt> 返回真。所以我们可以这样定义 <tt class="docutils literal"><span class="pre">listp</span></tt> :</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-listp</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>因为所有不是 <em>Cons</em> 对象的东西，就是一个原子 (atom)，判断式 <tt class="docutils literal"><span class="pre">atom</span></tt> 可以这样定义：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-atom</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>注意， <tt class="docutils literal"><span class="pre">nil</span></tt> 既是一个原子，也是一个列表。</p>
</div>
<div class="section" id="equality">
<h2>3.2 等式 (Equality)<a class="headerlink" href="#equality" title="永久链接至标题">¶</a></h2>
<p>每一次你调用 <tt class="docutils literal"><span class="pre">cons</span></tt> 时， Lisp 会配置一块新的内存给两个指针。所以如果我们用同样的参数调用 <tt class="docutils literal"><span class="pre">cons</span></tt> 两次，我们得到两个数值看起来一样，但实际上是两个不同的对象：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="no">nil</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="no">nil</span><span class="p">))</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>如果我们也可以询问两个列表是否有相同元素，那就很方便了。 Common Lisp 提供了这种目的另一个判断式： <tt class="docutils literal"><span class="pre">equal</span></tt> 。而另一方面 <tt class="docutils literal"><span class="pre">eql</span></tt> 只有在它的参数是相同对象时才返回真，</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="no">nil</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">)</span>
<span class="no">T</span>
</pre></div>
</td></tr></table></div>
<p>本质上 <tt class="docutils literal"><span class="pre">equal</span></tt> 若它的参数打印出的值相同时，返回真：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">equal</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="no">nil</span><span class="p">))</span>
<span class="no">T</span>
</pre></div>
</td></tr></table></div>
<p>这个判断式对非列表结构​​的别种对象也有效，但一种仅对列表有效的版本可以这样定义：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">our-equal</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)</span>
             <span class="p">(</span><span class="nb">consp</span> <span class="nv">y</span><span class="p">)</span>
             <span class="p">(</span><span class="nv">our-equal</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">our-equal</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>这个定义意味着，如果某个 <tt class="docutils literal"><span class="pre">x</span></tt> 和 <tt class="docutils literal"><span class="pre">y</span></tt> 相等( <tt class="docutils literal"><span class="pre">eql</span></tt> )，那么他们也相等( <tt class="docutils literal"><span class="pre">equal</span></tt> )。</p>
<p><strong>勘误:</strong> 这个版本的 <tt class="docutils literal"><span class="pre">our-equal</span></tt> 可以用在符号的列表 (list of symbols)，而不是列表 (list)。</p>
</div>
<div class="section" id="lisp-why-lisp-has-no-pointers">
<h2>3.3 为什么 Lisp 没有指针 (Why Lisp Has No Pointers)<a class="headerlink" href="#lisp-why-lisp-has-no-pointers" title="永久链接至标题">¶</a></h2>
<p>一个理解 Lisp 的秘密之一是意识到变量是有值的，就像列表有元素一样。如同 <em>Cons</em> 对象有指针指向他们的元素，变量有指针指向他们的值。</p>
<p>你可能在别的语言中使用过显式指针 (explicitly pointer)。在 Lisp，你永远不用这么做，因为语言帮你处理好指针了。我们已经在列表看过这是怎么实现的。同样的事情发生在变量身上。举例来说，假设我们想要把两个变量设成同样的列表：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre> <span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="figure">
<img alt="../_images/Figure-3.4.png" src="../_images/Figure-3.4.png" />
</div>
<p>图 3.4 两个变量设为相同的列表</p>
<p>当我们把 <tt class="docutils literal"><span class="pre">x</span></tt> 的值赋给 <tt class="docutils literal"><span class="pre">y</span></tt> 时，究竟发生什么事呢？内存中与 <tt class="docutils literal"><span class="pre">x</span></tt> 有关的位置并没有包含这个列表，而是一个指针指向它。当我们给 <tt class="docutils literal"><span class="pre">y</span></tt> 赋一个相同的值时， Lisp 复制的是指针，而不是列表。（图 3.4 显式赋值 <tt class="docutils literal"><span class="pre">x</span></tt> 给 <tt class="docutils literal"><span class="pre">y</span></tt> 后的结果）所以无论何时你把一个变量赋给另一个变量时，两个变量会有相同的值(<tt class="docutils literal"><span class="pre">eql</span></tt>)。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
<span class="no">T</span>
</pre></div>
</td></tr></table></div>
<p>Lisp 没有指针的原因是因为每一个值，其实概念上来说都是一个指针。当你赋一个值给变量或将这个值存在数据结构中，其实被储存的是指向这个值的指针。当你要取得变量的值，或是存在数据结构中的内容时， Lisp 返回指向这个值的指针。但这都在台面下发生。你可以不加思索地把值放在结构里，或放“在”变量里。</p>
<p>为了效率的原因， Lisp  有时会选择一个折衷的表示法，而不是指针。举例来说，因为一个小整数所需的内存空间，少于一个指针所需的空间，一个 Lisp 实现可能会直接处理这个小整数，而不是用指针来处理。但基本要点是，程序员预设可以把任何东西放在任何地方。除非你声明你不愿这么做，不然你能够在任何的数据结构，存放任何类型的对象，包括结构本身。</p>
</div>
<div class="section" id="building-lists">
<h2>3.4 建立列表 (Building Lists)<a class="headerlink" href="#building-lists" title="永久链接至标题">¶</a></h2>
<div class="figure">
<img alt="../_images/Figure-3.5.png" src="../_images/Figure-3.5.png" />
</div>
<p>图 3.5 复制的结果</p>
<p>函数 <tt class="docutils literal"><span class="pre">copy-list</span></tt> 接受一个列表，然后返回此列表的复本。新的列表会有同样的元素，但是装在新的 <em>Cons</em> 对象里：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
        <span class="nv">y</span> <span class="p">(</span><span class="nb">copy-list</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>图 3.5 展示出结果的结构; 返回值像是有着相同乘客的新公车。我们可以把 <tt class="docutils literal"><span class="pre">copy-list</span></tt> 想成是这么定义的：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-copy-list</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
 <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">lst</span><span class="p">)</span>
     <span class="nv">lst</span>
     <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nv">our-copy-list</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>这个定义暗示着 <tt class="docutils literal"><span class="pre">x</span></tt> 与 <tt class="docutils literal"><span class="pre">(copy-list</span> <span class="pre">x)</span></tt> 会永远 <tt class="docutils literal"><span class="pre">equal</span></tt> ，并永远不 <tt class="docutils literal"><span class="pre">eql</span></tt> ，除非 <tt class="docutils literal"><span class="pre">x</span></tt> 是 <tt class="docutils literal"><span class="pre">NIL</span></tt> 。</p>
<p>最后，函数 <tt class="docutils literal"><span class="pre">append</span></tt> 返回任何数目的列表串接 (concatenation)：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">append</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="ss">&#39;e</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span> <span class="nv">E</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>通过这么做，它复制所有的参数，除了最后一个</p>
</div>
<div class="section" id="example-compression">
<h2>3.5 示例：压缩 (Example: Compression)<a class="headerlink" href="#example-compression" title="永久链接至标题">¶</a></h2>
<p>作为一个例子，这节将演示如何实现简单形式的列表压缩。这个算法有一个令人印象深刻的名字，<em>游程编码</em>(run-length encoding)。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">compress</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">compr</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))</span>
      <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">compr</span> <span class="p">(</span><span class="nb">elt</span> <span class="nv">n</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nv">n-elts</span> <span class="nb">elt</span> <span class="nv">n</span><span class="p">))</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">next</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">next</span> <span class="nb">elt</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">compr</span> <span class="nb">elt</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">n-elts</span> <span class="nb">elt</span> <span class="nv">n</span><span class="p">)</span>
                  <span class="p">(</span><span class="nv">compr</span> <span class="nv">next</span> <span class="mi">1</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">n-elts</span> <span class="p">(</span><span class="nb">elt</span> <span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">list</span> <span class="nv">n</span> <span class="nb">elt</span><span class="p">)</span>
      <span class="nb">elt</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>图 3.6 游程编码 (Run-length encoding)：压缩</p>
<p>在餐厅的情境下，这个算法的工作方式如下。一个女服务生走向有四个客人的桌子。“你们要什么？” 她问。“我要特餐，” 第一个客人说。
“我也是，” 第二个客人说。“听起来不错，” 第三个客人说。每个人看着第四个客人。 “我要一个 cilantro soufflé，” 他小声地说。 (译注：蛋奶酥上面洒香菜跟酱料）</p>
<p>瞬息之间，女服务生就转身踩着高跟鞋走回柜台去了。 “三个特餐，” 她大声对厨师说，“还有一个香菜蛋奶酥。”</p>
<p>图 3.6 展示了如何实现这个压缩列表演算法。函数 <tt class="docutils literal"><span class="pre">compress</span></tt> 接受一个由原子组成的列表，然后返回一个压缩的列表：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">compress</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">((</span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>当相同的元素连续出现好几次，这个连续出现的序列 (sequence)被一个列表取代，列表指明出现的次数及出现的元素。</p>
<p>主要的工作是由递归函数 <tt class="docutils literal"><span class="pre">compr</span></tt> 所完成。这个函数接受三个参数： <tt class="docutils literal"><span class="pre">elt</span></tt> ， 上一个我们看过的元素； <tt class="docutils literal"><span class="pre">n</span></tt> ，连续出现的次数；以及 <tt class="docutils literal"><span class="pre">lst</span></tt> ，我们还没检视过的部分列表。如果没有东西需要检视了，我们调用 <tt class="docutils literal"><span class="pre">n-elts</span></tt> 来取得 <tt class="docutils literal"><span class="pre">n</span> <span class="pre">elts</span></tt> 的表示法。如果 <tt class="docutils literal"><span class="pre">lst</span></tt> 的第一个元素还是 <tt class="docutils literal"><span class="pre">elt</span></tt> ，我们增加出现的次数 <tt class="docutils literal"><span class="pre">n</span></tt> 并继续下去。否则我们得到，到目前为止的一个压缩的列表，然后 <tt class="docutils literal"><span class="pre">cons</span></tt> 这个列表在 <tt class="docutils literal"><span class="pre">compr</span></tt> 处理完剩下的列表所返回的东西之上。</p>
<p>要复原一个压缩的列表，我们调用 <tt class="docutils literal"><span class="pre">uncompress</span></tt> (图 3.7)</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">uncompress</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">3</span> <span class="mi">1</span><span class="p">)</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">uncompress</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">elt</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">))</span>
            <span class="p">(</span><span class="nb">rest</span> <span class="p">(</span><span class="nv">uncompress</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">consp</span> <span class="nb">elt</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nv">list-of</span> <span class="nb">elt</span><span class="p">)</span>
                    <span class="nb">rest</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">cons</span> <span class="nb">elt</span> <span class="nb">rest</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">list-of</span> <span class="p">(</span><span class="nv">n</span> <span class="nb">elt</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">n</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="nb">elt</span> <span class="p">(</span><span class="nv">list-of</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="nb">elt</span><span class="p">))))</span>
</pre></div>
</td></tr></table></div>
<p>图 3.7 游程编码 (Run-length encoding)：解压缩</p>
<p>这个函数递归地遍历这个压缩列表，逐字复制原子并调用 <tt class="docutils literal"><span class="pre">list-of</span></tt> ，展开成列表。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">list-of</span> <span class="mi">3</span> <span class="ss">&#39;ho</span><span class="p">)</span>
<span class="p">(</span><span class="nv">HO</span> <span class="nv">HO</span> <span class="nv">HO</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>我们其实不需要自己写 <tt class="docutils literal"><span class="pre">list-of</span></tt> 。内置的 <tt class="docutils literal"><span class="pre">make-list</span></tt> 可以办到一样的事情 –– 但它使用了我们还没介绍到的关键字参数 (keyword argument)。</p>
<p>图 3.6 跟 3.7 这种写法不是一个有经验的Lisp 程序员用的写法。它的效率很差，它没有尽可能的压缩，而且它只对由原子组成的列表有效。在几个章节内，我们会学到解决这些问题的技巧。</p>
<div class="highlight-cl"><pre>载入程序

在这节的程序是我们第一个实质的程序。
当我们想要写超过数行的函数时，
通常我们会把程序写在一个文件，
然后使用 load 让 Lisp 读取函数的定义。
如果我们把图 3.6 跟 3.7 的程序，
存在一个档案叫做，"compress.lisp" 然后输入

(load "compress.lisp")

到顶层，或多或少的，
我们会像在直接输入顶层一样得到同样的效果。

注意：在某些实现中，Lisp 文件的扩展名会是“.lsp”而不是“.lisp”。</pre>
</div>
</div>
<div class="section" id="access">
<h2>3.6 存取 (Access)<a class="headerlink" href="#access" title="永久链接至标题">¶</a></h2>
<p>Common Lisp 有额外的存取函数，它们是用 <tt class="docutils literal"><span class="pre">car</span></tt> 跟 <tt class="docutils literal"><span class="pre">cdr</span></tt> 所定义的。要找到列表特定位置的元素，我们可以调用 <tt class="docutils literal"><span class="pre">nth</span></tt> ，</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">nth</span> <span class="mi">0</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="nv">A</span>
</pre></div>
</td></tr></table></div>
<p>而要找到第 <tt class="docutils literal"><span class="pre">n</span></tt> 个 <tt class="docutils literal"><span class="pre">cdr</span></tt> ，我们调用 <tt class="docutils literal"><span class="pre">nthcdr</span></tt> ：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">nthcdr</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p><tt class="docutils literal"><span class="pre">nth</span></tt> 与 <tt class="docutils literal"><span class="pre">nthcdr</span></tt> 都是零索引的 (zero-indexed); 即元素从 <tt class="docutils literal"><span class="pre">0</span></tt> 开始编号，而不是从 <tt class="docutils literal"><span class="pre">1</span></tt> 开始。在 Common Lisp 里，无论何时你使用一个数字来参照一个数据结构中的元素时，都是从 <tt class="docutils literal"><span class="pre">0</span></tt> 开始编号的。</p>
<p>两个函数几乎做一样的事; <tt class="docutils literal"><span class="pre">nth</span></tt> 等同于取 <tt class="docutils literal"><span class="pre">nthcdr</span></tt> 的 <tt class="docutils literal"><span class="pre">car</span></tt> 。没有检查错误的情况下， <tt class="docutils literal"><span class="pre">nthcdr</span></tt> 可以这么定义：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-nthcdr</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">n</span><span class="p">)</span>
      <span class="nv">lst</span>
      <span class="p">(</span><span class="nv">our-nthcdr</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))))</span>
</pre></div>
</td></tr></table></div>
<p>函数 <tt class="docutils literal"><span class="pre">zerop</span></tt> 仅在参数为零时，才返回真。</p>
<p>函数 <tt class="docutils literal"><span class="pre">last</span></tt> 返回列表的最后一个 <em>Cons</em> 对象：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">last</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>这跟取得最后一个元素不一样。要取得列表的最后一个元素，你要取得 <tt class="docutils literal"><span class="pre">last</span></tt> 的 <tt class="docutils literal"><span class="pre">car</span></tt> 。</p>
<p>Common Lisp 定义了函数 <tt class="docutils literal"><span class="pre">first</span></tt> 直到 <tt class="docutils literal"><span class="pre">tenth</span></tt> 可以取得列表对应的元素。这些函数不是 <em>零索引的</em> (zero-indexed)：</p>
<p><tt class="docutils literal"><span class="pre">(second</span> <span class="pre">x)</span></tt> 等同于 <tt class="docutils literal"><span class="pre">(nth</span> <span class="pre">1</span> <span class="pre">x)</span></tt> 。</p>
<p>此外， Common Lisp 定义了像是 <tt class="docutils literal"><span class="pre">caddr</span></tt> 这样的函数，它是 <tt class="docutils literal"><span class="pre">cdr</span></tt> 的 <tt class="docutils literal"><span class="pre">cdr</span></tt> 的 <tt class="docutils literal"><span class="pre">car</span></tt> 的缩写 ( <tt class="docutils literal"><span class="pre">car</span></tt> of <tt class="docutils literal"><span class="pre">cdr</span></tt> of <tt class="docutils literal"><span class="pre">cdr</span></tt> )。所有这样形式的函数 <tt class="docutils literal"><span class="pre">cxr</span></tt> ，其中 x 是一个字串，最多四个 <tt class="docutils literal"><span class="pre">a</span></tt> 或 <tt class="docutils literal"><span class="pre">d</span></tt> ，在 Common Lisp 里都被定义好了。使用 <tt class="docutils literal"><span class="pre">cadr</span></tt> 可能会有异常 (exception)产生，在所有人都可能会读的代码里使用这样的函数，可能不是个好主意。</p>
</div>
<div class="section" id="mapping-functions">
<h2>3.7 映射函数 (Mapping Functions)<a class="headerlink" href="#mapping-functions" title="永久链接至标题">¶</a></h2>
<p>Common Lisp 提供了数个函数来对一个列表的元素做函数调用。最常使用的是 <tt class="docutils literal"><span class="pre">mapcar</span></tt> ，接受一个函数以及一个或多个列表，并返回把函数应用至每个列表的元素的结果，直到有的列表没有元素为止：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">10</span><span class="p">))</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span><span class="p">)</span>

<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">list</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">((</span><span class="nv">A</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>相关的 <tt class="docutils literal"><span class="pre">maplist</span></tt> 接受同样的参数，将列表的渐进的下一个 <tt class="docutils literal"><span class="pre">cdr</span></tt> 传入函数。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">maplist</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
           <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">((</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>其它的映成函数，包括 <tt class="docutils literal"><span class="pre">mapc</span></tt> 我们在 89 页讨论（译注：5.4 节最后），以及 <tt class="docutils literal"><span class="pre">mapcan</span></tt> 在 202 页（译注：12.4 节最后）讨论。</p>
</div>
<div class="section" id="trees">
<h2>3.8 树 (Trees)<a class="headerlink" href="#trees" title="永久链接至标题">¶</a></h2>
<p><em>Cons</em> 对象可以想成是二叉树， <tt class="docutils literal"><span class="pre">car</span></tt> 代表右子树，而 <tt class="docutils literal"><span class="pre">cdr</span></tt> 代表左子树。举例来说，列表</p>
<p><tt class="docutils literal"><span class="pre">(a</span> <span class="pre">(b</span> <span class="pre">c)</span> <span class="pre">d)</span></tt> 也是一棵由图 3.8 所代表的树。 （如果你逆时针旋转 45 度，你会发现跟图 3.3 一模一样）</p>
<div class="figure">
<img alt="../_images/Figure-3.8.png" src="../_images/Figure-3.8.png" />
</div>
<p>图 3.8 二叉树 (Binary Tree)</p>
<p>Common Lisp 有几个内置的操作树的函数。举例来说， <tt class="docutils literal"><span class="pre">copy-tree</span></tt> 接受一个树，并返回一份副本。它可以这么定义：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-copy-tree</span> <span class="p">(</span><span class="nv">tr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">tr</span><span class="p">)</span>
       <span class="nv">tr</span>
       <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">our-copy-tree</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tr</span><span class="p">))</span>
             <span class="p">(</span><span class="nv">our-copy-tree</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tr</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>把这跟 36 页的 <tt class="docutils literal"><span class="pre">copy-list</span></tt> 比较一下； <tt class="docutils literal"><span class="pre">copy-tree</span></tt> 复制每一个 <em>Cons</em> 对象的 <tt class="docutils literal"><span class="pre">car</span></tt> 与 <tt class="docutils literal"><span class="pre">cdr</span></tt> ，而 <tt class="docutils literal"><span class="pre">copy-list</span></tt> 仅复制 <tt class="docutils literal"><span class="pre">cdr</span></tt> 。</p>
<p>没有内部节点的二叉树没有太大的用处。 Common Lisp 包含了操作树的函数，不只是因为我们需要树这个结构，而是因为我们需要一种方法，来操作列表及所有内部的列表。举例来说，假设我们有一个这样的列表：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">integerp</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>而我们想要把各处的 <tt class="docutils literal"><span class="pre">x</span></tt> 都换成 <tt class="docutils literal"><span class="pre">y</span></tt> 。调用 <tt class="docutils literal"><span class="pre">substitute</span></tt> 是不行的，它只能替换序列 (sequence)中的元素：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">substitute</span> <span class="ss">&#39;y</span> <span class="ss">&#39;x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">integerp</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))))</span>
<span class="p">(</span><span class="nv">AND</span> <span class="p">(</span><span class="nv">INTEGERP</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nv">ZEROP</span> <span class="p">(</span><span class="nv">MOD</span> <span class="nv">X</span> <span class="mi">2</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>这个调用是无效的，因为列表有三个元素，没有一个元素是 <tt class="docutils literal"><span class="pre">x</span></tt> 。我们在这所需要的是 <tt class="docutils literal"><span class="pre">subst</span></tt> ，它替换树之中的元素。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">subst</span> <span class="ss">&#39;y</span> <span class="ss">&#39;x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">integerp</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))))</span>
<span class="p">(</span><span class="nv">AND</span> <span class="p">(</span><span class="nv">INTEGERP</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">(</span><span class="nv">ZEROP</span> <span class="p">(</span><span class="nv">MOD</span> <span class="nv">Y</span> <span class="mi">2</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>如果我们定义一个 <tt class="docutils literal"><span class="pre">subst</span></tt> 的版本，它看起来跟 <tt class="docutils literal"><span class="pre">copy-tree</span></tt> 很相似：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">our-subst</span> <span class="p">(</span><span class="nv">new</span> <span class="nv">old</span> <span class="nv">tree</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">tree</span> <span class="nv">old</span><span class="p">)</span>
        <span class="nv">new</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">tree</span><span class="p">)</span>
            <span class="nv">tree</span>
            <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">our-subst</span> <span class="nv">new</span> <span class="nv">old</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tree</span><span class="p">))</span>
                  <span class="p">(</span><span class="nv">our-subst</span> <span class="nv">new</span> <span class="nv">old</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tree</span><span class="p">))))))</span>
</pre></div>
</td></tr></table></div>
<p>操作树的函数通常有这种形式， <tt class="docutils literal"><span class="pre">car</span></tt> 与 <tt class="docutils literal"><span class="pre">cdr</span></tt> 同时做递归。这种函数被称之为是 <em>双重递归</em> (doubly recursive)。</p>
</div>
<div class="section" id="understanding-recursion">
<h2>3.9 理解递归 (Understanding Recursion)<a class="headerlink" href="#understanding-recursion" title="永久链接至标题">¶</a></h2>
<p>学生在学习递归时，有时候是被鼓励在纸上追踪 (trace)递归程序调用 (invocation)的过程。 (288页「译注：Appendix A Trace and Backtraces」可以看到一个递归函数的追踪过程。)但这种练习可能会误导你：一个程序员在定义一个递归函数时，通常不会特别地去想函数的调用顺序所导致的结果。</p>
<p>如果一个人总是需要这样子思考程序，递归会是艰难的、没有帮助的。递归的优点是它精确地让我们更抽象地来检视算法。你不需要考虑真正函数时所有的调用过程，就可以判断一个递归函数是否​​是正确的。</p>
<p>要知道一个递归函数是否​​做它该做的事，你只需要问，它包含了所有的情况吗？举例来说，下面是一个寻找列表长度的递归函数：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">len</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
        <span class="mi">0</span>
        <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">len</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))</span> <span class="mi">1</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>我们可以藉由检查两件事情，来确信这个函数是正确的：</p>
<ol class="arabic simple">
<li>对长度为 <tt class="docutils literal"><span class="pre">0</span></tt> 的列表是有效的。</li>
<li>给定它对于长度为 <tt class="docutils literal"><span class="pre">n</span></tt> 的列表是有效的，它对长度是 <tt class="docutils literal"><span class="pre">n+1</span></tt> 的列表也是有效的。</li>
</ol>
<p>如果这两点是成立的，我们知道这个函数对于所有可能的列表都是正确的。</p>
<p>我们的定义显然地满足第一点：如果列表( <tt class="docutils literal"><span class="pre">lst</span></tt> ) 是空的( <tt class="docutils literal"><span class="pre">nil</span></tt> )，函数直接返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。现在假定我们的函数对长度为 <tt class="docutils literal"><span class="pre">n</span></tt> 的列表是有效的。我们给它一个 <tt class="docutils literal"><span class="pre">n+1</span></tt> 长度的列表。这个定义说明了，函数会返回列表的 <tt class="docutils literal"><span class="pre">cdr</span></tt> 的长度再加上 <tt class="docutils literal"><span class="pre">1</span></tt> 。 <tt class="docutils literal"><span class="pre">cdr</span></tt> 是一个长度为 <tt class="docutils literal"><span class="pre">n</span></tt> 的列表。我们经由假定可知它的长度是 <tt class="docutils literal"><span class="pre">n</span></tt> 。所以整个列表的长度是 <tt class="docutils literal"><span class="pre">n+1</span></tt> 。</p>
<p>我们需要知道的就是这些。理解递归的秘密就像是处理括号一样。你怎么知道哪个括号对上哪个？你不需要这么做。你怎么想像那些调用过程？你不需要这么做。</p>
<p>更复杂的递归函数，可能会有更多的情况需要讨论，但是流程是一样的。举例来说， 41 页的 <tt class="docutils literal"><span class="pre">our-copy-tree</span></tt> ，我们需要讨论三个情况： 原子，单一的 <em>Cons</em> 对象， <tt class="docutils literal"><span class="pre">n+1</span></tt> 的 <em>Cons</em> 树。</p>
<p>第一个情况（长度零的列表）称之为<em>基本用例</em>( <em>base case</em> )。当一个递归函数不像你想的那样工作时，通常是因为基本用例是错的。下面这个不正确的 <tt class="docutils literal"><span class="pre">member</span></tt> 定义，是一个常见的​​错误，整个忽略了基本用例：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-member</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="nv">obj</span><span class="p">)</span>
      <span class="nv">lst</span>
      <span class="p">(</span><span class="nv">our-member</span> <span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))))</span>
</pre></div>
</td></tr></table></div>
<p>我们需要初始一个 <tt class="docutils literal"><span class="pre">null</span></tt> 测试，确保在到达列表底部时，没有找到目标时要停止递归。如果我们要找的对象没有在列表里，这个版本的 <tt class="docutils literal"><span class="pre">member</span></tt> 会陷入无穷回圈。附录 A 更详细地检视了这种问题。</p>
<p>能够判断一个递归函数是否​​正确只不过是理解递归的上半场，下半场是能够写出一个做你想做的事情的递归函数。 6.9 节讨论了这个问题。</p>
</div>
<div class="section" id="sets">
<h2>3.10 集合 (Sets)<a class="headerlink" href="#sets" title="永久链接至标题">¶</a></h2>
<p>列表是表示小集合的好方法。列表中的每个元素都代表了一个集合的成员：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">member</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>当 <tt class="docutils literal"><span class="pre">member</span></tt> 要返回“真”时，与其仅仅返回 <tt class="docutils literal"><span class="pre">t</span></tt> ，它返回由寻找对象所开始的那部分。逻辑上来说，一个 <em>Cons</em> 扮演的角色和 <tt class="docutils literal"><span class="pre">t</span></tt> 一样，而经由这么做，函数返回了更多资讯。</p>
<p>一般情况下， <tt class="docutils literal"><span class="pre">member</span></tt> 使用 <tt class="docutils literal"><span class="pre">eql</span></tt> 来比较对象。你可以使用一种叫做关键字参数的东西来重写缺省的比较方法。多数的 Common Lisp 函数接受一个或多个关键字参数。这些关键字参数不同的地方是，他们不是把对应的参数放在特定的位置作匹配，而是在函数调用中用特殊标签，称为关键字，来作匹配。一个关键字是一个前面有冒号的符号。</p>
<p>一个 <tt class="docutils literal"><span class="pre">member</span></tt> 函数所接受的关键字参数是 <tt class="docutils literal"><span class="pre">:test</span></tt> 参数。</p>
<p>如果你在调用 <tt class="docutils literal"><span class="pre">member</span></tt> 时，传入某个函数作为 <tt class="docutils literal"><span class="pre">:test</span></tt> 参数，那么那个函数就会被用来比较是否相等，而不是用 <tt class="docutils literal"><span class="pre">eql</span></tt> 。所以如果我们想找到一个给定的对象与列表中的成员是否相等( <tt class="docutils literal"><span class="pre">equal</span></tt> )，我们可以：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">member</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span><span class="p">))</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equal</span><span class="p">)</span>
<span class="p">((</span><span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">Z</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>关键字参数总是选​​择性添加的。如果你在一个调用中包含了任何的关键字参数，他们要摆在最后; 如果使用了超过一个的关键字参数，摆放的顺序无关紧要。</p>
<p>另一个 <tt class="docutils literal"><span class="pre">member</span></tt> 接受的关键字参数是 <tt class="docutils literal"><span class="pre">:key</span></tt> 参数。藉由提供这个参数，你可以在作比较之前，指定一个函数运用在每一个元素：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">member</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">car</span><span class="p">)</span>
<span class="p">((</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="nv">D</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>在这个例子里，我们询问是否有一个元素的 <tt class="docutils literal"><span class="pre">car</span></tt> 是 <tt class="docutils literal"><span class="pre">a</span></tt> ​​。</p>
<p>如果我们想要使用两个关键字参数，我们可以使用其中一个顺序。下面这两个调用是等价的：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">member</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">car</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equal</span><span class="p">)</span>
<span class="p">((</span><span class="mi">2</span><span class="p">))</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">member</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="ss">:test</span> <span class="nf">#&#39;</span><span class="nb">equal</span> <span class="ss">:key</span> <span class="nf">#&#39;</span><span class="nb">car</span><span class="p">)</span>
<span class="p">((</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>两者都询问是否有一个元素的 <tt class="docutils literal"><span class="pre">car</span></tt> 等于( <tt class="docutils literal"><span class="pre">equal</span></tt> ) 2。</p>
<p>如果我们想要找到一个元素满足任意的判断式像是── <tt class="docutils literal"><span class="pre">oddp</span></tt> ，奇数返回真──我们可以使用相关的 <tt class="docutils literal"><span class="pre">member-if</span></tt> ：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">member-if</span> <span class="nf">#&#39;</span><span class="nb">oddp</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>我们可以想像一个限制性的版本 <tt class="docutils literal"><span class="pre">member-if</span></tt> 是这样写成的：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">defun</span> <span class="nv">our-member-if</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">lst</span><span class="p">)</span>
       <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">))</span>
           <span class="nv">lst</span>
           <span class="p">(</span><span class="nv">our-member-if</span> <span class="nv">fn</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>函数 <tt class="docutils literal"><span class="pre">adjoin</span></tt> 像是条件式的 <tt class="docutils literal"><span class="pre">cons</span></tt> 。它接受一个对象及一个列表，如果对象还不是列表的成员，才构建对象至列表上。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">adjoin</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">adjoin</span> <span class="ss">&#39;z</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">Z</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>通常的情况下它接受与 <tt class="docutils literal"><span class="pre">member</span></tt> 函数同样的关键字参数。</p>
<p>集合论中的并集 (union)、交集 (intersection)以及补集 (complement)的实现，是由函数 <tt class="docutils literal"><span class="pre">union</span></tt> 、 <tt class="docutils literal"><span class="pre">intersection</span></tt> 以及 <tt class="docutils literal"><span class="pre">set-difference</span></tt> 。</p>
<p>这些函数期望两个（正好 2 个）列表（一样接受与 <tt class="docutils literal"><span class="pre">member</span></tt> 函数同样的关键字参数）。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">union</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">b</span> <span class="nv">s</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">C</span> <span class="nv">B</span> <span class="nv">S</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">intersection</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">set-difference</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">e</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>因为集合中没有顺序的概念，这些函数不需要保留原本元素在列表被找到的顺序。举例来说，调用 <tt class="docutils literal"><span class="pre">set-difference</span></tt> 也有可能返回 <tt class="docutils literal"><span class="pre">(d</span> <span class="pre">c</span> <span class="pre">a)</span></tt> 。</p>
</div>
<div class="section" id="sequences">
<h2>3.11 序列 (Sequences)<a class="headerlink" href="#sequences" title="永久链接至标题">¶</a></h2>
<p>另一种考虑一个列表的方式是想成一系列有特定顺序的对象。在 Common Lisp 里，<em>序列</em>( <em>sequences</em> )包括了列表与向量 (vectors)。本节介绍了一些可以运用在列表上的序列函数。更深入的序列操作在 4.4 节讨论。</p>
<p>函数 <tt class="docutils literal"><span class="pre">length</span></tt> 返回序列中元素的数目。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">length</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="mi">3</span>
</pre></div>
</td></tr></table></div>
<p>我们在 24 页 (译注：2.13节 <tt class="docutils literal"><span class="pre">our-length</span></tt> )写过这种函数的一个版本（仅可用于列表）。</p>
<p>要复制序列的一部分，我们使用 <tt class="docutils literal"><span class="pre">subseq</span></tt> 。第二个（需要的）参数是第一个开始引用进来的元素位置，第三个（选择性）参数是第一个不引用进来的元素位置。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">subseq</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">(</span><span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span><span class="p">(</span><span class="nb">subseq</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>如果省略了第三个参数，子序列会从第二个参数给定的位置引用到序列尾端。</p>
<p>函数 <tt class="docutils literal"><span class="pre">reverse</span></tt> 返回与其参数相同元素的一个序列，但顺序颠倒。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">reverse</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>一个回文 (palindrome) 是一个正读反读都一样的序列 —— 举例来说， <tt class="docutils literal"><span class="pre">(abba)</span></tt> 。如果一个回文有偶数个元素，那么后半段会是前半段的镜射 (mirror)。使用 <tt class="docutils literal"><span class="pre">length</span></tt> 、 <tt class="docutils literal"><span class="pre">subseq</span></tt> 以及 <tt class="docutils literal"><span class="pre">reverse</span></tt> ，我们可以定义一个函数</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">mirror?</span> <span class="p">(</span><span class="nv">s</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">len</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">s</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">evenp</span> <span class="nv">len</span><span class="p">)</span>
         <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">mid</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">len</span> <span class="mi">2</span><span class="p">)))</span>
           <span class="p">(</span><span class="nb">equal</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">s</span> <span class="mi">0</span> <span class="nv">mid</span><span class="p">)</span>
                  <span class="p">(</span><span class="nb">reverse</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">s</span> <span class="nv">mid</span><span class="p">)))))))</span>
</pre></div>
</td></tr></table></div>
<p>来检测是否是回文：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">mirror?</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">b</span> <span class="nv">a</span><span class="p">))</span>
<span class="no">T</span>
</pre></div>
</td></tr></table></div>
<p>Common Lisp 有一个内置的排序函数叫做 <tt class="docutils literal"><span class="pre">sort</span></tt> 。它接受一个序列及一个比较两个参数的函数，返回一个有同样元素的序列，根据比较函数来排序：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">sort</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">8</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="nb">&gt;</span><span class="p">)</span>
<span class="p">(</span><span class="mi">8</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>你要小心使用 <tt class="docutils literal"><span class="pre">sort</span></tt> ，因为它是<em>破坏性的</em>(<em>destructive</em>)。考虑到效率的因素， <tt class="docutils literal"><span class="pre">sort</span></tt> 被允许修改传入的序列。所以如果你不想你本来的序列被改动，传入一个副本。</p>
<p>使用 <tt class="docutils literal"><span class="pre">sort</span></tt> 及 <tt class="docutils literal"><span class="pre">nth</span></tt> ，我们可以写一个函数，接受一个整数 <tt class="docutils literal"><span class="pre">n</span></tt> ，返回列表中第 <tt class="docutils literal"><span class="pre">n</span></tt> 大的元素：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">nthmost</span> <span class="p">(</span><span class="nv">n</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">nth</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span>
       <span class="p">(</span><span class="nb">sort</span> <span class="p">(</span><span class="nb">copy-list</span> <span class="nv">lst</span><span class="p">)</span> <span class="nf">#&#39;</span><span class="nb">&gt;</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>我们把整数减一因为 <tt class="docutils literal"><span class="pre">nth</span></tt> 是零索引的，但如果 <tt class="docutils literal"><span class="pre">nthmost</span></tt> 是这样的话，会变得很不直观。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nv">nthmost</span> <span class="mi">2</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">1</span> <span class="mi">3</span> <span class="mi">8</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>多努力一点，我们可以写出这个函数的一个更有效率的版本。</p>
<p>函数 <tt class="docutils literal"><span class="pre">every</span></tt> 和 <tt class="docutils literal"><span class="pre">some</span></tt> 接受一个判断式及一个或多个序列。当我们仅输入一个序列时，它们测试序列元素是否满足判断式：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">every</span> <span class="nf">#&#39;</span><span class="nb">oddp</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">))</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">some</span> <span class="nf">#&#39;</span><span class="nb">evenp</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="no">T</span>
</pre></div>
</td></tr></table></div>
<p>如果它们输入多于一个序列时，判断式必须接受与序列一样多的元素作为参数，而参数从所有序列中一次提取一个：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">every</span> <span class="nf">#&#39;</span><span class="nb">&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">4</span><span class="p">))</span>
<span class="no">T</span>
</pre></div>
</td></tr></table></div>
<p>如果序列有不同的长度，最短的那个序列，决定需要测试的次数。</p>
</div>
<div class="section" id="stacks">
<h2>3.12 栈 (Stacks)<a class="headerlink" href="#stacks" title="永久链接至标题">¶</a></h2>
<p>用 <em>Cons</em> 对象来表示的列表，很自然地我们可以拿来实现下推栈 (pushdown stack)。这太常见了，以致于 Common Lisp 提供了两个宏给堆叠使用： <tt class="docutils literal"><span class="pre">(push</span> <span class="pre">xy)</span></tt> 把 <tt class="docutils literal"><span class="pre">x</span></tt> 放入列表 <tt class="docutils literal"><span class="pre">y</span></tt> 的前端。而 <tt class="docutils literal"><span class="pre">(pop</span> <span class="pre">x)</span></tt> 则是将列表 x 的第一个元素移除，并返回这个元素。</p>
<p>两个函数都是由 <tt class="docutils literal"><span class="pre">setf</span></tt> 定义的。如果参数是常数或变量，很简单就可以翻译出对应的函数调用。</p>
<p>表达式</p>
<p><tt class="docutils literal"><span class="pre">(push</span> <span class="pre">obj</span> <span class="pre">lst)</span></tt></p>
<p>等同于</p>
<p><tt class="docutils literal"><span class="pre">(setf</span> <span class="pre">lst</span> <span class="pre">(cons</span> <span class="pre">obj</span> <span class="pre">lst))</span></tt></p>
<p>而表达式</p>
<p><tt class="docutils literal"><span class="pre">(pop</span> <span class="pre">lst)</span></tt></p>
<p>等同于</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)))</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="nv">lst</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))</span>
  <span class="nv">x</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>所以，举例来说：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">push</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="nv">x</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">pop</span> <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="nv">x</span>
<span class="p">(</span><span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="nv">y</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>以上，全都遵循上述由 <tt class="docutils literal"><span class="pre">setf</span></tt> 所给出的相等式。图 3.9 展示了这些表达式被求值后的结构。</p>
<div class="figure">
<img alt="../_images/Figure-3.9.png" src="../_images/Figure-3.9.png" />
</div>
<p>图 3.9 push 及 pop 的效果</p>
<p>你可以使用 <tt class="docutils literal"><span class="pre">push</span></tt> 来定义一个给列表使用的互动版 <tt class="docutils literal"><span class="pre">reverse</span></tt> 。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-reverse</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">acc</span> <span class="no">nil</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nb">elt</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">push</span> <span class="nb">elt</span> <span class="nv">acc</span><span class="p">))</span>
    <span class="nv">acc</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>在这个版本，我们从一个空列表开始，然后把 <tt class="docutils literal"><span class="pre">lst</span></tt> 的每一个元素放入空表里。等我们完成时，``lst`` 最后一个元素会在最前端。</p>
<p><tt class="docutils literal"><span class="pre">pushnew</span></tt> 宏是 <tt class="docutils literal"><span class="pre">push</span></tt> 的变种，使用了 <tt class="docutils literal"><span class="pre">adjoin</span></tt> 而不是 <tt class="docutils literal"><span class="pre">cons</span></tt> ：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre> <span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)))</span>
     <span class="p">(</span><span class="nb">pushnew</span> <span class="ss">&#39;c</span> <span class="nv">x</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">pushnew</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)</span>
     <span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nv">C</span> <span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>在这里， <tt class="docutils literal"><span class="pre">c</span></tt> 被放入列表，但是 <tt class="docutils literal"><span class="pre">a</span></tt> 没有，因为它已经是列表的一个成员了。</p>
</div>
<div class="section" id="dotted-lists">
<h2>3.13 点状列表 (Dotted Lists)<a class="headerlink" href="#dotted-lists" title="永久链接至标题">¶</a></h2>
<p>调用 <tt class="docutils literal"><span class="pre">list</span></tt> 所构建的列表，这种列表精确地说称之为正规列表(<em>proper</em>list )。一个正规列表可以是 <tt class="docutils literal"><span class="pre">NIL</span></tt> 或是 <tt class="docutils literal"><span class="pre">cdr</span></tt> 是正规列表的 <em>Cons</em> 对象。也就是说，我们可以定义一个只对正规列表返回真的判断式： <a class="footnote-reference" href="#id5" id="id2">[3]</a></p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">proper-list?</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">x</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)</span>
           <span class="p">(</span><span class="nv">proper-list?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>至目前为止，我们构建的列表都是正规列表。</p>
<p>然而， <tt class="docutils literal"><span class="pre">cons</span></tt> 不仅是构建列表。无论何时你需要一个具有两个字段 (field)的列表，你可以使用一个 <em>Cons</em> 对象。你能够使用 <tt class="docutils literal"><span class="pre">car</span></tt> 来参照第一个字段，用 <tt class="docutils literal"><span class="pre">cdr</span></tt> 来参照第二个字段。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">pair</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="o">.</span> <span class="nv">B</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>因为这个 <em>Cons</em> 对象不是一个正规列表，它用点状表示法来显示。在点状表示法，每个 <em>Cons</em> 对象的 <tt class="docutils literal"><span class="pre">car</span></tt> 与 <tt class="docutils literal"><span class="pre">cdr</span></tt> 由一个句点隔开来表示。这个 <em>Cons</em> 对象的结构展示在图 3.10 。</p>
<div class="figure">
<img alt="../_images/Figure-3.10.png" src="../_images/Figure-3.10.png" />
</div>
<p>图3.10 一个成对的 <em>Cons</em> 对象 (A cons used as a pair)</p>
<p>一个非正规列表的 <em>Cons</em> 对象称之为点状列表 (dotted list)。这不是个好名字，因为非正规列表的 Cons 对象通常不是用来表示列表： <tt class="docutils literal"><span class="pre">(a</span> <span class="pre">.</span> <span class="pre">b)</span></tt> 只是一个有两部分的数据结构。</p>
<p>你也可以用点状表示法表示正规列表，但当 Lisp 显示一个正规列表时，它会使用普通的列表表示法：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="p">(</span><span class="nv">b</span> <span class="o">.</span> <span class="p">(</span><span class="nv">c</span> <span class="o">.</span> <span class="no">nil</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>顺道一提，注意列表由点状表示法与图 3.2 箱子表示法的关联性。</p>
<p>还有一个过渡形式 (intermediate form)的表示法，介于列表表示法及纯点状表示法之间，对于 <tt class="docutils literal"><span class="pre">cdr</span></tt> 是点状列表的 <em>Cons</em> 对象：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;b</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;c</span> <span class="ss">&#39;d</span><span class="p">)))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="o">.</span> <span class="nv">D</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="figure">
<img alt="../_images/Figure-3.11.png" src="../_images/Figure-3.11.png" />
</div>
<p>图 3.11 一个点状列表 (A dotted list)</p>
<p>这样的 <em>Cons</em> 对象看起来像正规列表，除了最后一个 cdr 前面有一个句点。这个列表的结构展示在图 3.11 ; 注意它跟图3.2 是多么的相似。</p>
<p>所以实际上你可以这么表示列表 <tt class="docutils literal"><span class="pre">(a</span> <span class="pre">b)</span></tt> ，</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="p">(</span><span class="nv">b</span> <span class="o">.</span> <span class="no">nil</span><span class="p">))</span>
<span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="p">(</span><span class="nv">b</span><span class="p">))</span>
<span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="o">.</span> <span class="no">nil</span><span class="p">)</span>
<span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>虽然 Lisp 总是使用后面的形式，来显示这个列表。</p>
</div>
<div class="section" id="assoc-lists">
<h2>3.14 关联列表 (Assoc-lists)<a class="headerlink" href="#assoc-lists" title="永久链接至标题">¶</a></h2>
<p>用 <em>Cons</em> 对象来表示映射 (mapping)也是很自然的。一个由 <em>Cons</em> 对象组成的列表称之为<em>关联列表</em>(<em>assoc-list</em>or <em>alist</em>)。这样的列表可以表示一个翻译的集合，举例来说：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">trans</span> <span class="o">&#39;</span><span class="p">((</span><span class="nb">+</span> <span class="o">.</span> <span class="s">&quot;add&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="o">.</span> <span class="s">&quot;subtract&quot;</span><span class="p">)))</span>
<span class="p">((</span><span class="nb">+</span> <span class="o">.</span> <span class="s">&quot;add&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="o">.</span> <span class="s">&quot;subtract&quot;</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>关联列表很慢，但是在初期的程序中很方便。 Common Lisp 有一个内置的函数 <tt class="docutils literal"><span class="pre">assoc</span></tt> ，用来取出在关联列表中，与给定的键值有关联的 <em>Cons</em> 对：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">assoc</span> <span class="ss">&#39;+</span> <span class="nv">trans</span><span class="p">)</span>
<span class="p">(</span><span class="nb">+</span> <span class="o">.</span> <span class="s">&quot;add&quot;</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">assoc</span> <span class="ss">&#39;*</span> <span class="nv">trans</span><span class="p">)</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>如果 <tt class="docutils literal"><span class="pre">assoc</span></tt> 没有找到要找的东西时，返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。</p>
<p>我们可以定义一个受限版本的 <tt class="docutils literal"><span class="pre">assoc</span></tt> ：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-assoc</span> <span class="p">(</span><span class="nv">key</span> <span class="nv">alist</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">alist</span><span class="p">)</span>
       <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">pair</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">alist</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">pair</span><span class="p">))</span>
            <span class="nv">pair</span>
            <span class="p">(</span><span class="nv">our-assoc</span> <span class="nv">key</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">alist</span><span class="p">))))))</span>
</pre></div>
</td></tr></table></div>
<p>和 <tt class="docutils literal"><span class="pre">member</span></tt> 一样，实际上的 <tt class="docutils literal"><span class="pre">assoc</span></tt> 接受关键字参数，包括 <tt class="docutils literal"><span class="pre">:test</span></tt> 和 <tt class="docutils literal"><span class="pre">:key</span></tt> 。 Common Lisp 也定义了一个 <tt class="docutils literal"><span class="pre">assoc-if</span></tt> 之于 <tt class="docutils literal"><span class="pre">assoc</span></tt> ，如同 <tt class="docutils literal"><span class="pre">member-if</span></tt> 之于 <tt class="docutils literal"><span class="pre">member</span></tt> 一样。</p>
</div>
<div class="section" id="example-shortest-path">
<h2>3.15 示例：最短路径 (Example: Shortest Path)<a class="headerlink" href="#example-shortest-path" title="永久链接至标题">¶</a></h2>
<p>图 3.12 包含一个搜索网络中最短路径的程序。函数 <tt class="docutils literal"><span class="pre">shortest-path</span></tt> 接受一个起始节点，目的节点以及一个网络，并返回最短路径，如果有的话。</p>
<p>在这个范例中，节点用符号表示，而网络用含以下元素形式的关联列表来表示：</p>
<p><em>(node​​ . neighbors)</em></p>
<p>所以由图 3.13 展示的最小网络 (minimal network)可以这样来表示：</p>
<p><tt class="docutils literal"><span class="pre">(setf</span> <span class="pre">min</span> <span class="pre">'((a</span> <span class="pre">b</span> <span class="pre">c)</span> <span class="pre">(b</span> <span class="pre">c)</span> <span class="pre">(c</span> <span class="pre">d)))</span></tt></p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">shortest-path</span> <span class="p">(</span><span class="nv">start</span> <span class="nv">end</span> <span class="nv">net</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">bfs</span> <span class="nv">end</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">start</span><span class="p">))</span> <span class="nv">net</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">bfs</span> <span class="p">(</span><span class="nv">end</span> <span class="nv">queue</span> <span class="nv">net</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">queue</span><span class="p">)</span>
      <span class="no">nil</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">path</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">queue</span><span class="p">)))</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">node</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">path</span><span class="p">)))</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">node</span> <span class="nv">end</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">reverse</span> <span class="nv">path</span><span class="p">)</span>
              <span class="p">(</span><span class="nv">bfs</span> <span class="nv">end</span>
                   <span class="p">(</span><span class="nb">append</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">queue</span><span class="p">)</span>
                           <span class="p">(</span><span class="nv">new-paths</span> <span class="nv">path</span> <span class="nv">node</span> <span class="nv">net</span><span class="p">))</span>
                   <span class="nv">net</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">new-paths</span> <span class="p">(</span><span class="nv">path</span> <span class="nv">node</span> <span class="nv">net</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">cons</span> <span class="nv">n</span> <span class="nv">path</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">assoc</span> <span class="nv">node</span> <span class="nv">net</span><span class="p">))))</span>
</pre></div>
</td></tr></table></div>
<p>图 3.12 广度优先搜索(breadth-first search)</p>
<div class="figure">
<img alt="../_images/Figure-3.13.png" src="../_images/Figure-3.13.png" />
</div>
<p>图 3.13 最小网络</p>
<p>要找到从节点 <tt class="docutils literal"><span class="pre">a</span></tt> 可以到达的节点，我们可以：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">assoc</span> <span class="ss">&#39;a</span> <span class="nb">min</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>图 3.12 程序的工作方式为使用广度优先的方式搜索网络。要使用广度优先搜索，你需要维护一个含有未探索节点的队列。每一次你到达一个节点，检查这个节点是否是你要的。如果不是，你把这个节点的子节点加入队列的尾端，并从队列起始选一个节点，从这继续搜索。藉由总是把较深的节点放在队列尾端，我们确保网络一次被搜索一层。</p>
<p>图 3.12 中的代码较不复杂地表示这个概念。我们不仅想要找到节点，还想保有我们怎么到那的纪录。所以与其维护一个具有节点的队列 (queue)，我们维护一个已知路径的队列，每个已知路径都是一列节点。当我们从队列取出一个元素继续搜索时，它是一个含有队列前端节点的列表，而不只是一个节点而已。</p>
<p>函数 <tt class="docutils literal"><span class="pre">bfs</span></tt> 负责搜索。起初队列只有一个元素，一个表示从起点开始的路径。所以 <tt class="docutils literal"><span class="pre">shortest-path</span></tt> 呼叫 <tt class="docutils literal"><span class="pre">bfs</span></tt> ，并传入 <tt class="docutils literal"><span class="pre">(list</span> <span class="pre">(list</span> <span class="pre">start))</span></tt> 作为初始队列。</p>
<p><tt class="docutils literal"><span class="pre">bfs</span></tt> 函数第一件要考虑的事是，是否还有节点需要探索。如果队列为空， <tt class="docutils literal"><span class="pre">bfs</span></tt> 返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 指出没有找到路径。如果还有节点需要搜索， <tt class="docutils literal"><span class="pre">bfs</span></tt> 检视队列前端的节点。如果节点的 <tt class="docutils literal"><span class="pre">car</span></tt> 部分是我们要找的节点，我们返回这个找到的路径，并且为了可读性的原因我们反转它。如果我们没有找到我们要找的节点，它有可能在现在节点之后，所以我们把它的子节点（或是每一个子路径）加入队列尾端。然后我们递回地呼叫 <tt class="docutils literal"><span class="pre">bfs</span></tt> 来继续搜寻剩下的队列。</p>
<p>因为 <tt class="docutils literal"><span class="pre">bfs</span></tt> 广度优先地搜索，第一个找到的路径会是最短的，或是最短之一：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">shortest-path</span> <span class="ss">&#39;a</span> <span class="ss">&#39;d</span> <span class="nb">min</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>这是队列在我们连续呼叫 <tt class="docutils literal"><span class="pre">bfs</span></tt> 看起来的样子：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">((</span><span class="nv">A</span><span class="p">))</span>
<span class="p">((</span><span class="nv">B</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="nv">A</span><span class="p">))</span>
<span class="p">((</span><span class="nv">C</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">))</span>
<span class="p">((</span><span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">C</span> <span class="nv">A</span><span class="p">))</span>
<span class="p">((</span><span class="nv">D</span> <span class="nv">C</span> <span class="nv">A</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>在队列中的第二个元素变成下一个队列的第一个元素。队列的第一个元素变成下一个队列尾端元素的 <tt class="docutils literal"><span class="pre">cdr</span></tt> 部分。</p>
<p>在图 3.12 的代码不是搜索一个网络最快的方法，但它给出了列表具有多功能的概念。在这个简单的程序中，我们用三种不同的方式使用了列​​表：我们使用一个符号的列表来表示路径，一个路径的列表来表示在广度优先搜索中的队列 <a class="footnote-reference" href="#id6" id="id3">[4]</a> ，以及一个关联列表来表示网络本身。</p>
</div>
<div class="section" id="garbages">
<h2>3.16 垃圾 (Garbages)<a class="headerlink" href="#garbages" title="永久链接至标题">¶</a></h2>
<p>有很多原因可以使列表变慢。列表提供了循序存取而不是随机存取，所以列表取出一个指定的元素比阵列慢，同样的原因，录音带取出某些东西比在光盘上慢。电脑内部里， <em>Cons</em> 对象倾向于用指针表示，所以走访一个列表意味着走访一系列的指针，而不是简单地像阵列一样增加索引值。但这两个所花的代价与配置及回收 <em>Cons</em> 核 (cons cells)比起来小多了。</p>
<p><em>自动内存管理</em>(<em>Automatic memory management</em>)是 Lisp 最有价值的特色之一。 Lisp 系统维护着一段內存称之为堆叠(<em>Heap</em>)。系统持续追踪堆叠当中没有使用的内存，把这些内存发放给新产生的对象。举例来说，函数 <tt class="docutils literal"><span class="pre">cons</span></tt> ，返回一个新配置的 <em>Cons</em> 对象。从堆叠中配置内存有时候通称为 <em>consing</em> 。</p>
<p>如果内存永远没有释放， Lisp 会因为创建新对象把内存用完，而必须要关闭。所以系统必须周期性地通过搜索堆叠 (heap)，寻找不需要再使用的内存。不需要再使用的内存称之为垃圾 (<em>garbage</em>)，而清除垃圾的动作称为垃圾回收 (<em>garbage collection</em>或 GC)。</p>
<p>垃圾是从哪来的？让我们来创造一些垃圾：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">lst</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">lst</span> <span class="no">nil</span><span class="p">)</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>一开始我们呼叫 <tt class="docutils literal"><span class="pre">list</span></tt> ， <tt class="docutils literal"><span class="pre">list</span></tt> 呼叫 <tt class="docutils literal"><span class="pre">cons</span></tt> ，在堆叠上配置了一个新的 <em>Cons</em> 对象。在这个情况我们创出三个 <em>Cons</em> 对象。之后当我们把 <tt class="docutils literal"><span class="pre">lst</span></tt> 设为 <tt class="docutils literal"><span class="pre">nil</span></tt> ，我们没有任何方法可以再存取 <tt class="docutils literal"><span class="pre">lst</span></tt> ，列表 <tt class="docutils literal"><span class="pre">(a</span> <span class="pre">b</span> <span class="pre">c)</span></tt> 。 <a class="footnote-reference" href="#id7" id="id4">[5]</a></p>
<p>因为我们没有任何方法再存取列表，它也有可能是不存在的。我们不再有任何方式可以存取的对象叫做垃圾。系统可以安全地重新使用这三个 <em>Cons</em> 核。</p>
<p>这种管理內存的方法，给程序員带来极大的便利性。你不用显式地配置 (allocate)或释放 (dellocate)內存。这也表示了你不需要处理因为这么做而可能产生的臭虫。內存泄漏 (Memory leaks)以及迷途指针 (dangling pointer)在 Lisp 中根本不可能发生。</p>
<p>但是像任何的科技进步，如果你不小心的话，自动內存管理也有可能对你不利。使用及回收堆叠所带来的代价有时可以看做 <tt class="docutils literal"><span class="pre">cons</span></tt> 的代价。这是有理的，除非一个程序从来不丢弃任何东西，不然所有的 <em>Cons</em> 对象终究要变成垃圾。 Consing 的问题是，配置空间与清除內存，与程序的常规运作比起来花费昂贵。近期的研究提出了大幅改善內存回收的演算法，但是 consing 总是需要代价的，在某些现有的 Lisp 系统中，代价是昂贵的。</p>
<p>除非你很小心，不然很容易写出过度显式创建 cons 对象的程序。举例来说， <tt class="docutils literal"><span class="pre">remove</span></tt> 需要复制所有的 <tt class="docutils literal"><span class="pre">cons</span></tt> 核，直到最后一个元素从列表中移除。你可以藉由使用破坏性的函数避免某些 consing，它试​​着去重用列表的结构作为参数传给它们。破坏性函数会在 12.4 节讨论。</p>
<p>当写出 <tt class="docutils literal"><span class="pre">cons</span></tt> 很多的程序是如此简单时，我们还是可以写出不使用 <tt class="docutils literal"><span class="pre">cons</span></tt> 的程序。典型的方法会是写出一个纯函数风格，使用很多列表的第一版程序。当程序进化时，你可以在代码的关键部份使用破坏性函数以及/或别种资料结构。但这很难给出通用的建议，因为有些 Lisp 实现，內存管理处理得相当好，以致于使用 <tt class="docutils literal"><span class="pre">cons</span></tt> 有时比不使用 <tt class="docutils literal"><span class="pre">cons</span></tt> 还快。这整个议题在 13.4 做更进一步的细部讨论。</p>
<p>无论如何 consing 在原型跟实验时是好的。而且如果你利用了列表给你带来的灵活性，你有较高的可能写出后期可存活下来的程序。</p>
</div>
<div class="section" id="chapter-3-summary">
<h2>Chapter 3 总结 (Summary)<a class="headerlink" href="#chapter-3-summary" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li>一个 <em>Cons</em> 是一个含两部分的数据结构。列表用链结在一起的 <em>Cons</em> 组成。</li>
<li>判断式 <tt class="docutils literal"><span class="pre">equal</span></tt> 比 <tt class="docutils literal"><span class="pre">eql</span></tt> 来得不严谨。基本上，如果传入参数印出来的值一样时，返回真。</li>
<li>所有 Lisp 对象表现得像指针。你永远不需要显式操作指针。</li>
<li>你可以使用 <tt class="docutils literal"><span class="pre">copy-list</span></tt> 复制列表，并使用 <tt class="docutils literal"><span class="pre">append</span></tt> 来连接它们的元素。</li>
<li>游程编码是一个餐厅中使用的简单压缩演算法。</li>
<li>Common Lisp 有由 <tt class="docutils literal"><span class="pre">car</span></tt> 与 <tt class="docutils literal"><span class="pre">cdr</span></tt> 定义的多种存取函数。</li>
<li>映成函数应用函数至逐项的元素，或逐项的列表尾端。</li>
<li>嵌套列表的操作有时被考虑为树的操作。</li>
<li>要判断一个递归函数是否​​正确，你只需要考虑是否包含了所有情况。</li>
<li>列表可以用集合表示。数个内置函数把列表当作集合。</li>
<li>关键字参数是选择性的，并不是由位置所识别，是用符号前面的特殊标签来识别。</li>
<li>列表是序列的子类型。 Common Lisp 有大量的序列函数。</li>
<li>一个不是正规列表的 <em>Cons</em> 称之为点状列表。</li>
<li>用 cons 对象作为元素的列表，可以拿来表示对应关系。这样的列表称为关联列表(assoc-lists)。</li>
<li>自动内存管理拯救你处理内存配置的烦恼，但制造过多的垃圾会使程序变慢。</li>
</ol>
</div>
<div class="section" id="chapter-3-exercises">
<h2>Chapter 3 习题 (Exercises)<a class="headerlink" href="#chapter-3-exercises" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li>用箱子表示法表示以下列表：</li>
</ol>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
<span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nv">c</span> <span class="p">(</span><span class="nv">d</span><span class="p">))))</span>
<span class="p">(</span><span class="nv">c</span><span class="p">)</span> <span class="p">(((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">d</span><span class="p">)</span>
<span class="p">(</span><span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="o">.</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">d</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<ol class="arabic simple" start="2">
<li>写一个保留原本列表中元素顺序的 <tt class="docutils literal"><span class="pre">union</span></tt> 版本：</li>
</ol>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">new-union</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">a</span> <span class="nv">d</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<ol class="arabic simple" start="3">
<li>定义一个函数，接受一个列表并返回一个列表，指出相等元素出现的次数，并由最常见至最少见的排序：</li>
</ol>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">occurrences</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">a</span> <span class="nv">d</span> <span class="nv">a</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">c</span> <span class="nv">a</span><span class="p">))</span>
<span class="p">((</span><span class="nv">A</span> <span class="o">.</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="nv">C</span> <span class="o">.</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nv">D</span> <span class="o">.</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="o">.</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<ol class="arabic simple" start="4">
<li>为什么 <tt class="docutils literal"><span class="pre">(member</span> <span class="pre">'(a)</span> <span class="pre">'((a)</span> <span class="pre">(b)))</span></tt> 返回 nil？</li>
<li>假设函数 <tt class="docutils literal"><span class="pre">pos+</span></tt> 接受一个列表并返回把每个元素加上自己的位置的列表：</li>
</ol>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">pos+</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">7</span> <span class="mi">5</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span><span class="mi">7</span> <span class="mi">6</span> <span class="mi">3</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>使用 (a) 递归 (b) 迭代 (c) <tt class="docutils literal"><span class="pre">mapcar</span></tt> 来定义这个函数。</p>
<ol class="arabic simple" start="6">
<li>经过好几年的审议，政府委员会决定列表应该由 <tt class="docutils literal"><span class="pre">cdr</span></tt> 指向第一个元素，而 <tt class="docutils literal"><span class="pre">car</span></tt> 指向剩下的列表。定义符合政府版本的以下函数：</li>
</ol>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nv">a</span><span class="p">)</span> <span class="nb">cons</span>
<span class="p">(</span><span class="nv">b</span><span class="p">)</span> <span class="nb">list</span>
<span class="p">(</span><span class="nv">c</span><span class="p">)</span> <span class="nb">length</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">lists</span><span class="p">)</span>
<span class="p">(</span><span class="nv">d</span><span class="p">)</span> <span class="nb">member</span> <span class="p">(</span><span class="nv">for</span> <span class="nv">lists</span><span class="c1">; no keywords)</span>
</pre></div>
</td></tr></table></div>
<p><strong>勘误:</strong> 要解决 3.6 (b)，你需要使用到 6.3 节的参数 <tt class="docutils literal"><span class="pre">&amp;rest</span></tt> 。</p>
<ol class="arabic simple" start="7">
<li>修改图 3.6 的程序，使它使用更少 cons 核。 （提示：使用点状列表）</li>
<li>定义一个函数，接受一个列表并用点状表示法印出：</li>
</ol>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">showdots</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="o">.</span> <span class="p">(</span><span class="nv">B</span> <span class="o">.</span> <span class="p">(</span><span class="nv">C</span> <span class="o">.</span> <span class="no">NIL</span><span class="p">)))</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<ol class="arabic simple" start="9">
<li>写一个程序来找到 3.15 节里表示的网络中，最长有限的路径 (不重复)。网络可能包含循环。</li>
</ol>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[3]</a></td><td>这个叙述有点误导，因为只要是对任何东西都不返回 nil 的函数，都不是正规列表。如果给定一个环状 cdr 列表(cdr-circular list)，它会无法终止。环状列表在 12.7 节 讨论。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[4]</a></td><td>12.3 小节会展示更有效率的队列实现方式。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[5]</a></td><td>事实上，我们有一种方式来存取列表。全局变量 <tt class="docutils literal"><span class="pre">*</span></tt> , <tt class="docutils literal"><span class="pre">**</span></tt> , 以及 <tt class="docutils literal"><span class="pre">***</span></tt> 总是设定为最后三个顶层所返回的值。这些变量在除错的时候很有用。</td></tr>
</tbody>
</table>
</div>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'acl-chinese';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                  </div></div>
              </article><div class="clearer"></div>
          </div><div class="span3">
                <div class="sphinxsidebar">
      <div id="sidenav" class="box sphinxsidebarwrapper">


<h4><a href="../index.html">內容目录</a></h4>
  <ul>
<li><a class="reference internal" href="#">第三章：列表</a><ul>
<li><a class="reference internal" href="#conses">3.1 构建 (Conses)</a></li>
<li><a class="reference internal" href="#equality">3.2 等式 (Equality)</a></li>
<li><a class="reference internal" href="#lisp-why-lisp-has-no-pointers">3.3 为什么 Lisp 没有指针 (Why Lisp Has No Pointers)</a></li>
<li><a class="reference internal" href="#building-lists">3.4 建立列表 (Building Lists)</a></li>
<li><a class="reference internal" href="#example-compression">3.5 示例：压缩 (Example: Compression)</a></li>
<li><a class="reference internal" href="#access">3.6 存取 (Access)</a></li>
<li><a class="reference internal" href="#mapping-functions">3.7 映射函数 (Mapping Functions)</a></li>
<li><a class="reference internal" href="#trees">3.8 树 (Trees)</a></li>
<li><a class="reference internal" href="#understanding-recursion">3.9 理解递归 (Understanding Recursion)</a></li>
<li><a class="reference internal" href="#sets">3.10 集合 (Sets)</a></li>
<li><a class="reference internal" href="#sequences">3.11 序列 (Sequences)</a></li>
<li><a class="reference internal" href="#stacks">3.12 栈 (Stacks)</a></li>
<li><a class="reference internal" href="#dotted-lists">3.13 点状列表 (Dotted Lists)</a></li>
<li><a class="reference internal" href="#assoc-lists">3.14 关联列表 (Assoc-lists)</a></li>
<li><a class="reference internal" href="#example-shortest-path">3.15 示例：最短路径 (Example: Shortest Path)</a></li>
<li><a class="reference internal" href="#garbages">3.16 垃圾 (Garbages)</a></li>
<li><a class="reference internal" href="#chapter-3-summary">Chapter 3 总结 (Summary)</a></li>
<li><a class="reference internal" href="#chapter-3-exercises">Chapter 3 习题 (Exercises)</a></li>
</ul>
</li>
</ul>

  
    <h3>本页</h3>
    <ul class="this-page-menu">
      
      
        <li><a href="https://github.com/acl-translation/acl-chinese/blob/redirect-to-new-domain/zhCN/ch3-cn.rst">
          Show on GitHub</a></li>
        <li><a href="https://github.com/acl-translation/acl-chinese/edit/redirect-to-new-domain/zhCN/ch3-cn.rst">
          Edit on GitHub</a></li>
      
    </ul>
  
</div>
    </div>
              </div></div>
      </div>
<footer class="container-fluid">
        <hr />&copy; 版权所有 2012, Juanito Fatas Huang.最后更新日期是 Apr 22, 2013.使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.</footer>
 <!-- End original user content -->


<br>
<br>
<br>


<style type="text/css">
  .rtd-badge {
    position: fixed;
    display: block;
    bottom: 5px;
    height: 40px;
    text-indent: -9999em;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
    -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
  }
  #version_menu {
    position: fixed;
    display: none;
    bottom: 11px;
    right: 166px;
    list-style-type: none;
    margin: 0;
  }
  .footer_popout:hover #version_menu {
    display: block;
  }
  #version_menu li {
    display: block;
    float: right;
  }
  #version_menu li a {
    display: block;
    padding: 6px 10px 4px 10px;
    margin: 7px 7px 0 0;
    font-weight: bold;
    font-size: 14px;
    height: 20px;
    line-height: 17px;
    text-decoration: none;
    color: #fff;
    background: #8ca1af url(../images/gradient-light.png) bottom left repeat-x;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    box-shadow: 0 1px 1px #465158;
    -moz-box-shadow: 0 1px 1px #465158;
    -webkit-box-shadow: 0 1px 1px #465158;
    text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
  }
  #version_menu li a:hover {
    text-decoration: none;
    background-color: #697983;
    box-shadow: 0 1px 0px #465158;
    -moz-box-shadow: 0 1px 0px #465158;
    -webkit-box-shadow: 0 1px 0px #465158;
  }
  .rtd-badge.rtd {
    background: #3b4449 url(//media.readthedocs.org//images/badge-rtd.png) scroll 0px -46px no-repeat;
    border: 1px solid #282E32;
    width: 41px;
    right: 5px;
  }
  .footer_popout:hover .rtd-badge.rtd {
    background-position: top left;
    width: 160px;
  }
  .rtd-badge.revsys { background: #465158 url(//media.readthedocs.org//images/badge-revsys.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 290px;
    right: 173px;
  }
  .rtd-badge.revsys-inline-sponsored {
    position: inherit;
    margin-left: auto;
    margin-right: 175px;
    margin-bottom: 5px;
    background: #465158 url(//media.readthedocs.org//images/badge-revsys.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 290px;
    right: 173px;
  }
  .rtd-badge.revsys-inline {
    position: inherit;
    margin-left: auto;
    margin-right: 175px;
    margin-bottom: 5px;
    background: #465158 url(//media.readthedocs.org//images/badge-revsys-sm.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 205px;
    right: 173px;
  }

</style>
<div class="rtd_doc_footer">
  <div class="footer_popout">
    <a href="//readthedocs.org/projects/ansi-common-lisp/?fromdocs=ansi-common-lisp" class="rtd-badge rtd"> Brought to you by Read the Docs</a>
    <ul id="version_menu">
      
        <li><a href="/en/latest/">latest</a></li>
      
    </ul>
  </div>
</div>
<!-- RTD Analytics Code -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


<!-- User Analytics Code -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-26995626-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</body>
</html>