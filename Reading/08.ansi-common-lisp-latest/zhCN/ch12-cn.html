<!DOCTYPE HTML>

  <html xmlns="http://www.w3.org/1999/xhtml" lang="zh">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
<title>第十二章：结构 &mdash; ANSI Common Lisp 中文版</title>
    
<!-- RTD <head> -->
<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript" src="//media.readthedocs.org/javascript/underscore.js"></script>
<script type="text/javascript" src="//media.readthedocs.org/javascript/doctools.js"></script>

<script type="text/javascript">
  // This is included here for Javascript that doesn't have access to the templates.
  var doc_version = "latest";
  var doc_slug = "ansi-common-lisp";
</script>

<script type="text/javascript" src="//media.readthedocs.org/javascript/rtd.js"></script>
<!-- end RTD <head> -->

    <link rel="stylesheet" href="../_static/han.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/rosefinch.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/main.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:       '../',
        VERSION:        '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX:    '.html',
        HAS_SOURCE:     true
      };
    </script>
    <script type="text/javascript" src="../_static/han.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src=../_static/jquery.dimensions.js"></script>
  <script type="text/javascript" src="../_static/main.js"></script><link rel="top" title="ANSI Common Lisp 中文版" href="../index.html" /></head>

  <body><div class="navbar navbar-static-top navbar-inverse">
        <div id="top-bar" class="navbar-inner">

          <h1 id="logo">ANSI Common Lisp 中文版<a href="../index.html" class="brand">ANSI Common Lisp 中文版</a></h1>
          <ul class="nav"></ul><a href="https://github.com/acl-translation/acl-chinese"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub"></a>
        </div>
      </div><div class="content container-fluid">
        <div class="row-fluid"><div class="document span9"><article >
                <div class="documentwrapper"><div class="body"><div class="section" id="id1">
<h1>第十二章：结构<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>3.3 节中介绍了 Lisp 如何使用指针允许我们将任何值放到任何地方。这种说法是完全有可能的，但这并不一定都是好事。</p>
<p>例如，一个对象可以是它自已的一个元素。这是好事还是坏事，取决于程序员是不是有意这样设计的。</p>
<div class="section" id="shared-structure">
<h2>12.1 共享结构 (Shared Structure)<a class="headerlink" href="#shared-structure" title="永久链接至标题">¶</a></h2>
<p>多个列表可以共享 <tt class="docutils literal"><span class="pre">cons</span></tt> 。在最简单的情况下，一个列表可以是另一个列表的一部分。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">part</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">))</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">whole</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="nv">part</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<div class="figure">
<img alt="../_images/Figure-12.1.png" src="../_images/Figure-12.1.png" />
</div>
<p><strong>图 12.1 共享结构</strong></p>
<p>执行上述操作后，第一个 <tt class="docutils literal"><span class="pre">cons</span></tt> 是第二个 <tt class="docutils literal"><span class="pre">cons</span></tt> 的一部分 (事实上，是第二个 <tt class="docutils literal"><span class="pre">cons</span></tt> 的 <tt class="docutils literal"><span class="pre">cdr</span></tt> )。在这样的情况下，我们说，这两个列表是共享结构 (Share Structure)。这两个列表的基本结构如图 12.1 所示。</p>
<p>其中，第一个 <tt class="docutils literal"><span class="pre">cons</span></tt> 是第二个 <tt class="docutils literal"><span class="pre">cons</span></tt> 的一部分 (事实上，是第二个 <tt class="docutils literal"><span class="pre">cons</span></tt> 的 <tt class="docutils literal"><span class="pre">cdr</span></tt> )。在这样的情况下，我们称这两个列表为共享结构 (Share Structure)。这两个列表的基本结构如图 12.1 所示。</p>
<p>使用 <tt class="docutils literal"><span class="pre">tailp</span></tt> 判断式来检测一下。将两个列表作为它的输入参数，如果第一个列表是第二个列表的一部分时，则返回 <tt class="docutils literal"><span class="pre">T</span></tt> ：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">tailp</span> <span class="nv">part</span> <span class="nv">whole</span><span class="p">)</span>
<span class="no">T</span>
</pre></div>
</td></tr></table></div>
<p>我们可以把它想像成：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-tailp</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">y</span><span class="p">)</span>
                         <span class="p">(</span><span class="nv">our-tailp</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>如定义所表明的，每个列表都是它自己的尾端， <tt class="docutils literal"><span class="pre">nil</span></tt> 是每一个正规列表的尾端。</p>
<p>在更复杂的情况下，两个列表可以是共享结构，但彼此都不是对方的尾端。在这种情况下，他们都有一个共同的尾端，如图 12.2 所示。我们像这样构建这种情况：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">part</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">)</span>
                        <span class="nv">whole1</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">1</span> <span class="nv">part</span><span class="p">)</span>
                        <span class="nv">whole2</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">2</span> <span class="nv">part</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<div class="figure">
<img alt="../_images/Figure-12.2.png" src="../_images/Figure-12.2.png" />
</div>
<p><strong>图 12.2 被共享的尾端</strong></p>
<p>现在 <tt class="docutils literal"><span class="pre">whole1</span></tt> 和 <tt class="docutils literal"><span class="pre">whole2</span></tt> 共享结构，但是它们彼此都不是对方的一部分。</p>
<p>当存在嵌套列表时，重要的是要区分是列表共享了结构，还是列表的元素共享了结构。顶层列表结构指的是，直接构成列表的那些 <tt class="docutils literal"><span class="pre">cons</span></tt> ，而不包含那些用于构造列表元素的 <tt class="docutils literal"><span class="pre">cons</span></tt> 。图 12.3 是一个嵌套列表的顶层列表结构 (<strong>译者注：</strong>图 12.3 中上面那三个有黑色阴影的 <tt class="docutils literal"><span class="pre">cons</span></tt> 即构成顶层列表结构的 <tt class="docutils literal"><span class="pre">cons</span></tt> )。</p>
<div class="figure">
<img alt="../_images/Figure-12.3.png" src="../_images/Figure-12.3.png" />
</div>
<p><strong>图 12.3 顶层列表结构</strong></p>
<p>两个 <tt class="docutils literal"><span class="pre">cons</span></tt> 是否共享结构，取决于我们把它们看作是列表还是<a class="reference external" href="http://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">树</a>。可能存在两个嵌套列表，当把它们看作树时，它们共享结构，而看作列表时，它们不共享结构。图 12.4 构建了这种情况，两个列表以一个元素的形式包含了同一个列表，代码如下：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">element</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span>
      <span class="nv">holds1</span> <span class="p">(</span><span class="nb">list</span> <span class="mi">1</span> <span class="nv">element</span> <span class="mi">2</span><span class="p">)</span>
      <span class="nv">holds2</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">element</span> <span class="mi">3</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<div class="figure">
<img alt="../_images/Figure-12.4.png" src="../_images/Figure-12.4.png" />
</div>
<p><strong>图 12.4 共享子树</strong></p>
<p>虽然 <tt class="docutils literal"><span class="pre">holds1</span></tt> 的第二个元素和 <tt class="docutils literal"><span class="pre">holds2</span></tt> 的第一个元素共享结构 (其实是相同的)，但如果把 <tt class="docutils literal"><span class="pre">holds1</span></tt> 和 <tt class="docutils literal"><span class="pre">holds2</span></tt> 看成是列表时，它们不共享结构。仅当两个列表共享顶层列表结构时，才能说这两个列表共享结构，而 <tt class="docutils literal"><span class="pre">holds1</span></tt> 和 <tt class="docutils literal"><span class="pre">holds2</span></tt> 没有共享顶层列表结构。</p>
<p>如果我们想避免共享结构，可以使用复制。函数 <tt class="docutils literal"><span class="pre">copy-list</span></tt> 可以这样定义：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-copy-list</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
       <span class="no">nil</span>
       <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nv">our-copy-list</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>它返回一个不与原始列表共享顶层列表结构的新列表。函数 <tt class="docutils literal"><span class="pre">copy-tree</span></tt> 可以这样定义：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-copy-tree</span> <span class="p">(</span><span class="nv">tr</span><span class="p">)</span>
   <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">atom</span> <span class="nv">tr</span><span class="p">)</span>
        <span class="nv">tr</span>
        <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">our-copy-tree</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">tr</span><span class="p">))</span>
              <span class="p">(</span><span class="nv">our-copy-tree</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">tr</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>它返回一个连原始列表的树型结构也不共享的新列表。图 12.5 显示了对一个嵌套列表使用 <tt class="docutils literal"><span class="pre">copy-list</span></tt> 和 <tt class="docutils literal"><span class="pre">copy-tree</span></tt> 的区别。</p>
<div class="figure">
<img alt="../_images/Figure-12.5.png" src="../_images/Figure-12.5.png" />
</div>
<p><strong>图 12.5 两种复制</strong></p>
</div>
<div class="section" id="modification">
<h2>12.2 修改 (Modification)<a class="headerlink" href="#modification" title="永久链接至标题">¶</a></h2>
<p>为什么要避免共享结构呢？之前讨论的共享结构问题仅仅是个智力练习，到目前为止，并没使我们在实际写程序的时候有什么不同。当修改一个被共享的结构时，问题出现了。如果两个列表共享结构，当我们修改了其中一个，另外一个也会无意中被修改。</p>
<p>上一节中，我们介绍了怎样构建一个是其它列表的尾端的列表：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">whole</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span><span class="p">)</span>
      <span class="nv">tail</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">whole</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>因为 <tt class="docutils literal"><span class="pre">whole</span></tt> 的 <tt class="docutils literal"><span class="pre">cdr</span></tt> 与 <tt class="docutils literal"><span class="pre">tail</span></tt> 是相等的，无论是修改 <tt class="docutils literal"><span class="pre">tail</span></tt> 还是 <tt class="docutils literal"><span class="pre">whole</span></tt> 的 <tt class="docutils literal"><span class="pre">cdr</span></tt> ，我们修改的都是同一个 <tt class="docutils literal"><span class="pre">cons</span></tt> ：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">second</span> <span class="nv">tail</span> <span class="p">)</span> <span class="ss">&#39;e</span><span class="p">)</span>
<span class="nv">E</span>
<span class="nb">&gt;</span> <span class="nv">tail</span>
<span class="p">(</span><span class="nv">B</span> <span class="nv">E</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="nv">whole</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">E</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>同样的，如果两个列表共享同一个尾端，这种情况也会发生。</p>
<p>一次修改两个对象并不总是错误的。有时候这可能正是你想要的。但如果无意的修改了共享结构，将会引入一些非常微妙的 bug。Lisp 程序员要培养对共享结构的意识，并且在这类错误发生时能够立刻反应过来。当一个列表神秘的改变了的时候，很有可能是因为改变了其它与之共享结构的对象。</p>
<p>真正危险的不是共享结构，而是改变被共享的结构。为了安全起见，干脆避免对结构使用 <tt class="docutils literal"><span class="pre">setf</span></tt> (以及相关的运算，比如： <tt class="docutils literal"><span class="pre">pop</span></tt> ， <tt class="docutils literal"><span class="pre">rplaca</span></tt> 等)，这样就不会遇到问题了。如果某些时候不得不修改列表结构时，要搞清楚要修改的列表的来源，确保它不要和其它不需要改变的对象共享结构。如果它和其它不需要改变的对象共享了结构，或者不能预测它的来源，那么复制一个副本来进行改变。</p>
<p>当你调用别人写的函数的时候要加倍小心。除非你知道它内部的操作，否则，你传入的参数时要考虑到以下的情况：</p>
<p>1.它对你传入的参数可能会有破坏性的操作</p>
<p>2.你传入的参数可能被保存起来，如果你调用了一个函数，然后又修改了之前作为参数传入该函数的对象，那么你也就改变了函数已保存起来作为它用的对象[1]。</p>
<p>在这两种情况下，解决的方法是传入一个拷贝。</p>
<p>在 Common Lisp 中，一个函数调用在遍历列表结构 (比如， <tt class="docutils literal"><span class="pre">mapcar</span></tt> 或 <tt class="docutils literal"><span class="pre">remove-if</span></tt> 的参数)的过程中不允许修改被遍历的结构。关于评估这样的代码的重要性并没有明确的规定。</p>
</div>
<div class="section" id="example-queues">
<h2>12.3 示例：队列 (Example: Queues)<a class="headerlink" href="#example-queues" title="永久链接至标题">¶</a></h2>
<p>共享结构并不是一个总让人担心的特性。我们也可以对其加以利用的。这一节展示了怎样用共享结构来表示<a class="reference external" href="http://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97">队列</a>。队列对象是我们可以按照数据的插入顺序逐个检出数据的仓库，这个规则叫做<a class="reference external" href="http://zh.wikipedia.org/zh-cn/%E5%85%88%E9%80%B2%E5%85%88%E5%87%BA">先进先出 (FIFO, first in, first out)</a>。</p>
<p>用列表表示<a class="reference external" href="http://zh.wikipedia.org/wiki/%E6%A0%88">栈 (stack)</a>比较容易，因为栈是从同一端插入和检出。而表示队列要困难些，因为队列的插入和检出是在不同端。为了有效的实现队列，我们需要找到一种办法来指向列表的两个端。</p>
<p>图 12.6 给出了一种可行的策略。它展示怎样表示一个含有 a，b，c 三个元素的队列。一个队列就是一对列表，最后那个 <tt class="docutils literal"><span class="pre">cons</span></tt> 在相同的列表中。这个列表对由被称作头端 (front)和尾端 (back)的两部分组成。如果要从队列中检出一个元素，只需在其头端 <tt class="docutils literal"><span class="pre">pop``，要插入一个元素，则创建一个新的</span> <span class="pre">``cons</span></tt> ，把尾端的 <tt class="docutils literal"><span class="pre">cdr</span></tt> 设置成指向这个 <tt class="docutils literal"><span class="pre">cons</span></tt> ，然后将尾端指向这个新的 <tt class="docutils literal"><span class="pre">cons</span></tt> 。</p>
<div class="figure">
<img alt="../_images/Figure-12.6.png" src="../_images/Figure-12.6.png" />
</div>
<p><strong>图 12.6 一个队列的结构</strong></p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">make-queue</span> <span class="p">()</span> <span class="p">(</span><span class="nb">cons</span> <span class="no">nil</span> <span class="no">nil</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">enqueue</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">q</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">q</span><span class="p">))</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">obj</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">q</span><span class="p">))</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">obj</span><span class="p">)</span>
            <span class="p">(</span><span class="nb">cdr</span> <span class="nv">q</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">q</span><span class="p">))))</span>
  <span class="p">(</span><span class="nb">car</span> <span class="nv">q</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">dequeue</span> <span class="p">(</span><span class="nv">q</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">pop</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">q</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p><strong>图 12.7 队列实现</strong></p>
<p>图 12.7 中的代码实现了这一策略。其用法如下：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">q1</span> <span class="p">(</span><span class="nv">make-queue</span><span class="p">))</span>
<span class="p">(</span><span class="no">NIL</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span> <span class="p">(</span><span class="nv">enqueue</span> <span class="ss">&#39;a</span> <span class="nv">q1</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">enqueue</span> <span class="ss">&#39;b</span> <span class="nv">q1</span><span class="p">)</span>
         <span class="p">(</span><span class="nv">enqueue</span> <span class="ss">&#39;c</span> <span class="nv">q1</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>现在， <tt class="docutils literal"><span class="pre">q1</span></tt> 的结构就如图 12.6 那样：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="nv">q1</span>
<span class="p">((</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span> <span class="nv">C</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>从队列中检出一些元素：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">dequeue</span> <span class="nv">q1</span><span class="p">)</span>
<span class="nv">A</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">dequeue</span> <span class="nv">q1</span><span class="p">)</span>
<span class="nv">B</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">enqueue</span> <span class="ss">&#39;d</span> <span class="nv">q1</span><span class="p">)</span>
<span class="p">(</span><span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="destructive-functions">
<h2>12.4 破坏性函数 (Destructive Functions)<a class="headerlink" href="#destructive-functions" title="永久链接至标题">¶</a></h2>
<p>Common Lisp 包含一些允许修改列表结构的函数。为了提高效率，这些函数是具有破坏性的。虽然它们可以回收利用作为参数传给它们的 <tt class="docutils literal"><span class="pre">cons</span></tt> ，但并不是因为想要它们的副作用而调用它们 (<strong>译者注：</strong>因为这些函数的副作用并没有任何保证，下面的例子将说明问题)。</p>
<p>比如， <tt class="docutils literal"><span class="pre">delete</span></tt> 是 <tt class="docutils literal"><span class="pre">remove</span></tt> 的一个具有破坏性的版本。虽然它可以破坏作为参数传给它的列表，但它并不保证什么。在大多数的 Common Lisp 的实现中，会出现下面的情况：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">lst</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">r</span> <span class="nv">a</span> <span class="nv">b</span> <span class="nv">i</span> <span class="nv">a</span><span class="p">)</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">R</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">I</span> <span class="nv">A</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">delete</span> <span class="ss">&#39;a</span> <span class="nv">lst</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">R</span> <span class="nv">B</span> <span class="nv">I</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="nv">lst</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">R</span> <span class="nv">B</span> <span class="nv">I</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>正如 <tt class="docutils literal"><span class="pre">remove</span></tt> 一样，如果你想要副作用，应该对返回值使用 <tt class="docutils literal"><span class="pre">setf</span></tt> ：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">setf</span> <span class="nv">lst</span> <span class="p">(</span><span class="nb">delete</span> <span class="ss">&#39;a</span> <span class="nv">lst</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>破坏性函数是怎样回收利用传给它们的列表的呢？比如，可以考虑 <tt class="docutils literal"><span class="pre">nconc</span></tt> —— <tt class="docutils literal"><span class="pre">append</span></tt> 的破坏性版本。[2]下面是两个参数版本的实现，其清楚地展示了两个已知列表是怎样被缝在一起的：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">nconc2</span> <span class="p">(</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">consp</span> <span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="k">progn</span>
           <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">last</span> <span class="nv">x</span><span class="p">))</span> <span class="nv">y</span><span class="p">)</span>
            <span class="nv">x</span><span class="p">)</span>
         <span class="nv">y</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>我们找到第一个列表的最后一个 <em>Cons</em> 核 (cons cells)，把它的 <tt class="docutils literal"><span class="pre">cdr</span></tt> 设置成指向第二个列表。一个正规的多参数的 <tt class="docutils literal"><span class="pre">nconc</span></tt> 可以被定义成像附录 B 中的那样。</p>
<p>函数 <tt class="docutils literal"><span class="pre">mapcan</span></tt> 类似 <tt class="docutils literal"><span class="pre">mapcar</span></tt> ，但它是用 <tt class="docutils literal"><span class="pre">nconc</span></tt> 把函数的返回值 (必须是列表) 拼接在一起的：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcan</span> <span class="nf">#&#39;</span><span class="nb">list</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
          <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
<span class="p">(</span> <span class="nv">A</span> <span class="mi">1</span> <span class="nv">B</span> <span class="mi">2</span> <span class="nv">C</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>这个函数可以定义如下：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-mapcan</span> <span class="p">(</span><span class="nv">fn</span> <span class="k">&amp;rest</span> <span class="nv">lsts</span> <span class="p">)</span>
       <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">nconc</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">mapcar</span> <span class="nv">fn</span> <span class="nv">lsts</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>使用 <tt class="docutils literal"><span class="pre">mapcan</span></tt> 时要谨慎，因为它具有破坏性。它用 <tt class="docutils literal"><span class="pre">nconc</span></tt> 拼接返回的列表，所以这些列表最好不要再在其它地方使用。</p>
<p>这类函数在处理某些问题的时候特别有用，比如，收集树在某层上的所有子结点。如果 <tt class="docutils literal"><span class="pre">children</span></tt> 函数返回一个节点的孩子节点的列表，那么我们可以定义一个函数返回某节点的孙子节点的列表如下：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">grandchildren</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nb">mapcan</span> <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">c</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">copy-list</span> <span class="p">(</span><span class="nv">children</span> <span class="nv">c</span><span class="p">)))</span>
           <span class="p">(</span><span class="nv">children</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>这个函数调用 <tt class="docutils literal"><span class="pre">copy-list</span></tt> 时存在一个假设  —— <tt class="docutils literal"><span class="pre">chlidren</span></tt> 函数返回的是一个已经保存在某个地方的列表，而不是构建了一个新的列表。</p>
<p>一个 <tt class="docutils literal"><span class="pre">mapcan</span></tt> 的无损变体可以这样定义：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">mappend</span> <span class="p">(</span><span class="nv">fn</span> <span class="k">&amp;rest</span> <span class="nv">lsts</span> <span class="p">)</span>
    <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">append</span> <span class="p">(</span><span class="nb">apply</span> <span class="nf">#&#39;</span><span class="nb">mapcar</span> <span class="nv">fn</span> <span class="nv">lsts</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>如果使用 <tt class="docutils literal"><span class="pre">mappend</span></tt> 函数，那么 <tt class="docutils literal"><span class="pre">grandchildren</span></tt> 的定义就可以省去 <tt class="docutils literal"><span class="pre">copy-list</span></tt> ：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">grandchildren</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
   <span class="p">(</span><span class="nv">mappend</span> <span class="nf">#&#39;</span><span class="nv">children</span> <span class="p">(</span><span class="nv">children</span> <span class="nv">x</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="example-binary-search-trees">
<h2>12.5 示例：二叉搜索树 (Example: Binary Search Trees)<a class="headerlink" href="#example-binary-search-trees" title="永久链接至标题">¶</a></h2>
<p>在某些情况下，使用破坏性操作比使用非破坏性的显得更自然。第 4.7 节中展示了如何维护一个具有二分搜索格式的有序对象集 (或者说维护一个<a class="reference external" href="http://zh.wikipedia.org/zh-cn/%E4%BA%8C%E5%85%83%E6%90%9C%E5%B0%8B%E6%A8%B9">二叉搜索树 (BST)</a>)。第 4.7 节中给出的函数都是非破坏性的，但在我们真正使用BST的时候，这是一个不必要的保护措施。本节将展示如何定义更符合实际应用的具有破坏性的插入函数和删除函数。</p>
<p>图 12.8 展示了如何定义一个具有破坏性的 <tt class="docutils literal"><span class="pre">bst-insert</span></tt> (第 72 页「<strong>译者注：</strong>第 4.7 节」)。相同的输入参数，能够得到相同返回值。唯一的区别是，它将修改作为第二个参数输入的 BST。 在第 2.12 节中说过，具有破坏性并不意味着一个函数调用具有副作用。的确如此，如果你想使用 <tt class="docutils literal"><span class="pre">bst-insert!</span></tt> 构造一个 BST，你必须像调用 <tt class="docutils literal"><span class="pre">bst-insert</span></tt> 那样调用它：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="vg">*bst*</span> <span class="no">nil</span><span class="p">)</span>
<span class="no">NIL</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">7</span> <span class="mi">2</span> <span class="mi">9</span> <span class="mi">8</span> <span class="mi">4</span> <span class="mi">1</span> <span class="mi">5</span> <span class="mi">12</span><span class="p">))</span>
<span class="p">(</span><span class="nb">setf</span> <span class="vg">*bst*</span> <span class="p">(</span><span class="nv">bst-insert!</span> <span class="nv">x</span> <span class="vg">*bst*</span> <span class="nf">#&#39;</span><span class="nb">&lt;</span><span class="p">)))</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">bst-insert!</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">bst</span> <span class="nb">&lt;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">bst</span><span class="p">)</span>
      <span class="p">(</span><span class="nv">make-node</span> <span class="ss">:elt</span> <span class="nv">obj</span><span class="p">)</span>
      <span class="p">(</span><span class="k">progn</span> <span class="p">(</span><span class="nv">bsti</span> <span class="nv">obj</span> <span class="nv">bst</span> <span class="nb">&lt;</span><span class="p">)</span>
             <span class="nv">bst</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">bsti</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">bst</span> <span class="nb">&lt;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">elt</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">bst</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nv">obj</span> <span class="nb">elt</span><span class="p">)</span>
        <span class="nv">bst</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nb">&lt;</span> <span class="nv">obj</span> <span class="nb">elt</span><span class="p">)</span>
            <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">l</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)))</span>
              <span class="p">(</span><span class="k">if</span> <span class="nv">l</span>
                  <span class="p">(</span><span class="nv">bsti</span> <span class="nv">obj</span> <span class="nv">l</span> <span class="nb">&lt;</span><span class="p">)</span>
                  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)</span>
                        <span class="p">(</span><span class="nv">make-node</span> <span class="ss">:elt</span> <span class="nv">obj</span><span class="p">))))</span>
            <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">r</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)))</span>
              <span class="p">(</span><span class="k">if</span> <span class="nv">r</span>
                  <span class="p">(</span><span class="nv">bsti</span> <span class="nv">obj</span> <span class="nv">r</span> <span class="nb">&lt;</span><span class="p">)</span>
                  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)</span>
                        <span class="p">(</span><span class="nv">make-node</span> <span class="ss">:elt</span> <span class="nv">obj</span><span class="p">))))))))</span>
</pre></div>
</td></tr></table></div>
<p><strong>图 12.8: 二叉搜索树：破坏性插入</strong></p>
<p>你也可以为 BST 定义一个类似 push 的功能，但这超出了本书的范围。(好奇的话，可以参考第 409 页 「<strong>译者注：</strong>即备注 204 」 的宏定义。)</p>
<p>与 <tt class="docutils literal"><span class="pre">bst-remove</span></tt> (第 74 页「<strong>译者注：</strong>第 4.7 节」) 对应，图 12.9 展示了一个破坏性版本的 <tt class="docutils literal"><span class="pre">bst-delete</span></tt> 。同 <tt class="docutils literal"><span class="pre">delete</span></tt> 一样，我们调用它并不是因为它的副作用。你应该像调用 <tt class="docutils literal"><span class="pre">bst-remove</span></tt> 那样调用 <tt class="docutils literal"><span class="pre">bst-delete</span></tt> ：</p>
<div class="highlight-cl"><pre>&gt; (setf *bst* (bst-delete 2 *bst* #'&lt;) )
#&lt;7&gt;
&gt; (bst-find 2 *bst* #'&lt;)
NIL</pre>
</div>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">bst-delete</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">bst</span> <span class="nb">&lt;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="nv">bst</span> <span class="p">(</span><span class="nv">bstd</span> <span class="nv">obj</span> <span class="nv">bat</span> <span class="no">nil</span> <span class="no">nil</span> <span class="nb">&lt;</span><span class="p">))</span>
  <span class="nv">bst</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">bstd</span> <span class="p">(</span><span class="nv">obj</span> <span class="nv">bst</span> <span class="nv">prev</span> <span class="nv">dir</span> <span class="nb">&lt;</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">elt</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">bst</span><span class="p">)))</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">eql</span> <span class="nb">elt</span> <span class="nv">obj</span><span class="p">)</span>
        <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">rest</span> <span class="p">(</span><span class="nv">percolate!</span> <span class="nv">bst</span><span class="p">)))</span>
          <span class="p">(</span><span class="nb">case</span> <span class="nv">dir</span>
            <span class="p">(</span><span class="ss">:l</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">prev</span><span class="p">)</span> <span class="nb">rest</span><span class="p">))</span>
            <span class="p">(</span><span class="ss">:r</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">prev</span><span class="p">)</span> <span class="nb">rest</span><span class="p">))))</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nb">&lt;</span> <span class="nv">obj</span> <span class="nb">elt</span><span class="p">)</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)</span>
              <span class="p">(</span><span class="nv">bstd</span> <span class="nv">obj</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)</span> <span class="nv">bst</span> <span class="ss">:l</span> <span class="nb">&lt;</span><span class="p">))</span>
          <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)</span>
              <span class="p">(</span><span class="nv">bstd</span> <span class="nv">obj</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)</span> <span class="nv">bst</span> <span class="ss">:r</span> <span class="nb">&lt;</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">percolate!</span> <span class="p">(</span><span class="nv">bst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">))</span>
         <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">))</span>
             <span class="no">nil</span>
             <span class="p">(</span><span class="nv">rperc!</span> <span class="nv">bst</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">null</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">))</span> <span class="p">(</span><span class="nv">lperc!</span> <span class="nv">bst</span><span class="p">))</span>
        <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">random</span> <span class="mi">2</span><span class="p">))</span>
               <span class="p">(</span><span class="nv">lperc!</span> <span class="nv">bst</span><span class="p">)</span>
               <span class="p">(</span><span class="nv">rperc!</span> <span class="nv">bst</span><span class="p">)))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">lperc!</span> <span class="p">(</span><span class="nv">bst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">bst</span><span class="p">)</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">percolate!</span> <span class="p">(</span><span class="nv">node-l</span> <span class="nv">bst</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">rperc!</span> <span class="p">(</span><span class="nv">bst</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="nv">bst</span><span class="p">)</span> <span class="p">(</span><span class="nv">node-elt</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">percolate!</span> <span class="p">(</span><span class="nv">node-r</span> <span class="nv">bst</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p><strong>图 12.9: 二叉搜索树：破坏性删除</strong></p>
<p><strong>译注:</strong> 此范例已被回报为错误的，一个修复的版本请造访<a class="reference external" href="https://gist.github.com/2868339">这里</a>。</p>
</div>
<div class="section" id="example-doubly-linked-lists">
<h2>12.6 示例：双向链表 (Example: Doubly-Linked Lists)<a class="headerlink" href="#example-doubly-linked-lists" title="永久链接至标题">¶</a></h2>
<p>普通的 Lisp 列表是单向链表，这意味着其指针指向一个方向：我们可以获取下一个元素，但不能获取前一个。在<a class="reference external" href="http://zh.wikipedia.org/wiki/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8">双向链表</a>中，指针指向两个方向，我们获取前一个元素和下一个元素都很容易。这一节将介绍如何创建和操作双向链表。</p>
<p>图 12.10 展示了如何用结构来实现双向链表。将 <tt class="docutils literal"><span class="pre">cons</span></tt> 看成一种结构，它有两个字段：指向数据的 <tt class="docutils literal"><span class="pre">car</span></tt> 和指向下一个元素的 <tt class="docutils literal"><span class="pre">cdr</span></tt> 。要实现一个双向链表，我们需要第三个字段，用来指向前一个元素。图 12.10 中的 <tt class="docutils literal"><span class="pre">defstruct</span></tt> 定义了一个含有三个字段的对象 <tt class="docutils literal"><span class="pre">dl</span></tt> (用于“双向链接”)，我们将用它来构造双向链表。``dl`` 的 <tt class="docutils literal"><span class="pre">data</span></tt> 字段对应一个 <tt class="docutils literal"><span class="pre">cons</span></tt> 的 <tt class="docutils literal"><span class="pre">car``，``next</span></tt> 字段对应 <tt class="docutils literal"><span class="pre">cdr</span></tt> 。 <tt class="docutils literal"><span class="pre">prev</span></tt> 字段就类似一个 <tt class="docutils literal"><span class="pre">cdr</span></tt> ，指向另外一个方向。(图 12.11 是一个含有三个元素的双向链表。) 空的双向链表为 <tt class="docutils literal"><span class="pre">nil</span></tt> ，就像空的列表一样。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defstruct</span> <span class="p">(</span><span class="nv">dl</span> <span class="p">(</span><span class="ss">:print-function</span> <span class="nv">print-dl</span><span class="p">))</span>
  <span class="nv">prev</span> <span class="nv">data</span> <span class="nv">next</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">print-dl</span> <span class="p">(</span><span class="nv">dl</span> <span class="nc">stream</span> <span class="nv">depth</span><span class="p">)</span>
  <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="k">ignore</span> <span class="nv">depth</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">format</span> <span class="nc">stream</span> <span class="s">&quot;#&lt;DL ~A&gt;&quot;</span> <span class="p">(</span><span class="nv">dl-&gt;list</span> <span class="nv">dl</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">dl-&gt;list</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">dl-p</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">dl-data</span> <span class="nv">lst</span><span class="p">)</span> <span class="p">(</span><span class="nv">dl-&gt;list</span> <span class="p">(</span><span class="nv">dl-next</span> <span class="nv">lst</span><span class="p">)))</span>
      <span class="nv">lst</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">dl-insert</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nb">elt</span> <span class="p">(</span><span class="nv">make-dl</span> <span class="ss">:data</span> <span class="nv">x</span> <span class="ss">:next</span> <span class="nv">lst</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nv">dl-p</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">)</span>
          <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">dl-next</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">))</span> <span class="nb">elt</span>
                <span class="p">(</span><span class="nv">dl-prev</span> <span class="nb">elt</span><span class="p">)</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">)</span> <span class="nb">elt</span><span class="p">))</span>
    <span class="nb">elt</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">dl-list</span> <span class="p">(</span><span class="k">&amp;rest</span> <span class="nv">args</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">reduce</span> <span class="nf">#&#39;</span><span class="nv">dl-insert</span> <span class="nv">args</span>
          <span class="ss">:from-end</span> <span class="no">t</span> <span class="ss">:initial-value</span> <span class="no">nil</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">dl-remove</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">dl-next</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">))</span> <span class="p">(</span><span class="nv">dl-next</span> <span class="nv">lst</span><span class="p">)))</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nv">dl-next</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="p">(</span><span class="nv">dl-next</span> <span class="nv">lst</span><span class="p">))</span> <span class="p">(</span><span class="nv">dl-prev</span> <span class="nv">lst</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">dl-next</span> <span class="nv">lst</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p><strong>图 12.10: 构造双向链表</strong></p>
<div class="figure">
<img alt="../_images/Figure-12.11.png" src="../_images/Figure-12.11.png" />
</div>
<p><strong>图 12.11: 一个双向链表。</strong></p>
<p>为了便于操作，我们为双向链表定义了一些实现类似 <tt class="docutils literal"><span class="pre">car</span></tt> ， <tt class="docutils literal"><span class="pre">cdr</span></tt> ， <tt class="docutils literal"><span class="pre">consp</span></tt> 功能的函数：``dl-data`` ， <tt class="docutils literal"><span class="pre">dl-next</span></tt> 和 <tt class="docutils literal"><span class="pre">dl-p</span></tt> 。 <tt class="docutils literal"><span class="pre">dl-&gt;list</span></tt> 是 <tt class="docutils literal"><span class="pre">dl</span></tt> 的打印函数(<tt class="docutils literal"><span class="pre">print-function</span></tt>)，其返回一个包含 <tt class="docutils literal"><span class="pre">dl</span></tt> 所有元素的普通列表。</p>
<p>函数 <tt class="docutils literal"><span class="pre">dl-insert</span></tt> 就像针对双向链表的 <tt class="docutils literal"><span class="pre">cons</span></tt> 操作。至少，它就像 <tt class="docutils literal"><span class="pre">cons</span></tt> 一样，是一个基本构建函数。与 <tt class="docutils literal"><span class="pre">cons</span></tt> 不同的是，它实际上要修改作为第二个参数传递给它的双向链表。在这种情况下，这是自然而然的。我们 <tt class="docutils literal"><span class="pre">cons</span></tt> 内容到普通列表前面，不需要对普通列表的 <tt class="docutils literal"><span class="pre">rest</span></tt> (<strong>译者注：</strong> <tt class="docutils literal"><span class="pre">rest</span></tt> 即 <tt class="docutils literal"><span class="pre">cdr</span></tt> 的另一种表示方法，这里的 <tt class="docutils literal"><span class="pre">rest</span></tt> 是对通过 <tt class="docutils literal"><span class="pre">cons</span></tt> 构建后列表来说的，即修改之前的列表) 做任何修改。但是要在双向链表的前面插入元素，我们不得不修改列表的 <tt class="docutils literal"><span class="pre">rest</span></tt> (这里的 <tt class="docutils literal"><span class="pre">rest</span></tt> 即指没修改之前的双向链表) 的 <tt class="docutils literal"><span class="pre">prev</span></tt> 字段来指向这个新元素。</p>
<p>几个普通列表可以共享同一个尾端。因为双向链表的尾端不得不指向它的前一个元素，所以不可能存在两个双向链表共享同一个尾端。如果 <tt class="docutils literal"><span class="pre">dl-insert</span></tt> 不具有破坏性，那么它不得不复制其第二个参数。</p>
<p>单向链表(普通列表)和双向链表另一个有趣的区别是，如何持有它们。我们使用普通列表的首端，来表示单向链表，如果将列表赋值给一个变量，变量可以通过保存指向列表第一个 <tt class="docutils literal"><span class="pre">cons</span></tt> 的指针来持有列表。但是双向链表是双向指向的，我们可以用任何一个点来持有双向链表。 <tt class="docutils literal"><span class="pre">dl-insert</span></tt> 另一个不同于 <tt class="docutils literal"><span class="pre">cons</span></tt> 的地方在于 <tt class="docutils literal"><span class="pre">dl-insert</span></tt> 可以在双向链表的任何位置插入新元素，而 <tt class="docutils literal"><span class="pre">cons</span></tt> 只能在列表的首端插入。</p>
<p>函数 <tt class="docutils literal"><span class="pre">dl-list</span></tt> 是对于 <tt class="docutils literal"><span class="pre">dl</span></tt> 的类似 <tt class="docutils literal"><span class="pre">list</span></tt> 的功能。它接受任意多个参数，它会返回一个包含以这些参数作为元素的 <tt class="docutils literal"><span class="pre">dl</span></tt> ：</p>
<div class="highlight-cl"><pre>&gt; (dl-list 'a 'b 'c)
#&lt;DL (A B C)&gt;</pre>
</div>
<p>它使用了 <tt class="docutils literal"><span class="pre">reduce</span></tt> 函数 (并设置其 <tt class="docutils literal"><span class="pre">from-end</span></tt> 参数为 <tt class="docutils literal"><span class="pre">true``，``initial-value</span></tt> 为 <tt class="docutils literal"><span class="pre">nil</span></tt>)，其功能等价于</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nv">dl-insert</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nv">dl-insert</span> <span class="ss">&#39;b</span> <span class="p">(</span><span class="nv">dl-insert</span> <span class="ss">&#39;c</span> <span class="no">nil</span><span class="p">))</span> <span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>如果将 <tt class="docutils literal"><span class="pre">dl-list</span></tt> 定义中的 <tt class="docutils literal"><span class="pre">#'dl-insert</span></tt> 换成 <tt class="docutils literal"><span class="pre">#'cons``，它就相当于</span> <span class="pre">``list</span></tt> 函数了。下面是 <tt class="docutils literal"><span class="pre">dl-list</span></tt> 的一些常见用法：</p>
<div class="highlight-cl"><pre>&gt; (setf dl (dl-list 'a 'b))
#&lt;DL (A B)&gt;
&gt; (setf dl (dl-insert 'c dl))
#&lt;DL (C A B)&gt;
&gt; (dl-insert 'r (dl-next dl))
#&lt;DL (R A B)&gt;
&gt; dl
#&lt;DL (C R A B)&gt;</pre>
</div>
<p>最后，``dl-remove`` 的作用是从双向链表中移除一个元素。同 <tt class="docutils literal"><span class="pre">dl-insert</span></tt> 一样，它也是具有破坏性的。</p>
</div>
<div class="section" id="circular-structure">
<h2>12.7 环状结构 (Circular Structure)<a class="headerlink" href="#circular-structure" title="永久链接至标题">¶</a></h2>
<p>将列表结构稍微修改一下，就可以得到一个环形列表。存在两种环形列表。最常用的一种是其顶层列表结构是一个环的，我们把它叫做 <tt class="docutils literal"><span class="pre">cdr-circular</span></tt> ，因为环是由一个 <tt class="docutils literal"><span class="pre">cons</span></tt> 的 <tt class="docutils literal"><span class="pre">cdr</span></tt> 构成的。</p>
<p>构造一个单元素的 <tt class="docutils literal"><span class="pre">cdr-circular</span></tt> 列表，可以将一个列表的 <tt class="docutils literal"><span class="pre">cdr</span></tt> 设置成列表自身：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span><span class="p">))</span>
<span class="p">(</span><span class="nv">A</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span> <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="no">nil</span><span class="p">)</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>这样 <tt class="docutils literal"><span class="pre">x</span></tt> 就是一个环形列表，其结构如图 12.12 (左) 所示。</p>
<div class="figure">
<img alt="../_images/Figure-12.12.png" src="../_images/Figure-12.12.png" />
</div>
<p><strong>图 12.12 环状列表。</strong></p>
<p>如果 Lisp 试着打印我们刚刚构造的结构，将会显示 (a a a a a …… —— 无限个 <tt class="docutils literal"><span class="pre">a</span></tt>)。但如果设置全局变量 <tt class="docutils literal"><span class="pre">*print-circle*</span></tt> 为 <tt class="docutils literal"><span class="pre">t</span></tt> 的话，Lisp 就会采用一种方式打印出一个能代表环形结构的对象：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="vg">*print-circle*</span> <span class="no">t</span> <span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="nv">x</span>
<span class="o">#1=</span><span class="p">(</span><span class="nv">A</span> <span class="o">.</span> <span class="o">#1#</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>如果你需要，你也可以使用 <tt class="docutils literal"><span class="pre">#n=</span></tt> 和 <tt class="docutils literal"><span class="pre">#n#</span></tt> 这两个读取宏，来自己表示共享结构。</p>
<p><tt class="docutils literal"><span class="pre">cdr-cicular</span></tt> 列表十分有用，比如，可以用来表示缓冲区、池。下面这个函数，可以将一个普通的非空列表，转换成一个对应的 <tt class="docutils literal"><span class="pre">cdr-cicular</span></tt> 列表：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">circular</span> <span class="p">(</span><span class="nv">lst</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">last</span> <span class="nv">lst</span><span class="p">))</span> <span class="nv">lst</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>另外一种环状列表叫做 <tt class="docutils literal"><span class="pre">car-circular</span></tt> 列表。``car-circular`` 列表是一个树，并将其自身当作自己的子树的结构。因为环是通过一个 <tt class="docutils literal"><span class="pre">cons</span></tt> 的 <tt class="docutils literal"><span class="pre">car</span></tt> 形成的，所以叫做  <tt class="docutils literal"><span class="pre">car-circular``。这里构造了一个</span> <span class="pre">``car-circular</span></tt> ，它的第二个元素是它自身：</p>
<div class="highlight-cl"><pre>&gt; (let ((y (list 'a )))
(setf (car y) y)
     y)
#i=(#i#)</pre>
</div>
<p>图 12.12 (右) 展示了其结构。这个 <tt class="docutils literal"><span class="pre">car-circular</span></tt> 是一个正规列表。 <tt class="docutils literal"><span class="pre">cdr-circular</span></tt> 列表都不是正规列表，除开一些特殊情况 <tt class="docutils literal"><span class="pre">car-circular</span></tt> 列表是正规列表。</p>
<p>一个列表也可以既是 <tt class="docutils literal"><span class="pre">car-circular</span></tt> ，又是 <tt class="docutils literal"><span class="pre">cdr-circular</span></tt> 。 一个 <tt class="docutils literal"><span class="pre">cons</span></tt> 的 <tt class="docutils literal"><span class="pre">car</span></tt> 和 <tt class="docutils literal"><span class="pre">cdr</span></tt> 均是其自身：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">c</span> <span class="p">(</span><span class="nb">cons</span> <span class="mi">11</span><span class="p">))</span> <span class="p">)</span>
     <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">c</span>
            <span class="p">(</span><span class="nb">cdr</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">c</span><span class="p">)</span>
     <span class="nv">c</span><span class="p">)</span>
<span class="o">#1=</span><span class="p">(</span><span class="o">#1#</span> <span class="o">.</span> <span class="o">#1#</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>很难想像这样的一个列表有什么用。实际上，了解环形列表的主要目的就是为了避免因为偶然因素构造出了环形列表，因为，将一个环形列表传给一个函数，如果该函数遍历这个环形列表，它将进入死循环。</p>
<p>环形结构的这种问题在列表以外的其他对象中也存在。比如，一个数组可以将数组自身当作其元素：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="vg">*print-array*</span> <span class="no">t</span> <span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">a</span> <span class="p">(</span><span class="nb">make-array</span> <span class="mi">1</span><span class="p">))</span> <span class="p">)</span>
          <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nb">aref</span> <span class="nv">a</span> <span class="mi">0</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
          <span class="nv">a</span><span class="p">)</span>
<span class="o">#1=#(#1#</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>实际上，任何可以包含元素的对象都可能包含其自身作为元素。</p>
<p>用 <tt class="docutils literal"><span class="pre">defstruct</span></tt> 构造出环形结构是相当常见的。比如，一个结构 <tt class="docutils literal"><span class="pre">c</span></tt> 是一颗树的元素，它的 <tt class="docutils literal"><span class="pre">parent</span></tt> 字段所指向的结构 <tt class="docutils literal"><span class="pre">p</span></tt> 的 <tt class="docutils literal"><span class="pre">child</span></tt> 字段也恰好指向 <tt class="docutils literal"><span class="pre">c</span></tt> 。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">progn</span> <span class="p">(</span><span class="nb">defstruct</span> <span class="nb">elt</span>
          <span class="p">(</span><span class="nv">parent</span> <span class="no">nil</span> <span class="p">)</span> <span class="p">(</span><span class="nv">child</span> <span class="no">nil</span><span class="p">)</span> <span class="p">)</span>
     <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">c</span> <span class="p">(</span><span class="nv">make-elt</span><span class="p">)</span> <span class="p">)</span>
               <span class="p">(</span><span class="nv">p</span> <span class="p">(</span><span class="nv">make-elt</span><span class="p">))</span> <span class="p">)</span>
          <span class="p">(</span><span class="nb">setf</span> <span class="p">(</span><span class="nv">elt-parent</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">p</span>
                    <span class="p">(</span><span class="nv">elt-child</span> <span class="nv">p</span><span class="p">)</span> <span class="nv">c</span><span class="p">)</span>
          <span class="nv">c</span><span class="p">)</span> <span class="p">)</span>
<span class="o">#1=</span><span class="l-Other">#S</span><span class="p">(</span><span class="nv">ELT</span> <span class="nv">PARENT</span> <span class="l-Other">#S</span><span class="p">(</span><span class="nv">ELT</span> <span class="nv">PARENT</span> <span class="no">NIL</span> <span class="nv">CHILD</span> <span class="o">#1#</span><span class="p">)</span> <span class="nv">CHILD</span> <span class="no">NIL</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>要实现像这样一个结构的打印函数 (<tt class="docutils literal"><span class="pre">print-function</span></tt>)，我们需要将全局变量 <tt class="docutils literal"><span class="pre">*print-circle*</span></tt> 绑定为 <tt class="docutils literal"><span class="pre">t</span></tt> ，或者避免打印可能构成环的字段。</p>
</div>
<div class="section" id="constant-structure">
<h2>12.8 常量结构 (Constant Structure)<a class="headerlink" href="#constant-structure" title="永久链接至标题">¶</a></h2>
<p>因为常量实际上是程序代码的一部分，所以我们也不应该修改他们，或者是不经意地写了自重写的代码。一个通过 <tt class="docutils literal"><span class="pre">quote</span></tt> 引用的列表是一个常量，所以一定要小心，不要修改被引用的列表的任何 <a href="#id6"><span class="problematic" id="id7">``</span></a>cons``。比如，如果我们用下面的代码，来测试一个符号是不是算术运算符：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">arith-op</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
<span class="p">(</span><span class="nb">member</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">+</span> <span class="nb">-</span> <span class="nb">*</span> <span class="nb">/</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>如果被测试的符号是算术运算符，它的返回值将至少一个被引用列表的一部分。如果我们修改了其返回值，</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">nconc</span> <span class="p">(</span><span class="nv">arith-op</span> <span class="ss">&#39;*</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">as</span> <span class="nv">i</span> <span class="no">t</span> <span class="nv">were</span><span class="p">))</span>
<span class="p">(</span><span class="nb">*</span> <span class="nb">/</span> <span class="nv">AS</span> <span class="nv">IT</span> <span class="nv">WERE</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>那么我就会修改 <tt class="docutils literal"><span class="pre">arith-op</span></tt> 函数中的一个列表，从而改变了这个函数的功能：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">arith-op</span> <span class="ss">&#39;as</span> <span class="p">)</span>
<span class="p">(</span><span class="nv">AS</span> <span class="nv">IT</span> <span class="nv">WERE</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>写一个返回常量结构的函数，并不一定是错误的。但当你考虑使用一个破坏性的操作是否安全的时候，你必须考虑到这一点。</p>
<p>有几个其它方法来实现 <tt class="docutils literal"><span class="pre">arith-op``，使其不返回被引用列表的部分。一般地，我们可以通过将其中的所有引用(</span> <span class="pre">``quote</span></tt> ) 替换成 <tt class="docutils literal"><span class="pre">list</span></tt> 来确保安全，这使得它每次被调用都将返回一个新的列表：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">arith-op</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">member</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;+</span> <span class="ss">&#39;-</span> <span class="ss">&#39;*</span> <span class="ss">&#39;/</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>这里，使用 <tt class="docutils literal"><span class="pre">list</span></tt> 是一种低效的解决方案，我们应该使用 <tt class="docutils literal"><span class="pre">find</span></tt> 来替代 <a href="#id8"><span class="problematic" id="id9">``</span></a>member``：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">arith-op</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">find</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">+</span> <span class="nb">-</span> <span class="nb">*</span> <span class="nb">/</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>这一节讨论的问题似乎只与列表有关，但实际上，这个问题存在于任何复杂的对象中：数组，字符串，结构，实例等。你不应该逐字地去修改程序的代码段。</p>
<p>即使你想写自修改程序，通过修改常量来实现并不是个好办法。编译器将常量编译成了代码，破坏性的操作可能修改它们的参数，但这些都是没有任何保证的事情。如果你想写自修改程序，正确的方法是使用闭包 (见 6.5 节)。</p>
</div>
<div class="section" id="chapter-12-summary">
<h2>Chapter 12 总结 (Summary)<a class="headerlink" href="#chapter-12-summary" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li>两个列表可以共享一个尾端。多个列表可以以树的形式共享结构，而不是共享顶层列表结构。可通过拷贝方式来避免共用结构。</li>
<li>共享结构通常可以被忽略，但如果你要修改列表，则需要特别注意。因为修改一个含共享结构的列表可能修改所有共享该结构的列表。</li>
<li>队列可以被表示成一个 <tt class="docutils literal"><span class="pre">cons</span></tt> ，其的 <tt class="docutils literal"><span class="pre">car</span></tt> 指向队列的第一个元素， <tt class="docutils literal"><span class="pre">cdr</span></tt> 指向队列的最后一个元素。</li>
<li>为了提高效率，破坏性函数允许修改其输入参数。</li>
<li>在某些应用中，破坏性的实现更适用。</li>
<li>列表可以是 <tt class="docutils literal"><span class="pre">car-circular</span></tt> 或 <a href="#id10"><span class="problematic" id="id11">``</span></a>cdr-circular``。 Lisp 可以表示圆形结构和共享结构。</li>
<li>不应该去修改的程序代码段中的常量形式。</li>
</ol>
</div>
<div class="section" id="chapter-12-exercises">
<h2>Chapter 12 练习 (Exercises)<a class="headerlink" href="#chapter-12-exercises" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li>画三个不同的树，能够被打印成 <tt class="docutils literal"><span class="pre">((A)</span> <span class="pre">(A)</span> <span class="pre">(A))</span></tt> 。写一个表达式来生成它们。</li>
<li>假设 <tt class="docutils literal"><span class="pre">make-queue</span></tt> ， <tt class="docutils literal"><span class="pre">enqueue</span></tt> 和 <tt class="docutils literal"><span class="pre">dequeue</span></tt> 是按照图 12.7 中的定义，用箱子表式法画出下面每一步所得到的队列的结构图：</li>
</ol>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">q</span> <span class="p">(</span><span class="nv">make-queue</span><span class="p">))</span>
<span class="p">(</span><span class="no">NIL</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">enqueue</span> <span class="ss">&#39;a</span> <span class="nv">q</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">enqueue</span> <span class="ss">&#39;b</span> <span class="nv">q</span><span class="p">)</span>
<span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nv">dequeue</span> <span class="nv">q</span><span class="p">)</span>
<span class="nv">A</span>
</pre></div>
</td></tr></table></div>
<ol class="arabic simple" start="3">
<li>定义一个函数 <tt class="docutils literal"><span class="pre">copy-queue</span></tt> ，可以返回一个 queue 的拷贝。</li>
<li>定义一个函数，接受两个输入参数 <tt class="docutils literal"><span class="pre">object</span></tt> 和 <tt class="docutils literal"><span class="pre">queue</span></tt> ，能将 <tt class="docutils literal"><span class="pre">object</span></tt> 插入到 <tt class="docutils literal"><span class="pre">queue</span></tt> 的首端。</li>
<li>定义一个函数，接受两个输入参数 <tt class="docutils literal"><span class="pre">object</span></tt> 和 <tt class="docutils literal"><span class="pre">queue``，能具有破坏性地将</span> <span class="pre">``object</span></tt> 的第一个实例 ( <tt class="docutils literal"><span class="pre">eql</span></tt> 等价地) 移到 <tt class="docutils literal"><span class="pre">queue</span></tt> 的首端。</li>
<li>定义一个函数，接受两个输入参数 <tt class="docutils literal"><span class="pre">object</span></tt> 和 <tt class="docutils literal"><span class="pre">lst</span></tt> ( <tt class="docutils literal"><span class="pre">lst</span></tt> 可能是 <tt class="docutils literal"><span class="pre">cdr-circular</span></tt> 列表)，如果 <tt class="docutils literal"><span class="pre">object</span></tt> 是 <tt class="docutils literal"><span class="pre">lst</span></tt> 的成员时返回真。</li>
<li>定义一个函数，如果它的参数是一个 <tt class="docutils literal"><span class="pre">cdr-circular</span></tt> 则返回真。</li>
<li>定义一个函数，如果它的参数是一个 <tt class="docutils literal"><span class="pre">car-circular</span></tt> 则返回真。</li>
</ol>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td>比如，在 Common Lisp 中，修改一个被用作符号名的字符串被认为是一种错误，因为内部的定义并没声明它是从参数复制来的，所以必须假定修改传入内部的任何参数中的字符串来创建新的符号是错误的。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>函数名称中 n 的含义是 “non-consing”。一些具有破坏性的函数以 n 开头。</td></tr>
</tbody>
</table>
</div>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'acl-chinese';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                  </div></div>
              </article><div class="clearer"></div>
          </div><div class="span3">
                <div class="sphinxsidebar">
      <div id="sidenav" class="box sphinxsidebarwrapper">


<h4><a href="../index.html">內容目录</a></h4>
  <ul>
<li><a class="reference internal" href="#">第十二章：结构</a><ul>
<li><a class="reference internal" href="#shared-structure">12.1 共享结构 (Shared Structure)</a></li>
<li><a class="reference internal" href="#modification">12.2 修改 (Modification)</a></li>
<li><a class="reference internal" href="#example-queues">12.3 示例：队列 (Example: Queues)</a></li>
<li><a class="reference internal" href="#destructive-functions">12.4 破坏性函数 (Destructive Functions)</a></li>
<li><a class="reference internal" href="#example-binary-search-trees">12.5 示例：二叉搜索树 (Example: Binary Search Trees)</a></li>
<li><a class="reference internal" href="#example-doubly-linked-lists">12.6 示例：双向链表 (Example: Doubly-Linked Lists)</a></li>
<li><a class="reference internal" href="#circular-structure">12.7 环状结构 (Circular Structure)</a></li>
<li><a class="reference internal" href="#constant-structure">12.8 常量结构 (Constant Structure)</a></li>
<li><a class="reference internal" href="#chapter-12-summary">Chapter 12 总结 (Summary)</a></li>
<li><a class="reference internal" href="#chapter-12-exercises">Chapter 12 练习 (Exercises)</a></li>
</ul>
</li>
</ul>

  
    <h3>本页</h3>
    <ul class="this-page-menu">
      
      
        <li><a href="https://github.com/acl-translation/acl-chinese/blob/redirect-to-new-domain/zhCN/ch12-cn.rst">
          Show on GitHub</a></li>
        <li><a href="https://github.com/acl-translation/acl-chinese/edit/redirect-to-new-domain/zhCN/ch12-cn.rst">
          Edit on GitHub</a></li>
      
    </ul>
  
</div>
    </div>
              </div></div>
      </div>
<footer class="container-fluid">
        <hr />&copy; 版权所有 2012, Juanito Fatas Huang.最后更新日期是 Apr 22, 2013.使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.</footer>
 <!-- End original user content -->


<br>
<br>
<br>


<style type="text/css">
  .rtd-badge {
    position: fixed;
    display: block;
    bottom: 5px;
    height: 40px;
    text-indent: -9999em;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
    -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
  }
  #version_menu {
    position: fixed;
    display: none;
    bottom: 11px;
    right: 166px;
    list-style-type: none;
    margin: 0;
  }
  .footer_popout:hover #version_menu {
    display: block;
  }
  #version_menu li {
    display: block;
    float: right;
  }
  #version_menu li a {
    display: block;
    padding: 6px 10px 4px 10px;
    margin: 7px 7px 0 0;
    font-weight: bold;
    font-size: 14px;
    height: 20px;
    line-height: 17px;
    text-decoration: none;
    color: #fff;
    background: #8ca1af url(../images/gradient-light.png) bottom left repeat-x;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    box-shadow: 0 1px 1px #465158;
    -moz-box-shadow: 0 1px 1px #465158;
    -webkit-box-shadow: 0 1px 1px #465158;
    text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
  }
  #version_menu li a:hover {
    text-decoration: none;
    background-color: #697983;
    box-shadow: 0 1px 0px #465158;
    -moz-box-shadow: 0 1px 0px #465158;
    -webkit-box-shadow: 0 1px 0px #465158;
  }
  .rtd-badge.rtd {
    background: #3b4449 url(//media.readthedocs.org//images/badge-rtd.png) scroll 0px -46px no-repeat;
    border: 1px solid #282E32;
    width: 41px;
    right: 5px;
  }
  .footer_popout:hover .rtd-badge.rtd {
    background-position: top left;
    width: 160px;
  }
  .rtd-badge.revsys { background: #465158 url(//media.readthedocs.org//images/badge-revsys.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 290px;
    right: 173px;
  }
  .rtd-badge.revsys-inline-sponsored {
    position: inherit;
    margin-left: auto;
    margin-right: 175px;
    margin-bottom: 5px;
    background: #465158 url(//media.readthedocs.org//images/badge-revsys.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 290px;
    right: 173px;
  }
  .rtd-badge.revsys-inline {
    position: inherit;
    margin-left: auto;
    margin-right: 175px;
    margin-bottom: 5px;
    background: #465158 url(//media.readthedocs.org//images/badge-revsys-sm.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 205px;
    right: 173px;
  }

</style>
<div class="rtd_doc_footer">
  <div class="footer_popout">
    <a href="//readthedocs.org/projects/ansi-common-lisp/?fromdocs=ansi-common-lisp" class="rtd-badge rtd"> Brought to you by Read the Docs</a>
    <ul id="version_menu">
      
        <li><a href="/en/latest/">latest</a></li>
      
    </ul>
  </div>
</div>
<!-- RTD Analytics Code -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


<!-- User Analytics Code -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-26995626-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</body>
</html>