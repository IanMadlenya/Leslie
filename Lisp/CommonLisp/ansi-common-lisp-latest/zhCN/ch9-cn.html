<!DOCTYPE HTML>

  <html xmlns="http://www.w3.org/1999/xhtml" lang="zh">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
<title>第九章：数字 &mdash; ANSI Common Lisp 中文版</title>
    
<!-- RTD <head> -->
<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript" src="//media.readthedocs.org/javascript/underscore.js"></script>
<script type="text/javascript" src="//media.readthedocs.org/javascript/doctools.js"></script>

<script type="text/javascript">
  // This is included here for Javascript that doesn't have access to the templates.
  var doc_version = "latest";
  var doc_slug = "ansi-common-lisp";
</script>

<script type="text/javascript" src="//media.readthedocs.org/javascript/rtd.js"></script>
<!-- end RTD <head> -->

    <link rel="stylesheet" href="../_static/han.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/rosefinch.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/main.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:       '../',
        VERSION:        '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX:    '.html',
        HAS_SOURCE:     true
      };
    </script>
    <script type="text/javascript" src="../_static/han.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src=../_static/jquery.dimensions.js"></script>
  <script type="text/javascript" src="../_static/main.js"></script><link rel="top" title="ANSI Common Lisp 中文版" href="../index.html" /></head>

  <body><div class="navbar navbar-static-top navbar-inverse">
        <div id="top-bar" class="navbar-inner">

          <h1 id="logo">ANSI Common Lisp 中文版<a href="../index.html" class="brand">ANSI Common Lisp 中文版</a></h1>
          <ul class="nav"></ul><a href="https://github.com/acl-translation/acl-chinese"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub"></a>
        </div>
      </div><div class="content container-fluid">
        <div class="row-fluid"><div class="document span9"><article >
                <div class="documentwrapper"><div class="body"><div class="section" id="id1">
<h1>第九章：数字<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>处理数字是 Common Lisp 的强项之一。Common Lisp 有着丰富的数值类型 (numeric types)，而 Common Lisp 操作数字的特性与其他语言比起来更受人喜爱。</p>
<div class="section" id="types">
<h2>9.1 类型 (Types)<a class="headerlink" href="#types" title="永久链接至标题">¶</a></h2>
<p>Common Lisp 提供了四种不同类型的数字：整数 (integers)、浮点数 (floating-point numbers)、比值 (ratios) 与复数 (complex number)。本章所描述的函数适用於所有类型的数字。有几个不能用在复数的会特别注明。</p>
<p>一个整数是写成一串数字： <tt class="docutils literal"><span class="pre">2001</span></tt> 。一个浮点数是可以写成一串包含小数点的数字， <tt class="docutils literal"><span class="pre">253.72</span></tt> ，或是用科学表示法， <tt class="docutils literal"><span class="pre">2.5372e2</span></tt> 。一个比值是写成一个由整数组成的分数： <tt class="docutils literal"><span class="pre">2/3</span></tt> 。而复数 <tt class="docutils literal"><span class="pre">a+bi</span></tt> 是写成 <tt class="docutils literal"><span class="pre">#c(a</span> <span class="pre">b)</span></tt> ，其中 <tt class="docutils literal"><span class="pre">a</span></tt> 与 <tt class="docutils literal"><span class="pre">b</span></tt> 是任两个同样类型的实数 (real number)。</p>
<p>判断式 <tt class="docutils literal"><span class="pre">integerp</span></tt> , <tt class="docutils literal"><span class="pre">floatp</span></tt> 以及 <tt class="docutils literal"><span class="pre">complexp</span></tt> 对於相对应的数字类型返回真。图 9.1 演示了数值类型的层级 (hierarchy of numeric types)。</p>
<div class="figure">
<img alt="../_images/Figure-9.1.png" src="../_images/Figure-9.1.png" />
</div>
<p><strong>图 9.1: 数值类型</strong></p>
<p>以下是某些通用的经验法则，来决定一个计算过程会返回何种数字：</p>
<ol class="arabic simple">
<li>如果一个数值函数 (numeric function)接受一个或多个浮点数作为参数，则返回值会是一个浮点数 (或是一个由浮点数组成的复数)。所以 <tt class="docutils literal"><span class="pre">(+</span> <span class="pre">1.0</span> <span class="pre">2)</span></tt> 求值成 <tt class="docutils literal"><span class="pre">3.0</span></tt> ，而 <tt class="docutils literal"><span class="pre">(+</span> <span class="pre">#c(0</span> <span class="pre">1.0)</span> <span class="pre">2)</span></tt> 求值成 <tt class="docutils literal"><span class="pre">#c(2.0</span> <span class="pre">1.0)</span></tt> 。</li>
<li>可约分的比值会被转换成整数。所以 <tt class="docutils literal"><span class="pre">(/</span> <span class="pre">10</span> <span class="pre">2)</span></tt> 会返回 <tt class="docutils literal"><span class="pre">5</span></tt> 。</li>
<li>若计算过程中复数的虚部会变成 <tt class="docutils literal"><span class="pre">0</span></tt> ，则复数会被转成实数 。所以 <tt class="docutils literal"><span class="pre">(+</span> <span class="pre">#c(1</span> <span class="pre">-1)</span> <span class="pre">#c(2</span> <span class="pre">1))</span></tt> 求值成 <tt class="docutils literal"><span class="pre">3</span></tt> 。</li>
</ol>
<p>第二、第三个规则可以在参数被读取时直接应用，所以：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nv">ratiop</span> <span class="m">2/2</span><span class="p">)</span> <span class="p">(</span><span class="nb">complexp</span> <span class="m">#c</span><span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">)))</span>
<span class="p">(</span><span class="no">NIL</span> <span class="no">NIL</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="conversion-and-extraction">
<h2>9.2 转换及取出 (Conversion and Extraction)<a class="headerlink" href="#conversion-and-extraction" title="永久链接至标题">¶</a></h2>
<p>Lisp 提供函数来做四种不同类型的数字的转换 (converting)及取出位数 (extracting component)。函数 <tt class="docutils literal"><span class="pre">float</span></tt> 将任何实数转换成一个浮点数:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">float</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="m">2/3</span> <span class="mf">.5</span><span class="p">))</span>
<span class="p">(</span><span class="mf">1.0</span> <span class="mf">0.6666667</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>将数字转成整数未必需要转换，因为它可能牵涉到某些资讯的丧失。函数 <tt class="docutils literal"><span class="pre">truncate</span></tt> 返回任何实数的整数部分:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">truncate</span> <span class="mf">1.3</span><span class="p">)</span>
<span class="mi">1</span>
<span class="mf">0.29999995</span>
</pre></div>
</td></tr></table></div>
<p>第二个返回值是传入的参数减去第一个返回值。(会有 0.00000005 的差是因为浮点数的计算本来就不精确。)</p>
<p>函数 <tt class="docutils literal"><span class="pre">floor</span></tt> 与 <tt class="docutils literal"><span class="pre">ceiling</span></tt> 以及 <tt class="docutils literal"><span class="pre">round</span></tt> 也从它们的参数中导出整数。使用 <tt class="docutils literal"><span class="pre">floor</span></tt> 返回小於等於其参数的最大整数，而 <tt class="docutils literal"><span class="pre">ceiling</span></tt> 返回大於或等於其参数的最小整数，我们可以将 <tt class="docutils literal"><span class="pre">mirror?</span></tt> (46 页，译注: 3.11 节)改成可以找出所有回文 (palindromes)的版本:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">palindrome?</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">mid</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">length</span> <span class="nv">x</span><span class="p">)</span> <span class="mi">2</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">equal</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">x</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">floor</span> <span class="nv">mid</span><span class="p">))</span>
           <span class="p">(</span><span class="nb">reverse</span> <span class="p">(</span><span class="nb">subseq</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">ceiling</span> <span class="nv">mid</span><span class="p">))))))</span>
</pre></div>
</td></tr></table></div>
<p>和 <tt class="docutils literal"><span class="pre">truncate</span></tt> 一样， <tt class="docutils literal"><span class="pre">floor</span></tt> 与 <tt class="docutils literal"><span class="pre">ceiling</span></tt> 也返返回入参数与第一个返回值的差作为第二个值。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">floor</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="mi">1</span>
<span class="mf">0.5</span>
</pre></div>
</td></tr></table></div>
<p>实际上，我们可以把 <tt class="docutils literal"><span class="pre">truncate</span></tt> 想成是这样定义的:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">our-truncate</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">floor</span> <span class="nv">n</span><span class="p">)</span>
        <span class="p">(</span><span class="nb">ceiling</span> <span class="nv">n</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>函数 <tt class="docutils literal"><span class="pre">round</span></tt> 返回最接近其参数的整数。当参数与两个整数的距离相等时， Common Lisp 和很多程序语言一样，不会往上取 (round up)整数。而是取最近的偶数:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">round</span> <span class="o">&#39;</span><span class="p">(</span><span class="mf">-2.5</span> <span class="mf">-1.5</span> <span class="mf">1.5</span> <span class="mf">2.5</span><span class="p">))</span>
<span class="p">(</span><span class="mi">-2</span> <span class="mi">-2</span> <span class="mi">2</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>在某些数值应用中这是好事，因为舍入误差 (rounding error)倾向於互相抵消。然而如果用户期望你的程序将某些值取整数时，你必须自己提供这个功能。 <a class="footnote-reference" href="#id6" id="id2">[1]</a> 与其他的函数一样， <tt class="docutils literal"><span class="pre">round</span></tt> 返返回入参数与第一个返回值的差作为第二个值。</p>
<p>函数 <tt class="docutils literal"><span class="pre">mod</span></tt> 仅返回 <tt class="docutils literal"><span class="pre">floor</span></tt> 会返回的第二个值；而 <tt class="docutils literal"><span class="pre">rem</span></tt> 返回 <tt class="docutils literal"><span class="pre">truncate</span></tt> 会返回的第二个值。我们在 94 页 (译注: 5.7 节)使用了 <tt class="docutils literal"><span class="pre">mod</span></tt> 来决定一个数是否可被另一个整除，以及 127 页(译注: 7.4 节)用来找出环状缓冲区 (ring buffer)中，元素实际的位置。</p>
<p>关於实数，函数 <tt class="docutils literal"><span class="pre">signum</span></tt> 返回 <tt class="docutils literal"><span class="pre">1</span></tt> , <tt class="docutils literal"><span class="pre">0</span></tt> 或 <tt class="docutils literal"><span class="pre">-1</span></tt> ，取决於它的参数是正、零或负数。函数 <tt class="docutils literal"><span class="pre">abs</span></tt> 返回其参数的绝对值。因此 <tt class="docutils literal"><span class="pre">(*</span> <span class="pre">(abs</span> <span class="pre">x)</span> <span class="pre">(signum</span> <span class="pre">x))</span></tt> 等於 <tt class="docutils literal"><span class="pre">x</span></tt> 。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">mapcar</span> <span class="nf">#&#39;</span><span class="nb">signum</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">-2</span> <span class="mf">-0.0</span> <span class="mf">0.0</span> <span class="mi">0</span> <span class="mf">.5</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="mi">-1</span> <span class="mf">-0.0</span> <span class="mf">0.0</span> <span class="mi">0</span> <span class="mf">1.0</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>在某些应用里， <tt class="docutils literal"><span class="pre">-0.0</span></tt> 可能自成一格 (in its own right)，如上所示。其实功能上它几乎没有差异，因为数值 <tt class="docutils literal"><span class="pre">-0.0</span></tt> 与 <tt class="docutils literal"><span class="pre">0.0</span></tt> 有一样的行为。</p>
<p>比值与复数概念上是两部分结构。(译注: 像 <strong>Cons</strong> 这样的两部分结构) 函数 <tt class="docutils literal"><span class="pre">numerator</span></tt> 与 <tt class="docutils literal"><span class="pre">denominator</span></tt> 返回一个比值或整数所对应的部份。 (如果数字是整数，前者返回该数字，而後者返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。)函数 <tt class="docutils literal"><span class="pre">realpart</span></tt> 与 <tt class="docutils literal"><span class="pre">imgpart</span></tt> 返回任何数字的实数与虚数部分。 (如果数字不是复数，前者返回该数字，後者返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。)</p>
<p>函数 <tt class="docutils literal"><span class="pre">random</span></tt> 接受一个整数或浮点数。一个这样形式的表达式 <tt class="docutils literal"><span class="pre">(random</span> <span class="pre">n)</span></tt> 返回一个大於或小於等於 <tt class="docutils literal"><span class="pre">n</span></tt> 的数字，并有着与 <tt class="docutils literal"><span class="pre">n</span></tt> 相同的类型。</p>
</div>
<div class="section" id="comparison">
<h2>9.3 比较 (Comparison)<a class="headerlink" href="#comparison" title="永久链接至标题">¶</a></h2>
<p>判断式 <tt class="docutils literal"><span class="pre">=</span></tt> 当其参数数值上相等时 –– 即两者的差为零时，返回真。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">=</span> <span class="mi">1</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eql</span> <span class="mi">1</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p><tt class="docutils literal"><span class="pre">=</span></tt> 比起 <tt class="docutils literal"><span class="pre">eql</span></tt> 来得宽松，但它的参数需要是同样类型。</p>
<p>用来比较数字的判断式为 <tt class="docutils literal"><span class="pre">&lt;</span></tt> (小於), <tt class="docutils literal"><span class="pre">&lt;=</span></tt> (小於等於), <tt class="docutils literal"><span class="pre">=</span></tt> (等於), <tt class="docutils literal"><span class="pre">&gt;=</span></tt> (大於等於), <tt class="docutils literal"><span class="pre">&gt;</span></tt> (大於) 以及 <tt class="docutils literal"><span class="pre">/=</span></tt> (不同)。以上所有皆接受一个或多个参数。只有一个参数时，它们全返回真。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>等同於一个二元操作符的结合 (conjunction)，应用至每一对参数上:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">w</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>由於 <tt class="docutils literal"><span class="pre">/=</span></tt> 若它的两个参数不等於时返回真，表达式</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">/=</span> <span class="nv">w</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>等同於</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">and</span> <span class="p">(</span><span class="nb">/=</span> <span class="nv">w</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">/=</span> <span class="nv">w</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">/=</span> <span class="nv">w</span> <span class="nv">z</span><span class="p">)</span>
     <span class="p">(</span><span class="nb">/=</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">/=</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">/=</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>特殊的判断式 <tt class="docutils literal"><span class="pre">zerop</span></tt> , <tt class="docutils literal"><span class="pre">plusp</span></tt> 与 <tt class="docutils literal"><span class="pre">minusp</span></tt> 接受一个参数，分别於参数 <tt class="docutils literal"><span class="pre">=</span></tt> , <tt class="docutils literal"><span class="pre">&gt;</span></tt> , <tt class="docutils literal"><span class="pre">&lt;</span></tt> 零时，返回真。虽然 <tt class="docutils literal"><span class="pre">-0.0</span></tt> (如果实现有使用它) 前面有个负号，但它 <tt class="docutils literal"><span class="pre">=</span></tt> 零，</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">minusp</span> <span class="mf">-0.0</span><span class="p">)</span> <span class="p">(</span><span class="nb">zerop</span> <span class="mf">-0.0</span><span class="p">))</span>
<span class="p">(</span><span class="no">NIL</span> <span class="no">T</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>因此使用 <tt class="docutils literal"><span class="pre">zerop</span></tt> 而不是 <tt class="docutils literal"><span class="pre">minusp</span></tt> 。</p>
<p>判断式 <tt class="docutils literal"><span class="pre">oddp</span></tt> 与 <tt class="docutils literal"><span class="pre">evenp</span></tt> 只能用在整数。前者只对奇数返回真，後者只对偶数返回真。</p>
<p>本节定义的判断式中，只有 <tt class="docutils literal"><span class="pre">=</span></tt> , <tt class="docutils literal"><span class="pre">/=</span></tt> 与 <tt class="docutils literal"><span class="pre">zerop</span></tt> 可以用在复数。</p>
<p>函数 <tt class="docutils literal"><span class="pre">max</span></tt> 与 <tt class="docutils literal"><span class="pre">min</span></tt> 分别返回其参数的最大值与最小值。两者至少需要给一个参数:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">max</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="nb">min</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="p">(</span><span class="mi">5</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>如果参数有包含浮点数的话，结果的类型取决於各家实现。</p>
</div>
<div class="section" id="arithematic">
<h2>9.4 算术 (Arithematic)<a class="headerlink" href="#arithematic" title="永久链接至标题">¶</a></h2>
<p>用来做加减的函数是 <tt class="docutils literal"><span class="pre">+</span></tt> 与 <tt class="docutils literal"><span class="pre">-</span></tt> 。两者皆可接受任何数量的参数，包括没有参数，在没有参数的情况下返回 <tt class="docutils literal"><span class="pre">0</span></tt> 。(译注: <tt class="docutils literal"><span class="pre">-</span></tt> 在没有参数的情况下会报错，至少要一个参数) 一个这样形式的表达式 <tt class="docutils literal"><span class="pre">(-</span> <span class="pre">n)</span></tt> 返回 <tt class="docutils literal"><span class="pre">-n</span></tt> 。一个这样形式的表达式</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>等同於</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">z</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>有两个函数 <tt class="docutils literal"><span class="pre">1+</span></tt> 与 <tt class="docutils literal"><span class="pre">1-</span></tt> ，分别将参数加上 <tt class="docutils literal"><span class="pre">1</span></tt> 与减去 <tt class="docutils literal"><span class="pre">1</span></tt> 并返回。 <tt class="docutils literal"><span class="pre">1-</span></tt> 有一点误导，因为 <tt class="docutils literal"><span class="pre">(1-</span> <span class="pre">x)</span></tt> 返回 <tt class="docutils literal"><span class="pre">x-1</span></tt> 而不是 <tt class="docutils literal"><span class="pre">1-x</span></tt> 。</p>
<p>宏 <tt class="docutils literal"><span class="pre">incf</span></tt> 及     <tt class="docutils literal"><span class="pre">decf</span></tt> 分别增加与减少参数。一个这样形式的表达式 <tt class="docutils literal"><span class="pre">(incf</span> <span class="pre">x</span> <span class="pre">n)</span></tt> 类似於 <tt class="docutils literal"><span class="pre">(setf</span> <span class="pre">x</span> <span class="pre">(+</span> <span class="pre">x</span> <span class="pre">n))</span></tt> 的效果，而 <tt class="docutils literal"><span class="pre">(decf</span> <span class="pre">x</span> <span class="pre">n)</span></tt> 类似於 <tt class="docutils literal"><span class="pre">(setf</span> <span class="pre">x</span> <span class="pre">(-</span> <span class="pre">x</span> <span class="pre">n))</span></tt> 的效果。这两个情况里，第二个参数是选择性的并缺省为 <tt class="docutils literal"><span class="pre">1</span></tt> 。</p>
<p>用来做乘法的函数是 <tt class="docutils literal"><span class="pre">*</span></tt> 。接受任何数量的参数。没有给参数时返回 <tt class="docutils literal"><span class="pre">1</span></tt> 。否则返回参数的乘积。</p>
<p>除法函数 <tt class="docutils literal"><span class="pre">/</span></tt> 至少预期一个参数。一个这样形式的调用 <tt class="docutils literal"><span class="pre">(/</span> <span class="pre">n)</span></tt> 等同於 <tt class="docutils literal"><span class="pre">(/</span> <span class="pre">1</span> <span class="pre">n)</span></tt> ，</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">3</span><span class="p">)</span>
<span class="m">1/3</span>
</pre></div>
</td></tr></table></div>
<p>而一个这样形式的调用</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>等同於</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">z</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>注意 <tt class="docutils literal"><span class="pre">-</span></tt> 与 <tt class="docutils literal"><span class="pre">/</span></tt> 两者在这方面的相似性。</p>
<p>当给定两个整数时， <tt class="docutils literal"><span class="pre">/</span></tt> 若第一个不是第二个的倍数时，会返回一个比值:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">/</span> <span class="mi">365</span> <span class="mi">12</span><span class="p">)</span>
<span class="m">365/12</span>
</pre></div>
</td></tr></table></div>
<p>举例来说，如果你试着找出平均每一个月有多长，你可能会有顶层在逗你玩的想法。在这个情况下，你需要的是对比值调用 <tt class="docutils literal"><span class="pre">float</span></tt> ，而不是对两个整数做 <tt class="docutils literal"><span class="pre">/</span></tt> 。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">float</span> <span class="m">365/12</span><span class="p">)</span>
<span class="mf">30.416666</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="exponentiation">
<h2>9.5 指数 (Exponentiation)<a class="headerlink" href="#exponentiation" title="永久链接至标题">¶</a></h2>
<p>要找到 <span class="math">\(x^n\)</span> 我们调用 <tt class="docutils literal"><span class="pre">(expt</span> <span class="pre">x</span> <span class="pre">n)</span></tt> ，</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">expt</span> <span class="mi">2</span> <span class="mi">5</span><span class="p">)</span>
<span class="mi">32</span>
</pre></div>
</td></tr></table></div>
<p>而要找到 <span class="math">\(log_nx\)</span> 我们调用 <tt class="docutils literal"><span class="pre">(log</span> <span class="pre">x</span> <span class="pre">n)</span></tt> :</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">log</span> <span class="mi">32</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">5.0</span>
</pre></div>
</td></tr></table></div>
<p>通常返回一个浮点数。</p>
<p>要找到 <span class="math">\(e^x\)</span> 有一个特别的函数 <tt class="docutils literal"><span class="pre">exp</span></tt> ，</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">exp</span> <span class="mi">2</span><span class="p">)</span>
<span class="mf">7.389056</span>
</pre></div>
</td></tr></table></div>
<p>而要找到一个自然对数，你可以使用 <tt class="docutils literal"><span class="pre">log</span></tt> 就好，因为第二个参数缺省为 <tt class="docutils literal"><span class="pre">e</span></tt> :</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">log</span> <span class="mf">7.389056</span><span class="p">)</span>
<span class="mf">2.0</span>
</pre></div>
</td></tr></table></div>
<p>要找到立方根，你可以调用 <tt class="docutils literal"><span class="pre">expt</span></tt> 用一个比值作为第二个参数，</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">expt</span> <span class="mi">27</span> <span class="m">1/3</span><span class="p">)</span>
<span class="mf">3.0</span>
</pre></div>
</td></tr></table></div>
<p>但要找到平方根，函数 <tt class="docutils literal"><span class="pre">sqrt</span></tt> 会比较快:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="mi">4</span><span class="p">)</span>
<span class="mf">2.0</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="trigometric-functions">
<h2>9.6 三角函数 (Trigometric Functions)<a class="headerlink" href="#trigometric-functions" title="永久链接至标题">¶</a></h2>
<p>常量 <tt class="docutils literal"><span class="pre">pi</span></tt> 是 <tt class="docutils literal"><span class="pre">π</span></tt> 的浮点表示法。它的精度 (precision)取决於各家实现。函数 <tt class="docutils literal"><span class="pre">sin</span></tt> , <tt class="docutils literal"><span class="pre">cos</span></tt> 及 <tt class="docutils literal"><span class="pre">tan</span></tt> 分别可以找到正弦、馀弦及正交函数，其中角度以径度 (radian)表示:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">pi</span> <span class="mi">4</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">sin</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cos</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">tan</span> <span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="mf">0.7071067811865475d0</span> <span class="mf">0.7071067811865476d0</span> <span class="mf">1.0d0</span><span class="p">)</span>
<span class="c1">;;; 译注: CCL 1.8  SBCL 1.0.55 下的结果是</span>
<span class="c1">;;; (0.7071067811865475D0 0.7071067811865476D0 0.9999999999999999D0)</span>
</pre></div>
</td></tr></table></div>
<p>这些函数全部接受负数及复数参数。</p>
<p>函数 <tt class="docutils literal"><span class="pre">asin</span></tt> , <tt class="docutils literal"><span class="pre">acos</span></tt> 及 <tt class="docutils literal"><span class="pre">atan</span></tt> 实现了正弦、馀弦及正交的反函数 (inverse)。参数介於 <tt class="docutils literal"><span class="pre">-1</span></tt> 与 <tt class="docutils literal"><span class="pre">1</span></tt> 之间（包含）时， <tt class="docutils literal"><span class="pre">asin</span></tt> 与 <tt class="docutils literal"><span class="pre">acos</span></tt> 返回实数。</p>
<p>双曲 (hyperbolic)正弦、馀弦及正交分别由 <tt class="docutils literal"><span class="pre">sinh</span></tt> , <tt class="docutils literal"><span class="pre">cosh</span></tt> 及 <tt class="docutils literal"><span class="pre">tanh</span></tt> 实现。它们的反函数同样为 <tt class="docutils literal"><span class="pre">asinh</span></tt> , <tt class="docutils literal"><span class="pre">acosh</span></tt> 以及 <tt class="docutils literal"><span class="pre">atanh</span></tt> 。</p>
</div>
<div class="section" id="id3">
<h2>9.6 三角函数 (Trigometric Functions)<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>常量 <tt class="docutils literal"><span class="pre">pi</span></tt> 是 <tt class="docutils literal"><span class="pre">π</span></tt> 的浮点表示法。它的精度 (precision)取决於各家实现。函数 <tt class="docutils literal"><span class="pre">sin</span></tt> , <tt class="docutils literal"><span class="pre">cos</span></tt> 及 <tt class="docutils literal"><span class="pre">tan</span></tt> 分别可以找到正弦、馀弦及正交函数，其中角度以径度 (radian)表示:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">pi</span> <span class="mi">4</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">sin</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cos</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">tan</span> <span class="nv">x</span><span class="p">)))</span>
<span class="p">(</span><span class="mf">0.7071067811865475d0</span> <span class="mf">0.7071067811865476d0</span> <span class="mf">1.0d0</span><span class="p">)</span>
<span class="c1">;;; 译注: CCL 1.8  SBCL 1.0.55 下的结果是</span>
<span class="c1">;;; (0.7071067811865475D0 0.7071067811865476D0 0.9999999999999999D0)</span>
</pre></div>
</td></tr></table></div>
<p>这些函数全部接受负数及复数参数。</p>
<p>函数 <tt class="docutils literal"><span class="pre">asin</span></tt> , <tt class="docutils literal"><span class="pre">acos</span></tt> 及 <tt class="docutils literal"><span class="pre">atan</span></tt> 实现了正弦、馀弦及正交的反函数 (inverse)。参数介於 <tt class="docutils literal"><span class="pre">-1</span></tt> 与 <tt class="docutils literal"><span class="pre">1</span></tt> 之间（包含）时， <tt class="docutils literal"><span class="pre">asin</span></tt> 与 <tt class="docutils literal"><span class="pre">acos</span></tt> 返回实数。</p>
<p>双曲的 (hyperbolic)正弦、馀弦及正交分别由 <tt class="docutils literal"><span class="pre">sinh</span></tt> , <tt class="docutils literal"><span class="pre">cosh</span></tt> 及 <tt class="docutils literal"><span class="pre">tanh</span></tt> 实现。它们的反函数同样为 <tt class="docutils literal"><span class="pre">asinh</span></tt> , <tt class="docutils literal"><span class="pre">acosh</span></tt> 以及 <tt class="docutils literal"><span class="pre">atanh</span></tt> 。</p>
</div>
<div class="section" id="representations">
<h2>9.7 表示法 (Representations)<a class="headerlink" href="#representations" title="永久链接至标题">¶</a></h2>
<p>Common Lisp 对於整数的大小没有限制。可以塞进一个字 (word)内存的小整数称为定数 (fixnums)。当一个计算过程整数无法塞入一个字 (word)时，Lisp 切换至使用多个内存字的表示法（一个大数 「bignum」)。所以一个整数的大小限制取决於实体内存，而不是语言。</p>
<p>常量 <tt class="docutils literal"><span class="pre">most-positive-fixnum</span></tt> 与 <tt class="docutils literal"><span class="pre">most-negative-fixnum</span></tt> 表示了一个实现不使用大数 (bignum)可表示的最大数字幅度 (magnitude)。在很多实现里，它们为：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">most-positive-fixnum</span> <span class="nv">most-negative-fixnum</span><span class="p">)</span>
<span class="mi">536870911</span>
<span class="mi">-536870912</span>
<span class="c1">;;; 译注: CCL 1.8 的结果为</span>
<span class="mi">1152921504606846975</span>
<span class="mi">-1152921504606846976</span>
<span class="c1">;;; SBCL 1.0.55 的结果为</span>
<span class="mi">4611686018427387903</span>
<span class="mi">-4611686018427387904</span>
</pre></div>
</td></tr></table></div>
<p>判断式 <tt class="docutils literal"><span class="pre">typep</span></tt> 接受一个参数及一个类型名称，并返回指定类型的参数。所以，</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">typep</span> <span class="mi">1</span> <span class="ss">&#39;fixnum</span><span class="p">)</span>
<span class="no">T</span>
<span class="nb">&gt;</span> <span class="p">(</span><span class="k">type</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">most-positive-fixnum</span><span class="p">)</span> <span class="ss">&#39;bignum</span><span class="p">)</span>
<span class="no">T</span>
</pre></div>
</td></tr></table></div>
<p>浮点数字的数值限制是取决於各家实现的。 Common Lisp 提供了最多四种类型的浮点数：短浮点 <tt class="docutils literal"><span class="pre">short-float</span></tt> 、 单浮点 <tt class="docutils literal"><span class="pre">single-float</span></tt> 、双浮点 <tt class="docutils literal"><span class="pre">double-float</span></tt> 以及长浮点 <tt class="docutils literal"><span class="pre">long-float</span></tt> 。Common Lisp 的实现不需要用不同的格式来表示这四种类型（很少实现这麽做）。</p>
<p>一般来说，短浮点应可塞入一个字 (word)，单浮点与双浮点提供普遍的单与双精度浮点数的概念，而长浮点，如果想要的话可以是很大的数。但一个实现可以使这四个类型没有区别，也是完全没有问题的。</p>
<p>你可以指定你想要何种格式的浮点数，当一个数字是用科学表示法时，可以通过将 <tt class="docutils literal"><span class="pre">e</span></tt> 替换为 <tt class="docutils literal"><span class="pre">s</span></tt> <tt class="docutils literal"><span class="pre">f</span></tt> <tt class="docutils literal"><span class="pre">d</span></tt> <tt class="docutils literal"><span class="pre">l</span></tt> 来得到不同的浮点数。(你也可以使用大写，这对长浮点来说是个好主意，因为 <tt class="docutils literal"><span class="pre">l</span></tt> 看起来太像 <tt class="docutils literal"><span class="pre">1</span></tt> 了。)所以要表示最大的 <tt class="docutils literal"><span class="pre">1.0</span></tt> 你可以写 <tt class="docutils literal"><span class="pre">1L0</span></tt> 。</p>
<p>(译注: <tt class="docutils literal"><span class="pre">s</span></tt> 为短浮点、 <tt class="docutils literal"><span class="pre">f</span></tt> 为单浮点、 <tt class="docutils literal"><span class="pre">d</span></tt> 为双浮点、 <tt class="docutils literal"><span class="pre">l</span></tt> 为长浮点。)</p>
<p>在给定的实现里，用十六个全局常量标明了每个格式的限制。它们的名字是这种形式: <tt class="docutils literal"><span class="pre">m-s-f</span></tt> ，其中 <tt class="docutils literal"><span class="pre">m</span></tt> 是 <tt class="docutils literal"><span class="pre">most</span></tt> 或 <tt class="docutils literal"><span class="pre">least</span></tt> ， <tt class="docutils literal"><span class="pre">s</span></tt> 是 <tt class="docutils literal"><span class="pre">positive</span></tt> 或 <tt class="docutils literal"><span class="pre">negative</span></tt> ，而 <tt class="docutils literal"><span class="pre">f</span></tt> 是四种浮点数之一。 <a class="reference external" href="http://ansi-common-lisp.readthedocs.org/en/latest/zhCN/notes-cn.html#notes-150">λ</a></p>
<p>浮点数乾涸与溢出被 Common Lisp 视为错误 :</p>
<p>(译注: 这里调皮了一下，使用了乾涸。我们说一个 stack 满了要 push 时叫做溢出 (overflow)，stack 为空又要 pop 时叫做下溢「underflow」，但是下溢听起来以为是裤子湿了…)</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">most-positive-long-float</span> <span class="mi">10</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="kt">floating-point-overflow</span>
</pre></div>
</td></tr></table></div>
</div>
<div class="section" id="example-ray-tracing">
<h2>9.8 范例：追踪光线 (Example: Ray-Tracing)<a class="headerlink" href="#example-ray-tracing" title="永久链接至标题">¶</a></h2>
<p>作为一个数值应用的范例，本节示范了如何撰写一个光线追踪器 (ray-tracer)。光线追踪是一个高级的 (deluxe)渲染算法: 它产生出逼真的图像，但需要花点时间。</p>
<p>要产生一个 3D 的图像，我们至少需要定义四件事: 一个观测点 (eye)、一个或多个光源、一个由一个或多个平面所组成的模拟世界 (simulated world)，以及一个作为通往这个世界的窗户的平面 (图像平面「image plane」)。我们产生出的是模拟世界投影在图像平面区域的图像。</p>
<p>让光线追踪如此不寻常的是，我们如何找到这个投影: 我们一个一个像素地沿着图像平面走，追踪回到模拟世界里的光线。这个方法带来三个主要的优势: 它让我们容易得到现实世界的光学效应 (optical effect)，如透明度 (transparency)、反射光 (reflected light)以及产生阴影 (cast shadows)；它让我们可以直接用任何我们想要的几何的物体，来定义出模拟的世界，而不需要用多变形 (polygons)来建构它们；以及它很简单实现。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">sq</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="nv">x</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">mag</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">sqrt</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">z</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">unit-vector</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">d</span> <span class="p">(</span><span class="nv">mag</span> <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">y</span> <span class="nv">d</span><span class="p">)</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">z</span> <span class="nv">d</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defstruct</span> <span class="p">(</span><span class="nv">point</span> <span class="p">(</span><span class="ss">:conc-name</span> <span class="no">nil</span><span class="p">))</span>
  <span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">distance</span> <span class="p">(</span><span class="nv">p1</span> <span class="nv">p2</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">mag</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">p2</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">p2</span><span class="p">))</span>
       <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">p1</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">p2</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">minroot</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">zerop</span> <span class="nv">a</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">disc</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">4</span> <span class="nv">a</span> <span class="nv">c</span><span class="p">))))</span>
        <span class="p">(</span><span class="nb">unless</span> <span class="p">(</span><span class="nb">minusp</span> <span class="nv">disc</span><span class="p">)</span>
          <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">discrt</span> <span class="p">(</span><span class="nb">sqrt</span> <span class="nv">disc</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">min</span> <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">discrt</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">a</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">/</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">b</span><span class="p">)</span> <span class="nv">discrt</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="nv">a</span><span class="p">))))))))</span>
</pre></div>
</td></tr></table></div>
<p><strong>图 9.2 实用数学函数</strong></p>
<p>图 9.2 包含了我们在光线追踪器里会需要用到的一些实用数学函数。第一个 <tt class="docutils literal"><span class="pre">sq</span></tt> ，返回其参数的平方。下一个 <tt class="docutils literal"><span class="pre">mag</span></tt> ，返回一个给定 <tt class="docutils literal"><span class="pre">x</span></tt> <tt class="docutils literal"><span class="pre">y</span></tt> <tt class="docutils literal"><span class="pre">z</span></tt> 所组成向量的大小 (magnitude)。这个函数被接下来两个函数用到。我们在 <tt class="docutils literal"><span class="pre">unit-vector</span></tt> 用到了，此函数返回三个数值，来表示与单位向量有着同样方向的向量，其中向量是由 <tt class="docutils literal"><span class="pre">x</span></tt> <tt class="docutils literal"><span class="pre">y</span></tt> <tt class="docutils literal"><span class="pre">z</span></tt> 所组成的:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">multiple-value-call</span> <span class="nf">#&#39;</span><span class="nv">mag</span> <span class="p">(</span><span class="nv">unit-vector</span> <span class="mi">23</span> <span class="mi">12</span> <span class="mi">47</span><span class="p">))</span>
<span class="mf">1.0</span>
</pre></div>
</td></tr></table></div>
<p>我们在 <tt class="docutils literal"><span class="pre">distance</span></tt> 也用到了 <tt class="docutils literal"><span class="pre">mag</span></tt> ，它返回三维空间中，两点的距离。（定义 <tt class="docutils literal"><span class="pre">point</span></tt> 结构来有一个 <tt class="docutils literal"><span class="pre">nil</span></tt> 的 <tt class="docutils literal"><span class="pre">conc-name</span></tt> 意味着栏位存取的函数会有跟栏位一样的名字: 举例来说， <tt class="docutils literal"><span class="pre">x</span></tt> 而不是 <tt class="docutils literal"><span class="pre">point-x</span></tt> 。)</p>
<p>最後 <tt class="docutils literal"><span class="pre">minroot</span></tt> 接受三个实数， <tt class="docutils literal"><span class="pre">a</span></tt> , <tt class="docutils literal"><span class="pre">b</span></tt> 与 <tt class="docutils literal"><span class="pre">c</span></tt> ，并返回满足等式 <span class="math">\(ax^2+bx+c=0\)</span> 的最小实数 <tt class="docutils literal"><span class="pre">x</span></tt> 。当 <tt class="docutils literal"><span class="pre">a</span></tt> 不为 0 时，这个等式的根由下面这个熟悉的式子给出:</p>
<div class="math">
\[x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a}\]</div>
<p>图 9.3 包含了定义一个最小光线追踪器的代码。 它产生通过单一光源照射的黑白图像，与观测点 (eye)处於同个位置。 (结果看起来像是闪光摄影术 (flash photography)拍出来的)</p>
<p><tt class="docutils literal"><span class="pre">surface</span></tt> 结构会用来表示模拟世界中的物体。更精确的说，它会被 <tt class="docutils literal"><span class="pre">included</span></tt> 至定义具体类型物体的结构里，像是球体 (spheres)。 <tt class="docutils literal"><span class="pre">surface</span></tt> 结构本身只包含一个栏位: 一个 <tt class="docutils literal"><span class="pre">color</span></tt> 范围从 0 (黑色) 至 1 (白色)。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defstruct</span> <span class="nv">surface</span>  <span class="nv">color</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defparameter</span> <span class="vg">*world*</span> <span class="no">nil</span><span class="p">)</span>
<span class="p">(</span><span class="nb">defconstant</span> <span class="nv">eye</span> <span class="p">(</span><span class="nv">make-point</span> <span class="ss">:x</span> <span class="mi">0</span> <span class="ss">:y</span> <span class="mi">0</span> <span class="ss">:z</span> <span class="mi">200</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">tracer</span> <span class="p">(</span><span class="nb">pathname</span> <span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">res</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">p</span> <span class="nb">pathname</span> <span class="ss">:direction</span> <span class="ss">:output</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">format</span> <span class="nv">p</span> <span class="s">&quot;P2 ~A ~A 255&quot;</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">res</span> <span class="mi">100</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">res</span> <span class="mi">100</span><span class="p">))</span>
    <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">inc</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">res</span><span class="p">)))</span>
      <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">y</span> <span class="mi">-50</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="nv">inc</span><span class="p">)))</span>
          <span class="p">((</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">50</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">inc</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">-50</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">inc</span><span class="p">)))</span>
            <span class="p">((</span><span class="nb">&lt;</span> <span class="p">(</span><span class="nb">-</span> <span class="mi">50</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">inc</span><span class="p">))</span>
          <span class="p">(</span><span class="nb">print</span> <span class="p">(</span><span class="nv">color-at</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">p</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">color-at</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
                       <span class="p">(</span><span class="nv">unit-vector</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">eye</span><span class="p">))</span>
                                    <span class="p">(</span><span class="nb">-</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">eye</span><span class="p">))</span>
                                    <span class="p">(</span><span class="nb">-</span> <span class="mi">0</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">eye</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">round</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nv">sendray</span> <span class="nv">eye</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span> <span class="mi">255</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">sendray</span> <span class="p">(</span><span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">int</span><span class="p">)</span> <span class="p">(</span><span class="nv">first-hit</span> <span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">s</span>
        <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nv">lambert</span> <span class="nv">s</span> <span class="nv">int</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span> <span class="p">(</span><span class="nv">surface-color</span> <span class="nv">s</span><span class="p">))</span>
        <span class="mi">0</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">first-hit</span> <span class="p">(</span><span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">(</span><span class="nv">surface</span> <span class="nv">hit</span> <span class="nv">dist</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">s</span> <span class="vg">*world*</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">h</span> <span class="p">(</span><span class="nv">intersect</span> <span class="nv">s</span> <span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">when</span> <span class="nv">h</span>
          <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">d</span> <span class="p">(</span><span class="nv">distance</span> <span class="nv">h</span> <span class="nv">pt</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">dist</span><span class="p">)</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">d</span> <span class="nv">dist</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">setf</span> <span class="nv">surface</span> <span class="nv">s</span> <span class="nv">hit</span> <span class="nv">h</span> <span class="nv">dist</span> <span class="nv">d</span><span class="p">))))))</span>
    <span class="p">(</span><span class="nb">values</span> <span class="nv">surface</span> <span class="nv">hit</span><span class="p">)))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">lambert</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">int</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">multiple-value-bind</span> <span class="p">(</span><span class="nv">xn</span> <span class="nv">yn</span> <span class="nv">zn</span><span class="p">)</span> <span class="p">(</span><span class="nv">normal</span> <span class="nv">s</span> <span class="nv">int</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">max</span> <span class="mi">0</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">xr</span> <span class="nv">xn</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">yr</span> <span class="nv">yn</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">zr</span> <span class="nv">zn</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p><strong>图 9.3 光线追踪。</strong></p>
<p>图像平面会是由 x 轴与 y 轴所定义的平面。观测者 (eye) 会在 z 轴，距离原点 200 个单位。所以要在图像平面可以被看到，插入至 <tt class="docutils literal"><span class="pre">*worlds*</span></tt> 的表面 (一开始为 <tt class="docutils literal"><span class="pre">nil</span></tt>)会有着负的 z 座标。图 9.4 说明了一个光线穿过图像平面上的一点，并击中一个球体。</p>
<div class="figure">
<img alt="../_images/Figure-9.4.png" src="../_images/Figure-9.4.png" />
</div>
<p><strong>图 9.4: 追踪光线。</strong></p>
<p>函数 <tt class="docutils literal"><span class="pre">tracer</span></tt> 接受一个路径名称，并写入一张图片至对应的文件。图片文件会用一种简单的 ASCII 称作 PGM 的格式写入。默认情况下，图像会是 100x100 。我们 PGM 文件的标头 (headers) 会由标签 <tt class="docutils literal"><span class="pre">P2</span></tt> 组成，伴随着指定图片宽度 (breadth)与高度 (height)的整数，初始为 100，单位为 pixel，以及可能的最大值 (255)。文件剩馀的部份会由 10000 个介於 0 (黑)与 1 (白)整数组成，代表着 100 条 100 像素的水平线。</p>
<p>图片的解析度可以通过给入明确的 <tt class="docutils literal"><span class="pre">res</span></tt> 来调整。举例来说，如果 <tt class="docutils literal"><span class="pre">res</span></tt> 是 <tt class="docutils literal"><span class="pre">2</span></tt> ，则同样的图像会被渲染成 200x200 。</p>
<p>图片是一个在图像平面 100x100 的正方形。每一个像素代表着穿过图像平面抵达观测点的光的数量。要找到每个像素光的数量， <tt class="docutils literal"><span class="pre">tracer</span></tt> 调用 <tt class="docutils literal"><span class="pre">color-at</span></tt> 。这个函数找到从观测点至该点的向量，并调用 <tt class="docutils literal"><span class="pre">sendray</span></tt> 来追踪这个向量回到模拟世界的轨迹； <tt class="docutils literal"><span class="pre">sandray</span></tt> 会返回一个数值介於 0 与 1 之间的亮度 (intensity)，之後会缩放成一个 0 至 255 的整数来显示。</p>
<p>要决定一个光线的亮度， <tt class="docutils literal"><span class="pre">sendray</span></tt> 需要找到光是从哪个物体所反射的。要办到这件事，我们调用 <tt class="docutils literal"><span class="pre">first-hit</span></tt> ，此函数研究在 <tt class="docutils literal"><span class="pre">*world*</span></tt> 里的所有平面，并返回光线最先抵达的平面（如果有的话）。如果光没有击中任何东西， <tt class="docutils literal"><span class="pre">sendray</span></tt> 仅返回背景颜色，按惯例是 <tt class="docutils literal"><span class="pre">0</span></tt> (黑色)。如果光线有击中某物的话，我们需要找出在光击中时，有多少数量的光照在该平面。</p>
<p><a class="reference external" href="http://zh.wikipedia.org/zh-tw/%E6%AF%94%E5%B0%94%EF%BC%8D%E6%9C%97%E4%BC%AF%E5%AE%9A%E5%BE%8B">朗伯定律</a> 告诉我们，由平面上一点所反射的光的强度，正比於该点的单位法向量 (unit normal vector) <em>N</em> (这里是与平面垂直且长度为一的向量)与该点至光源的单位向量 <em>L</em> 的点积 (dot-product):</p>
<div class="math">
\[i = N·L\]</div>
<p>如果光刚好照到这点， <em>N</em> 与 <em>L</em> 会重合 (coincident)，则点积会是最大值， <tt class="docutils literal"><span class="pre">1</span></tt> 。如果将在这时候将平面朝光转 90 度，则 <em>N</em> 与 <em>L</em> 会垂直，则两者点积会是 <tt class="docutils literal"><span class="pre">0</span></tt> 。如果光在平面後面，则点积会是负数。</p>
<p>在我们的程序里，我们假设光源在观测点 (eye)，所以 <tt class="docutils literal"><span class="pre">lambert</span></tt> 使用了这个规则来找到平面上某点的亮度 (illumination)，返回我们追踪的光的单位向量与法向量的点积。</p>
<p>在 <tt class="docutils literal"><span class="pre">sendray</span></tt> 这个值会乘上平面的颜色 (即便是有好的照明，一个暗的平面还是暗的)来决定该点之後总体亮度。</p>
<p>为了简单起见，我们在模拟世界里会只有一种物体，球体。图 9.5 包含了与球体有关的代码。球体结构包含了 <tt class="docutils literal"><span class="pre">surface</span></tt> ，所以一个球体会有一种颜色以及 <tt class="docutils literal"><span class="pre">center</span></tt> 和 <tt class="docutils literal"><span class="pre">radius</span></tt> 。调用 <tt class="docutils literal"><span class="pre">defsphere</span></tt> 添加一个新球体至世界里。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defstruct</span> <span class="p">(</span><span class="nv">sphere</span> <span class="p">(</span><span class="ss">:include</span> <span class="nv">surface</span><span class="p">))</span>
  <span class="nv">radius</span> <span class="nv">center</span><span class="p">)</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">defsphere</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span> <span class="nv">r</span> <span class="nv">c</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">s</span> <span class="p">(</span><span class="nv">make-sphere</span>
             <span class="ss">:radius</span> <span class="nv">r</span>
             <span class="ss">:center</span> <span class="p">(</span><span class="nv">make-point</span> <span class="ss">:x</span> <span class="nv">x</span> <span class="ss">:y</span> <span class="nv">y</span> <span class="ss">:z</span> <span class="nv">z</span><span class="p">)</span>
             <span class="ss">:color</span>  <span class="nv">c</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">push</span> <span class="nv">s</span> <span class="vg">*world*</span><span class="p">)</span>
    <span class="nv">s</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">intersect</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nb">typecase</span> <span class="nv">s</span> <span class="p">(</span><span class="nv">sphere</span> <span class="nf">#&#39;</span><span class="nv">sphere-intersect</span><span class="p">))</span>
           <span class="nv">s</span> <span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">sphere-intersect</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">pt</span> <span class="nv">xr</span> <span class="nv">yr</span> <span class="nv">zr</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">c</span> <span class="p">(</span><span class="nv">sphere-center</span> <span class="nv">s</span><span class="p">))</span>
         <span class="p">(</span><span class="nv">n</span> <span class="p">(</span><span class="nv">minroot</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">xr</span><span class="p">)</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">yr</span><span class="p">)</span> <span class="p">(</span><span class="nv">sq</span> <span class="nv">zr</span><span class="p">))</span>
                     <span class="p">(</span><span class="nb">*</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">c</span><span class="p">))</span> <span class="nv">xr</span><span class="p">)</span>
                             <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">c</span><span class="p">))</span> <span class="nv">yr</span><span class="p">)</span>
                             <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">c</span><span class="p">))</span> <span class="nv">zr</span><span class="p">)))</span>
                     <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">sq</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">c</span><span class="p">)))</span>
                        <span class="p">(</span><span class="nv">sq</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">c</span><span class="p">)))</span>
                        <span class="p">(</span><span class="nv">sq</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">c</span><span class="p">)))</span>
                        <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">sq</span> <span class="p">(</span><span class="nv">sphere-radius</span> <span class="nv">s</span><span class="p">)))))))</span>
    <span class="p">(</span><span class="k">if</span> <span class="nv">n</span>
        <span class="p">(</span><span class="nv">make-point</span> <span class="ss">:x</span>  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">n</span> <span class="nv">xr</span><span class="p">))</span>
                    <span class="ss">:y</span>  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">n</span> <span class="nv">yr</span><span class="p">))</span>
                    <span class="ss">:z</span>  <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">pt</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">n</span> <span class="nv">zr</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">normal</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">pt</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">funcall</span> <span class="p">(</span><span class="nb">typecase</span> <span class="nv">s</span> <span class="p">(</span><span class="nv">sphere</span> <span class="nf">#&#39;</span><span class="nv">sphere-normal</span><span class="p">))</span>
           <span class="nv">s</span> <span class="nv">pt</span><span class="p">))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">sphere-normal</span> <span class="p">(</span><span class="nv">s</span> <span class="nv">pt</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">c</span> <span class="p">(</span><span class="nv">sphere-center</span> <span class="nv">s</span><span class="p">)))</span>
    <span class="p">(</span><span class="nv">unit-vector</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">pt</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">pt</span><span class="p">))</span>
                 <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nv">z</span> <span class="nv">pt</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p><strong>图 9.5 球体。</strong></p>
<p>函数 <tt class="docutils literal"><span class="pre">intersect</span></tt> 判断与何种平面有关，并调用对应的函数。在此时只有一种， <tt class="docutils literal"><span class="pre">sphere-intersect</span></tt> ，但 <tt class="docutils literal"><span class="pre">intersect</span></tt> 是写成可以容易扩展处理别种物体。</p>
<p>我们要怎麽找到一束光与一个球体的交点 (intersection)呢？光线是表示成点 <span class="math">\(p =〈x_0,y_0,x_0〉\)</span> 以及单位向量 <span class="math">\(v =〈x_r,y_r,x_r〉\)</span> 。每个在光上的点可以表示为 <span class="math">\(p+nv\)</span> ，对於某个 <em>n</em> –– 即 <span class="math">\(〈x_0+nx_r,y_0+ny_r,z_0+nz_r〉\)</span> 。光击中球体的点的距离至中心 <span class="math">\(〈x_c,y_c,z_c〉\)</span> 会等於球体的半径 <em>r</em> 。所以在下列这个交点的方程序会成立:</p>
<div class="math">
\[r = \sqrt{ (x_0 + nx_r + x_c)^2 + (y_0 + ny_r + y_c)^2 + (z_0 + nz_r + z_c)^2 }\]</div>
<p>这会给出</p>
<div class="math">
\[an^2 + bn + c = 0\]</div>
<p>其中</p>
<div class="math">
\[\begin{split}a = x_r^2 + y_r^2 + z_r^2\\b = 2((x_0-x_c)x_r + (y_0-y_c)y_r + (z_0-z_c)z_r)\\c = (x_0-x_c)^2 + (y_0-y_c)^2 + (z_0-z_c)^2 - r^2\end{split}\]</div>
<p>要找到交点我们只需要找到这个二次方程序的根。它可能是零、一个或两个实数根。没有根代表光没有击中球体；一个根代表光与球体交於一点 (擦过 「grazing hit」)；两个根代表光与球体交於两点 (一点交於进入时、一点交於离开时)。在最後一个情况里，我们想要两个根之中较小的那个； <em>n</em> 与光离开观测点的距离成正比，所以先击中的会是较小的 <em>n</em> 。所以我们调用 <tt class="docutils literal"><span class="pre">minroot</span></tt> 。如果有一个根， <tt class="docutils literal"><span class="pre">sphere-intersect</span></tt> 返回代表该点的 <span class="math">\(〈x_0+nx_r,y_0+ny_r,z_0+nz_r〉\)</span> 。</p>
<p>图 9.5 的另外两个函数， <tt class="docutils literal"><span class="pre">normal</span></tt> 与 <tt class="docutils literal"><span class="pre">sphere-normal</span></tt> 类比於 <tt class="docutils literal"><span class="pre">intersect</span></tt> 与 <tt class="docutils literal"><span class="pre">sphere-intersect</span></tt> 。要找到垂直於球体很简单 –– 不过是从该点至球体中心的向量而已。</p>
<p>图 9.6 示范了我们如何产生图片； <tt class="docutils literal"><span class="pre">ray-test</span></tt> 定义了 38 个球体（不全都看的见）然後产生一张图片，叫做 &#8220;sphere.pgm&#8221; 。</p>
<p>(译注：PGM 可移植灰度图格式，更多信息参见 <a class="reference external" href="http://en.wikipedia.org/wiki/Portable_graymap">wiki</a> )</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">ray-test</span> <span class="p">(</span><span class="k">&amp;optional</span> <span class="p">(</span><span class="nv">res</span> <span class="mi">1</span><span class="p">))</span>
  <span class="p">(</span><span class="nb">setf</span> <span class="vg">*world*</span> <span class="no">nil</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">defsphere</span> <span class="mi">0</span> <span class="mi">-300</span> <span class="mi">-1200</span> <span class="mi">200</span> <span class="mf">.8</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">defsphere</span> <span class="mi">-80</span> <span class="mi">-150</span> <span class="mi">-1200</span> <span class="mi">200</span> <span class="mf">.7</span><span class="p">)</span>
  <span class="p">(</span><span class="nv">defsphere</span> <span class="mi">70</span> <span class="mi">-100</span> <span class="mi">-1200</span> <span class="mi">200</span> <span class="mf">.9</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">x</span> <span class="mi">-2</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">x</span><span class="p">)))</span>
      <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">))</span>
    <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">z</span> <span class="mi">2</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">z</span><span class="p">)))</span>
        <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">z</span> <span class="mi">7</span><span class="p">))</span>
      <span class="p">(</span><span class="nv">defsphere</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="mi">200</span><span class="p">)</span> <span class="mi">300</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">z</span> <span class="mi">-400</span><span class="p">)</span> <span class="mi">40</span> <span class="mf">.75</span><span class="p">)))</span>
  <span class="p">(</span><span class="nv">tracer</span> <span class="p">(</span><span class="nb">make-pathname</span> <span class="ss">:name</span> <span class="s">&quot;spheres.pgm&quot;</span><span class="p">)</span> <span class="nv">res</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p><strong>图 9.6 使用光线追踪器</strong></p>
<p>图 9.7 是产生出来的图片，其中 <tt class="docutils literal"><span class="pre">res</span></tt> 参数为 10。</p>
<div class="figure">
<img alt="../_images/Figure-9.7.png" src="../_images/Figure-9.7.png" />
</div>
<p><strong>图 9.7: 追踪光线的图</strong></p>
<p>一个实际的光线追踪器可以产生更复杂的图片，因为它会考虑更多，我们只考虑了单一光源至平面某一点。可能会有多个光源，每一个有不同的强度。它们通常不会在观测点，在这个情况程序需要检查至光源的向量是否与其他平面相交，这会在第一个相交的平面上产生阴影。将光源放置於观测点让我们不需要考虑这麽复杂的情况，因为我们看不见在阴影中的任何点。</p>
<p>一个实际的光线追踪器不仅追踪光第一个击中的平面，也会加入其它平面的反射光。一个实际的光线追踪器会是有颜色的，并可以模型化出透明或是闪耀的平面。但基本的算法会与图 9.3 所演示的差不多，而许多改进只需要递回的使用同样的成分。</p>
<p>一个实际的光线追踪器可以是高度优化的。这里给出的程序为了精简写成，甚至没有如 Lisp 程序员会最佳化的那样，就仅是一个光线追踪器而已。仅加入类型与行内宣告 (13.3 节)就可以让它变得两倍以上快。</p>
</div>
<div class="section" id="chapter-9-summary">
<h2>Chapter 9 总结 (Summary)<a class="headerlink" href="#chapter-9-summary" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li>Common Lisp 提供整数 (integers)、比值 (ratios)、浮点数 (floating-point numbers)以及复数 (complex numbers)。</li>
<li>数字可以被约分或转换 (converted)，而它们的位数 (components)可以被取出。</li>
<li>用来比较数字的判断式可以接受任意数量的参数，以及比较下一数对 (successive pairs) –– <cite>/=</cite> 函数除外，它是用来比较所有的数对 (pairs)。</li>
<li>Common Lisp 几乎提供你在低阶科学计算机可以看到的数值函数。同样的函数普遍可应用在多种类型的数字上。</li>
<li>Fixnum 是小至可以塞入一个字 (word)的整数。它们在必要时会悄悄但花费昂贵地转成大数 (bignum)。Common Lisp 提供最多四种浮点数。每一个浮点表示法的限制是实现相关的 (implementation-dependent)常量。</li>
<li>一个光线追踪器 (ray-tracer)通过追踪光线来产生图像，使得每一像素回到模拟的世界。</li>
</ol>
</div>
<div class="section" id="chapter-9-exercises">
<h2>Chapter 9 练习 (Exercises)<a class="headerlink" href="#chapter-9-exercises" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li>定义一个函数，接受一个实数列表，若且唯若 (iff)它们是非递减 (nondecreasing)顺序时返回真。</li>
<li>定义一个函数，接受一个整数 <tt class="docutils literal"><span class="pre">cents</span></tt> 并返回四个值，将数字用 <tt class="docutils literal"><span class="pre">25-</span></tt> , <tt class="docutils literal"><span class="pre">10-</span></tt> , <tt class="docutils literal"><span class="pre">5-</span></tt> , <tt class="docutils literal"><span class="pre">1-</span></tt> 来显示，使用最少数量的硬币。(译注: <tt class="docutils literal"><span class="pre">25-</span></tt> 是 25 美分，以此类推)</li>
<li>一个遥远的星球住着两种生物， wigglies 与 wobblies 。 Wigglies 与 wobblies 唱歌一样厉害。每年都有一个比赛来选出十大最佳歌手。下面是过去十年的结果:</li>
</ol>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="7%" />
<col width="10%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">YEAR</th>
<th class="head">1</th>
<th class="head">2</th>
<th class="head">3</th>
<th class="head">4</th>
<th class="head">5</th>
<th class="head">6</th>
<th class="head">7</th>
<th class="head">8</th>
<th class="head">9</th>
<th class="head">10</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>WIGGLIES</td>
<td>6</td>
<td>5</td>
<td>6</td>
<td>4</td>
<td>5</td>
<td>5</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>5</td>
</tr>
<tr class="row-odd"><td>WOBBLIES</td>
<td>4</td>
<td>5</td>
<td>4</td>
<td>6</td>
<td>5</td>
<td>5</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>写一个程序来模拟这样的比赛。你的结果实际上有建议委员会每年选出 10 个最佳歌手吗？</p>
<ol class="arabic simple" start="4">
<li>定义一个函数，接受 8 个表示二维空间中两个线段端点的实数，若线段没有相交，则返回假，或返回两个值表示相交点的 <tt class="docutils literal"><span class="pre">x</span></tt> 座标与 <tt class="docutils literal"><span class="pre">y</span></tt> 座标。</li>
<li>假设 <tt class="docutils literal"><span class="pre">f</span></tt> 是一个接受一个 (实数) 参数的函数，而 <tt class="docutils literal"><span class="pre">min</span></tt> 与 <tt class="docutils literal"><span class="pre">max</span></tt> 是有着不同正负号的非零实数，使得 <tt class="docutils literal"><span class="pre">f</span></tt> 对於参数 <tt class="docutils literal"><span class="pre">i</span></tt> 有一个根 (返回零)并满足 <tt class="docutils literal"><span class="pre">min</span> <span class="pre">&lt;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">max</span></tt> 。定义一个函数，接受四个参数， <tt class="docutils literal"><span class="pre">f</span></tt> , <tt class="docutils literal"><span class="pre">min</span></tt> , <tt class="docutils literal"><span class="pre">max</span></tt> 以及 <tt class="docutils literal"><span class="pre">epsilon</span></tt> ，并返回一个 <tt class="docutils literal"><span class="pre">i</span></tt> 的近似值，准确至正负 <tt class="docutils literal"><span class="pre">epsilon</span></tt> 之内。</li>
<li><em>Honer&#8217;s method</em> 是一个有效率求出多项式的技巧。要找到 <span class="math">\(ax^3+bx^2+cx+d\)</span> 你对 <tt class="docutils literal"><span class="pre">x(x(ax+b)+c)+d</span></tt> 求值。定义一个函数，接受一个或多个参数 –– x 的值伴随着 <em>n</em> 个实数，用来表示 <tt class="docutils literal"><span class="pre">(n-1)</span></tt> 次方的多项式的系数 –– 并用 <em>Honer&#8217;s method</em> 计算出多项式的值。</li>
</ol>
<p>译注: <a class="reference external" href="http://en.wikipedia.org/wiki/Horner's_method">Honer&#8217;s method on wiki</a></p>
<ol class="arabic simple" start="7">
<li>你的 Common Lisp 实现使用了几个位元来表示定长数？</li>
<li>你的 Common Lisp 实现提供几种不同的浮点数？</li>
</ol>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>当 <tt class="docutils literal"><span class="pre">format</span></tt> 取整显示时，它不保证会取成偶数或奇数。见 125 页 (译注: 7.4 节)。</td></tr>
</tbody>
</table>
</div>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'acl-chinese';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                  </div></div>
              </article><div class="clearer"></div>
          </div><div class="span3">
                <div class="sphinxsidebar">
      <div id="sidenav" class="box sphinxsidebarwrapper">


<h4><a href="../index.html">內容目录</a></h4>
  <ul>
<li><a class="reference internal" href="#">第九章：数字</a><ul>
<li><a class="reference internal" href="#types">9.1 类型 (Types)</a></li>
<li><a class="reference internal" href="#conversion-and-extraction">9.2 转换及取出 (Conversion and Extraction)</a></li>
<li><a class="reference internal" href="#comparison">9.3 比较 (Comparison)</a></li>
<li><a class="reference internal" href="#arithematic">9.4 算术 (Arithematic)</a></li>
<li><a class="reference internal" href="#exponentiation">9.5 指数 (Exponentiation)</a></li>
<li><a class="reference internal" href="#trigometric-functions">9.6 三角函数 (Trigometric Functions)</a></li>
<li><a class="reference internal" href="#id3">9.6 三角函数 (Trigometric Functions)</a></li>
<li><a class="reference internal" href="#representations">9.7 表示法 (Representations)</a></li>
<li><a class="reference internal" href="#example-ray-tracing">9.8 范例：追踪光线 (Example: Ray-Tracing)</a></li>
<li><a class="reference internal" href="#chapter-9-summary">Chapter 9 总结 (Summary)</a></li>
<li><a class="reference internal" href="#chapter-9-exercises">Chapter 9 练习 (Exercises)</a></li>
</ul>
</li>
</ul>

  
    <h3>本页</h3>
    <ul class="this-page-menu">
      
      
        <li><a href="https://github.com/acl-translation/acl-chinese/blob/redirect-to-new-domain/zhCN/ch9-cn.rst">
          Show on GitHub</a></li>
        <li><a href="https://github.com/acl-translation/acl-chinese/edit/redirect-to-new-domain/zhCN/ch9-cn.rst">
          Edit on GitHub</a></li>
      
    </ul>
  
</div>
    </div>
              </div></div>
      </div>
<footer class="container-fluid">
        <hr />&copy; 版权所有 2012, Juanito Fatas Huang.最后更新日期是 Apr 22, 2013.使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.</footer>
 <!-- End original user content -->


<br>
<br>
<br>


<style type="text/css">
  .rtd-badge {
    position: fixed;
    display: block;
    bottom: 5px;
    height: 40px;
    text-indent: -9999em;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
    -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
  }
  #version_menu {
    position: fixed;
    display: none;
    bottom: 11px;
    right: 166px;
    list-style-type: none;
    margin: 0;
  }
  .footer_popout:hover #version_menu {
    display: block;
  }
  #version_menu li {
    display: block;
    float: right;
  }
  #version_menu li a {
    display: block;
    padding: 6px 10px 4px 10px;
    margin: 7px 7px 0 0;
    font-weight: bold;
    font-size: 14px;
    height: 20px;
    line-height: 17px;
    text-decoration: none;
    color: #fff;
    background: #8ca1af url(../images/gradient-light.png) bottom left repeat-x;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    box-shadow: 0 1px 1px #465158;
    -moz-box-shadow: 0 1px 1px #465158;
    -webkit-box-shadow: 0 1px 1px #465158;
    text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
  }
  #version_menu li a:hover {
    text-decoration: none;
    background-color: #697983;
    box-shadow: 0 1px 0px #465158;
    -moz-box-shadow: 0 1px 0px #465158;
    -webkit-box-shadow: 0 1px 0px #465158;
  }
  .rtd-badge.rtd {
    background: #3b4449 url(//media.readthedocs.org//images/badge-rtd.png) scroll 0px -46px no-repeat;
    border: 1px solid #282E32;
    width: 41px;
    right: 5px;
  }
  .footer_popout:hover .rtd-badge.rtd {
    background-position: top left;
    width: 160px;
  }
  .rtd-badge.revsys { background: #465158 url(//media.readthedocs.org//images/badge-revsys.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 290px;
    right: 173px;
  }
  .rtd-badge.revsys-inline-sponsored {
    position: inherit;
    margin-left: auto;
    margin-right: 175px;
    margin-bottom: 5px;
    background: #465158 url(//media.readthedocs.org//images/badge-revsys.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 290px;
    right: 173px;
  }
  .rtd-badge.revsys-inline {
    position: inherit;
    margin-left: auto;
    margin-right: 175px;
    margin-bottom: 5px;
    background: #465158 url(//media.readthedocs.org//images/badge-revsys-sm.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 205px;
    right: 173px;
  }

</style>
<div class="rtd_doc_footer">
  <div class="footer_popout">
    <a href="//readthedocs.org/projects/ansi-common-lisp/?fromdocs=ansi-common-lisp" class="rtd-badge rtd"> Brought to you by Read the Docs</a>
    <ul id="version_menu">
      
        <li><a href="/en/latest/">latest</a></li>
      
    </ul>
  </div>
</div>
<!-- RTD Analytics Code -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


<!-- User Analytics Code -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-26995626-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</body>
</html>