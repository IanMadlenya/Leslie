<!DOCTYPE HTML>

  <html xmlns="http://www.w3.org/1999/xhtml" lang="zh">

  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
<title>第十四章：进阶议题 &mdash; ANSI Common Lisp 中文版</title>
    
<!-- RTD <head> -->
<script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.8.2/jquery.min.js"></script>
<script type="text/javascript" src="//media.readthedocs.org/javascript/underscore.js"></script>
<script type="text/javascript" src="//media.readthedocs.org/javascript/doctools.js"></script>

<script type="text/javascript">
  // This is included here for Javascript that doesn't have access to the templates.
  var doc_version = "latest";
  var doc_slug = "ansi-common-lisp";
</script>

<script type="text/javascript" src="//media.readthedocs.org/javascript/rtd.js"></script>
<!-- end RTD <head> -->

    <link rel="stylesheet" href="../_static/han.min.css" type="text/css" />
    <link rel="stylesheet" href="../_static/bootstrap.min.css" type="text/css" />
  <link rel="stylesheet" href="../_static/rosefinch.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/main.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:       '../',
        VERSION:        '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX:    '.html',
        HAS_SOURCE:     true
      };
    </script>
    <script type="text/javascript" src="../_static/han.min.js"></script>
    <script type="text/javascript" src="../_static/bootstrap.min.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  <script type="text/javascript" src=../_static/jquery.dimensions.js"></script>
  <script type="text/javascript" src="../_static/main.js"></script><link rel="top" title="ANSI Common Lisp 中文版" href="../index.html" /></head>

  <body><div class="navbar navbar-static-top navbar-inverse">
        <div id="top-bar" class="navbar-inner">

          <h1 id="logo">ANSI Common Lisp 中文版<a href="../index.html" class="brand">ANSI Common Lisp 中文版</a></h1>
          <ul class="nav"></ul><a href="https://github.com/acl-translation/acl-chinese"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub"></a>
        </div>
      </div><div class="content container-fluid">
        <div class="row-fluid"><div class="document span9"><article >
                <div class="documentwrapper"><div class="body"><div class="section" id="id1">
<h1>第十四章：进阶议题<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>本章是选择性阅读的。本章描述了 Common Lisp 里一些更深奥的特性。Common Lisp 像是一个冰山：大部分的功能对于那些永远不需要他们的多数用户是看不见的。你或许永远不需要自己定义包 (Package)或读取宏 (read-macros)，但当你需要时，有些例子可以让你参考是很有用的。</p>
<div class="section" id="type-specifiers">
<h2>14.1 类型标识符 (Type Specifiers)<a class="headerlink" href="#type-specifiers" title="永久链接至标题">¶</a></h2>
<p>类型在 Common Lisp 里不是对象。举例来说，没有对象对应到 <tt class="docutils literal"><span class="pre">integer</span></tt> 这个类型。我们从像是 <tt class="docutils literal"><span class="pre">type-of</span></tt> 函数里所获得的，以及作为传给像是 <tt class="docutils literal"><span class="pre">typep</span></tt> 函数的参数，不是一个类型，而是一个类型标识符 (type specifier)。</p>
<p>一个类型标识符是一个类型的名称。最简单的类型标识符是像是 <tt class="docutils literal"><span class="pre">integer</span></tt> 的符号。这些符号形成了 Common Lisp 里的类型层级。在层级的最顶端是类型 <tt class="docutils literal"><span class="pre">t</span></tt> –– 所有的对象皆为类型 <tt class="docutils literal"><span class="pre">t</span></tt> 。而类型层级不是一棵树。从 <tt class="docutils literal"><span class="pre">nil</span></tt> 至顶端有两条路，举例来说：一条从 <tt class="docutils literal"><span class="pre">atom</span></tt> ，另一条从 <tt class="docutils literal"><span class="pre">list</span></tt> 与 <tt class="docutils literal"><span class="pre">sequence</span></tt> 。</p>
<p>一个类型实际上只是一个对象集合。这意味著有多少类型就有多少个对象的集合：一个无穷大的数目。我们可以用原子的类型标识符 (atomic type specifiers)来表示某些集合：比如 <tt class="docutils literal"><span class="pre">integer</span></tt> 表示所有整数集合。但我们也可以建构一个复合类型标识符 (compound type specifiers)来参照到任何对象的集合。</p>
<p>举例来说，如果 <tt class="docutils literal"><span class="pre">a</span></tt> 与 <tt class="docutils literal"><span class="pre">b</span></tt> 是两个类型标识符，则 <tt class="docutils literal"><span class="pre">(or</span> <span class="pre">a</span> <span class="pre">b)</span></tt> 表示分别由 <tt class="docutils literal"><span class="pre">a</span></tt> 与 <tt class="docutils literal"><span class="pre">b</span></tt> 类型所表示的联集 (union)。也就是说，一个类型 <tt class="docutils literal"><span class="pre">(or</span> <span class="pre">a</span> <span class="pre">b)</span></tt> 的对象是类型 <tt class="docutils literal"><span class="pre">a</span></tt> 或 类型 <tt class="docutils literal"><span class="pre">b</span></tt> 。</p>
<p>如果 <tt class="docutils literal"><span class="pre">circular?</span></tt> 是一个对于 <tt class="docutils literal"><span class="pre">cdr</span></tt> 为环状的列表返回真的函数，则你可以使用适当的序列集合来表示： <a class="footnote-reference" href="#id4" id="id2">[1]</a></p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">or</span> <span class="nb">vector</span> <span class="p">(</span><span class="nb">and</span> <span class="nb">list</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">satisfies</span> <span class="nv">circular?</span><span class="p">))))</span>
</pre></div>
</td></tr></table></div>
<p>某些原子的类型标识符也可以出现在复合类型标识符。要表示介于 1 至 100 的整数（包含），我们可以用：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nc">integer</span> <span class="mi">1</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>这样的类型标识符用来表示一个有限的类型 (finite type)。</p>
<p>在一个复合类型标识符里，你可以藉由在一个参数的位置使用 <tt class="docutils literal"><span class="pre">*</span></tt> 来留下某些未指定的信息。所以</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="kt">simple-array</span> <span class="kt">fixnum</span> <span class="p">(</span><span class="nb">*</span> <span class="nb">*</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>描述了指定给 <tt class="docutils literal"><span class="pre">fixnum</span></tt> 使用的二维简单数组 (simple array)集合，而</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="kt">simple-array</span> <span class="kt">fixnum</span> <span class="nb">*</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>描述了指定给 <tt class="docutils literal"><span class="pre">finxnum</span></tt> 使用的简单数组集合 (前者的超类型 「supertype」)。尾随的星号可以省略，所以上个例子可以写为：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="kt">simple-array</span> <span class="kt">fixnum</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>若一个复合类型标识符没有传入参数，你可以使用一个原子。所以 <tt class="docutils literal"><span class="pre">simple-array</span></tt> 描述了所有简单数组的集合。</p>
<p>如果有某些复合类型标识符你想重复使用，你可以使用 <tt class="docutils literal"><span class="pre">deftype</span></tt> 定义一个缩写。这个宏与 <tt class="docutils literal"><span class="pre">defmacro</span></tt> 相似，但会展开成一个类型标识符，而不是一个表达式。通过表达</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">deftype</span> <span class="nv">proseq</span> <span class="p">()</span>
        <span class="o">&#39;</span><span class="p">(</span><span class="nb">or</span> <span class="nb">vector</span> <span class="p">(</span><span class="nb">and</span> <span class="nb">list</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nv">satisfies</span> <span class="nv">circular?</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>我们定义了 <tt class="docutils literal"><span class="pre">proseq</span></tt> 作为一个新的原子类型标识符：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">typep</span> <span class="o">#(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="ss">&#39;proseq</span><span class="p">)</span>
<span class="no">T</span>
</pre></div>
</td></tr></table></div>
<p>如果你定义一个接受参数的类型标识符，参数会被视为 Lisp 形式（即没有被求值），与 <tt class="docutils literal"><span class="pre">defmacro</span></tt> 一样。所以</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">deftype</span> <span class="nv">multiple-of</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="o">`</span><span class="p">(</span><span class="nb">and</span> <span class="nc">integer</span> <span class="p">(</span><span class="nv">satisfies</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
                             <span class="p">(</span><span class="nb">zerop</span> <span class="p">(</span><span class="nb">mod</span> <span class="nv">x</span> <span class="o">,</span><span class="nv">n</span><span class="p">))))))</span>
</pre></div>
</td></tr></table></div>
<p>(译注: 注意上面代码是使用反引号 <tt class="docutils literal"><span class="pre">`</span></tt> )</p>
<p>定义了 <cite>(multiple-of n)</cite> 当成所有 <tt class="docutils literal"><span class="pre">n</span></tt> 的倍数的标识符：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">type</span> <span class="mi">12</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">multiple-of</span> <span class="mi">4</span><span class="p">))</span>
<span class="no">T</span>
</pre></div>
</td></tr></table></div>
<p>类型标识符会被直译 (interpreted)，因此很慢，所以通常你最好定义一个函数来处理这类的测试。</p>
</div>
<div class="section" id="binary-streams">
<h2>14.2 二进制流 (Binary Streams)<a class="headerlink" href="#binary-streams" title="永久链接至标题">¶</a></h2>
<p>第 7 章曾提及流有二进制流 (binary streams)以及字符流 (character streams)。一个二进制流是一个整数的来源及/或终点，而不是字符。你通过指定一个整数的子类型来创建一个二进制流 –– 当你打开流时，通常是用 <tt class="docutils literal"><span class="pre">unsigned-byte</span></tt> –– 来作为 <tt class="docutils literal"><span class="pre">:element-type</span></tt> 的参数。</p>
<p>关于二进制流的 I/O 函数仅有两个， <tt class="docutils literal"><span class="pre">read-byte</span></tt> 以及 <tt class="docutils literal"><span class="pre">write-byte</span></tt> 。所以下面是你如何定义一个复制一个文件的函数：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">copy-file</span> <span class="p">(</span><span class="nv">from</span> <span class="nv">to</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">in</span> <span class="nv">from</span> <span class="ss">:direction</span> <span class="ss">:input</span>
                           <span class="ss">:element-type</span> <span class="ss">&#39;unsigned-byte</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">with-open-file</span> <span class="p">(</span><span class="nv">out</span> <span class="nv">to</span> <span class="ss">:direction</span> <span class="ss">:output</span>
                            <span class="ss">:element-type</span> <span class="ss">&#39;unsigned-byte</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">i</span> <span class="p">(</span><span class="nb">read-byte</span> <span class="nv">in</span> <span class="no">nil</span> <span class="mi">-1</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">read-byte</span> <span class="nv">in</span> <span class="no">nil</span> <span class="mi">-1</span><span class="p">)))</span>
          <span class="p">((</span><span class="nb">minusp</span> <span class="nv">i</span><span class="p">))</span>
        <span class="p">(</span><span class="k">declare</span> <span class="p">(</span><span class="kt">fixnum</span> <span class="nv">i</span><span class="p">))</span>
        <span class="p">(</span><span class="nb">write-byte</span> <span class="nv">i</span> <span class="nv">out</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>仅通过指定 <tt class="docutils literal"><span class="pre">unsigned-byte</span></tt> 给 <tt class="docutils literal"><span class="pre">:element-type</span></tt> ，你让操作系统选择一个字节 (byte)的长度。举例来说，如果你明确地想要读写 7 比特的整数，你可以使用：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="kt">unsigned-byte</span> <span class="mi">7</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>来传给 <tt class="docutils literal"><span class="pre">:element-type</span></tt> 。</p>
</div>
<div class="section" id="read-macros">
<h2>14.3 读取宏 (Read-Macros)<a class="headerlink" href="#read-macros" title="永久链接至标题">¶</a></h2>
<p>7.5 节介绍过宏字符 (macro character)的概念，一个对于 <tt class="docutils literal"><span class="pre">read</span></tt> 有特别意义的字符。每一个这样的字符，都有一个相关联的函数，这函数告诉 <tt class="docutils literal"><span class="pre">read</span></tt> 当遇到这个字符时该怎么处理。你可以变更某个已存在宏字符所相关联的函数，或是自己定义新的宏字符。</p>
<p>函数 <tt class="docutils literal"><span class="pre">set-macro-character</span></tt> 提供了一种方式来定义读取宏 (read-macros)。它接受一个字符及一个函数，因此当 <tt class="docutils literal"><span class="pre">read</span></tt> 碰到该字符时，它返回调用传入函数后的结果。</p>
<p>Lisp 中最古老的读取宏之一是 <tt class="docutils literal"><span class="pre">'</span></tt> ，即 <tt class="docutils literal"><span class="pre">quote</span></tt> 。我们可以定义成：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">set-macro-character</span> <span class="sc">#\&#39;</span>
        <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nc">stream</span> <span class="nb">char</span><span class="p">)</span>
                <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="k">quote</span> <span class="k">quote</span><span class="p">)</span> <span class="p">(</span><span class="nb">read</span> <span class="nc">stream</span> <span class="no">t</span> <span class="no">nil</span> <span class="no">t</span><span class="p">))))</span>
</pre></div>
</td></tr></table></div>
<p>当 <tt class="docutils literal"><span class="pre">read</span></tt> 在一个普通的语境下遇到 <tt class="docutils literal"><span class="pre">'</span></tt> 时，它会返回在当前流和字符上调用这个函数的结果。(这个函数忽略了第二个参数，第二个参数永远是引用字符。)所以当 <tt class="docutils literal"><span class="pre">read</span></tt> 看到 <tt class="docutils literal"><span class="pre">'a</span></tt> 时，会返回 <tt class="docutils literal"><span class="pre">(quote</span> <span class="pre">a)</span></tt> 。</p>
<p>译注: <tt class="docutils literal"><span class="pre">read</span></tt> 函数接受的参数 <tt class="docutils literal"><span class="pre">(read</span> <span class="pre">&amp;optional</span> <span class="pre">stream</span> <span class="pre">eof-error</span> <span class="pre">eof-value</span> <span class="pre">recursive)</span></tt></p>
<p>现在我们明白了 <tt class="docutils literal"><span class="pre">read</span></tt> 最后一个参数的用途。它表示无论 <tt class="docutils literal"><span class="pre">read</span></tt> 调用是否在另一个 <tt class="docutils literal"><span class="pre">read</span></tt> 里。传给 <tt class="docutils literal"><span class="pre">read</span></tt> 的参数在几乎所有的读取宏里皆相同：传入参数有流 (stream)；接著是第二个参数， <tt class="docutils literal"><span class="pre">t</span></tt> ，说明了 <tt class="docutils literal"><span class="pre">read</span></tt> 若读入的东西是 end-of-file 时，应不应该报错；第三个参数说明了不报错时要返回什么，因此在这里也就不重要了；而第四个参数 <tt class="docutils literal"><span class="pre">t</span></tt> 说明了这个 <tt class="docutils literal"><span class="pre">read</span></tt> 调用是递归的。</p>
<p>(译注：困惑的话可以看看 <a class="reference external" href="https://gist.github.com/3467235">read 的定义</a> )</p>
<p>你可以（通过使用 <tt class="docutils literal"><span class="pre">make-dispatch-macro-character</span></tt> ）来定义你自己的派发宏字符（dispatching macro character），但由于 <tt class="docutils literal"><span class="pre">#</span></tt> 已经是一个宏字符，所以你也可以直接使用。六个 <tt class="docutils literal"><span class="pre">#</span></tt> 打头的组合特别保留给你使用： <tt class="docutils literal"><span class="pre">#!</span></tt> 、 <tt class="docutils literal"><span class="pre">#?</span></tt> 、 <tt class="docutils literal"><span class="pre">##[</span></tt> 、 <tt class="docutils literal"><span class="pre">##]</span></tt> 、 <tt class="docutils literal"><span class="pre">#{</span></tt> 、 <tt class="docutils literal"><span class="pre">#}</span></tt> 。</p>
<p>你可以通过调用 <tt class="docutils literal"><span class="pre">set-dispatch-macro-character</span></tt> 定义新的派发宏字符组合，与 <tt class="docutils literal"><span class="pre">set-macro-character</span></tt> 类似，除了它接受两个字符参数外。下面的代码定义了 <tt class="docutils literal"><span class="pre">#?</span></tt> 作为返回一个整数列表的读取宏。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">set-dispatch-macro-character</span> <span class="sc">#\#</span> <span class="sc">#\?</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nc">stream</span> <span class="nv">char1</span> <span class="nv">char2</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;quote</span>
            <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">lst</span> <span class="no">nil</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="p">(</span><span class="nb">+</span> <span class="p">(</span><span class="nb">read</span> <span class="nc">stream</span> <span class="no">t</span> <span class="no">nil</span> <span class="no">t</span><span class="p">)</span> <span class="mi">1</span><span class="p">))</span>
                <span class="p">(</span><span class="nb">push</span> <span class="nv">i</span> <span class="nv">lst</span><span class="p">))</span>
              <span class="p">(</span><span class="nb">nreverse</span> <span class="nv">lst</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>现在 <tt class="docutils literal"><span class="pre">#?n</span></tt> 会被读取成一个含有整数 <tt class="docutils literal"><span class="pre">0</span></tt> 至 <tt class="docutils literal"><span class="pre">n</span></tt> 的列表。举例来说：</p>
<div class="highlight-cl"><pre>&gt; #?7
(1 2 3 4 5 6 7)</pre>
</div>
<p>除了简单的宏字符，最常定义的宏字符是列表分隔符 (list delimiters)。另一个保留给用户的字符组是 <tt class="docutils literal"><span class="pre">#{</span></tt> 。以下我们定义了一种更复杂的左括号：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">set-macro-character</span> <span class="sc">#\}</span> <span class="p">(</span><span class="nb">get-macro-character</span> <span class="sc">#\)</span><span class="p">))</span>

<span class="p">(</span><span class="nb">set-dispatch-macro-character</span> <span class="sc">#\#</span> <span class="sc">#\{</span>
  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nc">stream</span> <span class="nv">char1</span> <span class="nv">char2</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">accum</span> <span class="no">nil</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">pair</span> <span class="p">(</span><span class="nb">read-delimited-list</span> <span class="sc">#\}</span> <span class="nc">stream</span> <span class="no">t</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">do</span> <span class="p">((</span><span class="nv">i</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">pair</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">i</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">i</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">pair</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;quote</span> <span class="p">(</span><span class="nb">nreverse</span> <span class="nv">accum</span><span class="p">)))</span>
          <span class="p">(</span><span class="nb">push</span> <span class="nv">i</span> <span class="nv">accum</span><span class="p">)))))</span>
</pre></div>
</td></tr></table></div>
<p>这定义了一个这样形式 <tt class="docutils literal"><span class="pre">#{x</span> <span class="pre">y}</span></tt> 的表达式，使得这样的表达式被读取为所有介于 <tt class="docutils literal"><span class="pre">x</span></tt> 与 <tt class="docutils literal"><span class="pre">y</span></tt> 之间的整数列表，包含 <tt class="docutils literal"><span class="pre">x</span></tt> 与 <tt class="docutils literal"><span class="pre">y</span></tt> ：</p>
<div class="highlight-cl"><pre>&gt; #{2 7}
(2 3 4 4 5 6 7)</pre>
</div>
<p>函数 <tt class="docutils literal"><span class="pre">read-delimited-list</span></tt> 正是为了这样的读取宏而生的。它的第一个参数是被视为列表结束的字符。为了使 <tt class="docutils literal"><span class="pre">}</span></tt> 被识别为分隔符，必须先给它这个角色，所以程序在开始的地方调用了 <tt class="docutils literal"><span class="pre">set-macro-character</span></tt> 。</p>
<p>如果你想要在定义一个读取宏的文件里使用该读取宏，则读取宏的定义应要包在一个 <tt class="docutils literal"><span class="pre">eval-when</span></tt> 表达式里，来确保它在编译期会被求值。不然它的定义会被编译，但不会被求值，直到编译文件被载入时才会被求值。</p>
</div>
<div class="section" id="packages">
<h2>14.4 包 (Packages)<a class="headerlink" href="#packages" title="永久链接至标题">¶</a></h2>
<p>一个包是一个将名字映对到符号的 Lisp 对象。当前的包总是存在全局变量 <tt class="docutils literal"><span class="pre">*package*</span></tt> 里。当 Common Lisp 启动时，当前的包会是 <tt class="docutils literal"><span class="pre">*common-lisp-user*</span></tt> ，通常称为用户包 (user package)。函数 <tt class="docutils literal"><span class="pre">package-name</span></tt> 返回包的名字，而 <tt class="docutils literal"><span class="pre">find-package</span></tt> 返回一个给定名称的包:</p>
<div class="highlight-cl"><pre>&gt; (package-name *package*)
"COMMON-LISP-USER"
&gt; (find-package "COMMON-LISP-USER")
#&lt;Package "COMMON-LISP-USER" 4CD15E&gt;</pre>
</div>
<p>通常一个符号在读入时就被 interned 至当前的包里面了。函数 <tt class="docutils literal"><span class="pre">symbol-package</span></tt> 接受一个符号并返回该符号被 interned 的包。</p>
<div class="highlight-cl"><pre>(symbol-package 'sym)
#&lt;Package "COMMON-LISP-USER" 4CD15E&gt;</pre>
</div>
<p>有趣的是，这个表达式返回它该返回的值，因为表达式在可以被求值前必须先被读入，而读取这个表达式导致 <tt class="docutils literal"><span class="pre">sym</span></tt> 被 interned。为了之后的用途，让我们给 <tt class="docutils literal"><span class="pre">sym</span></tt> 一个值:</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">sym</span> <span class="mi">99</span><span class="p">)</span>
<span class="mi">99</span>
</pre></div>
</td></tr></table></div>
<p>现在我们可以创建及切换至一个新的包：</p>
<div class="highlight-cl"><pre>&gt; (setf *package* (make-package 'mine
                                :use '(common-lisp)))
#&lt;Package "MINE" 63390E&gt;</pre>
</div>
<p>现在应该会听到诡异的背景音乐，因为我们来到一个不一样的世界了：
在这里 <tt class="docutils literal"><span class="pre">sym</span></tt> 不再是本来的 <tt class="docutils literal"><span class="pre">sym</span></tt> 了。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nv">MINE&gt;</span> <span class="nv">sym</span>
<span class="nv">Error:</span> <span class="nv">SYM</span> <span class="nv">has</span> <span class="nv">no</span> <span class="nv">value</span>
</pre></div>
</td></tr></table></div>
<p>为什么会这样？因为上面我们设为 99 的 <tt class="docutils literal"><span class="pre">sym</span></tt> 与 <tt class="docutils literal"><span class="pre">mine</span></tt> 里的 <tt class="docutils literal"><span class="pre">sym</span></tt> 是两个不同的符号。 <a class="footnote-reference" href="#id5" id="id3">[2]</a> 要在用户包之外参照到原来的 <tt class="docutils literal"><span class="pre">sym</span></tt> ，我们必须把包的名字加上两个冒号作为前缀：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nv">MINE&gt;</span> <span class="nv">common-lisp-user::sym</span>
<span class="mi">99</span>
</pre></div>
</td></tr></table></div>
<p>所以有著相同打印名称的不同符号能够在不同的包内共存。可以有一个 <tt class="docutils literal"><span class="pre">sym</span></tt> 在 <tt class="docutils literal"><span class="pre">common-lisp-user</span></tt> 包，而另一个 <tt class="docutils literal"><span class="pre">sym</span></tt> 在 <tt class="docutils literal"><span class="pre">mine</span></tt> 包，而他们会是不一样的符号。这就是包存在的意义。如果你在分开的包内写你的程序，你大可放心选择函数与变量的名字，而不用担心某人使用了同样的名字。即便是他们使用了同样的名字，也不会是相同的符号。</p>
<p>包也提供了信息隐藏的手段。程序应通过函数与变量的名字来参照它们。如果你不让一个名字在你的包之外可见的话，那么另一个包中的代码就无法使用或者修改这个名字所参照的对象。</p>
<p>通常使用两个冒号作为包的前缀也是很差的风格。这么做你就违反了包本应提供的模块性。如果你不得不使用一个双冒号来参照到一个符号，这是因为某人根本不想让你用。</p>
<p>通常我们应该只参照被输出 ( <em>exported</em> )的符号。如果我们回到用户包里，并输出一个被 interned 的符号，</p>
<div class="highlight-cl"><pre>MINE&gt; (in-package common-lisp-user)
#&lt;Package "COMMON-LISP-USER" 4CD15E&gt;
&gt; (export 'bar)
T
&gt; (setf bar 5)
5</pre>
</div>
<p>我们使这个符号对于其它的包是可视的。现在当我们回到 <tt class="docutils literal"><span class="pre">mine</span></tt> ，我们可以仅使用单冒号来参照到 <tt class="docutils literal"><span class="pre">bar</span></tt> ，因为他是一个公开可用的名字：</p>
<div class="highlight-cl"><pre>&gt; (in-package mine)
#&lt;Package "MINE" 63390E&gt;
MINE&gt; common-lisp-user:bar
5</pre>
</div>
<p>通过把 <tt class="docutils literal"><span class="pre">bar</span></tt> 输入 ( <tt class="docutils literal"><span class="pre">import</span></tt> )至 <tt class="docutils literal"><span class="pre">mine</span></tt> 包，我们就能进一步让 <tt class="docutils literal"><span class="pre">mine</span></tt> 和 <tt class="docutils literal"><span class="pre">user</span></tt> 包可以共享 <tt class="docutils literal"><span class="pre">bar</span></tt> 这个符号：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nv">MINE&gt;</span> <span class="p">(</span><span class="nb">import</span> <span class="ss">&#39;common-lisp-user:bar</span><span class="p">)</span>
<span class="no">T</span>
<span class="nv">MINE&gt;</span> <span class="nv">bar</span>
<span class="mi">5</span>
</pre></div>
</td></tr></table></div>
<p>在输入 <tt class="docutils literal"><span class="pre">bar</span></tt> 之后，我们根本不需要用任何包的限定符 (package qualifier)，就能参照它了。这两个包现在共享了同样的符号；不可能会有一个独立的 <tt class="docutils literal"><span class="pre">mine:bar</span></tt> 了。</p>
<p>要是已经有一个了怎么办？在这种情况下， <tt class="docutils literal"><span class="pre">import</span></tt> 调用会产生一个错误，如下面我们试著输入 <tt class="docutils literal"><span class="pre">sym</span></tt> 时便知：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nv">MINE&gt;</span> <span class="p">(</span><span class="nb">import</span> <span class="ss">&#39;common-lisp-user::sym</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">SYM</span> <span class="nv">is</span> <span class="nv">already</span> <span class="nv">present</span> <span class="nv">in</span> <span class="nv">MINE.</span>
</pre></div>
</td></tr></table></div>
<p>在此之前，当我们试著在 <tt class="docutils literal"><span class="pre">mine</span></tt> 包里对 <tt class="docutils literal"><span class="pre">sym</span></tt> 进行了一次不成功的求值，我们使 <tt class="docutils literal"><span class="pre">sym</span></tt> 被 interned 至 <tt class="docutils literal"><span class="pre">mine</span></tt> 包里。而因为它没有值，所以产生了一个错误，但输入符号名的后果就是使这个符号被 intern 进这个包。所以现在当我们试著输入 <tt class="docutils literal"><span class="pre">sym</span></tt> 至 <tt class="docutils literal"><span class="pre">mine</span></tt> 包里，已经有一个相同名称的符号了。</p>
<p>另一个方法来获得别的包内符号的存取权是使用( <tt class="docutils literal"><span class="pre">use</span></tt> )它：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="nv">MINE&gt;</span> <span class="p">(</span><span class="nb">use-package</span> <span class="ss">&#39;common-lisp-user</span><span class="p">)</span>
<span class="no">T</span>
</pre></div>
</td></tr></table></div>
<p>现在所有由用户包 (译注: common-lisp-user 包）所输出的符号，可以不需要使用任何限定符在 <tt class="docutils literal"><span class="pre">mine</span></tt> 包里使用。(如果 <tt class="docutils literal"><span class="pre">sym</span></tt> 已经被用户包书出了，这个调用也会产生一个错误。)</p>
<p>含有自带操作符及变量名字的包叫做 <tt class="docutils literal"><span class="pre">common-lisp</span></tt> 。由于我们将这个包的名字在创建 <tt class="docutils literal"><span class="pre">mine</span></tt> 包时作为 <tt class="docutils literal"><span class="pre">make-package</span></tt> 的 <tt class="docutils literal"><span class="pre">:use</span></tt> 参数，所有的 Common Lisp 自带的名字在 <tt class="docutils literal"><span class="pre">mine</span></tt> 里都是可视的:</p>
<div class="highlight-cl"><pre>MINE&gt; #'cons
#&lt;Compiled-Function CONS 462A3E&gt;</pre>
</div>
<p>在编译后的代码中, 通常不会像这样在顶层进行包的操作。更常见的是包的调用会包含在源文件里。通常，只要把 <tt class="docutils literal"><span class="pre">in-package</span></tt> 和 <tt class="docutils literal"><span class="pre">defpackage</span></tt> 放在源文件的开头就可以了，正如 137 页所示。</p>
<p>这种由包所提供的模块性实际上有点奇怪。我们有不是对象的模块 (modules)，而是名字的模块。</p>
<p>每一个使用了 <tt class="docutils literal"><span class="pre">common-lisp</span></tt> 的包，都可以存取 <tt class="docutils literal"><span class="pre">cons</span></tt> ，因为 <tt class="docutils literal"><span class="pre">common-lisp</span></tt> 包里有一个叫这个名字的函数。但这会导致一个名字为 <tt class="docutils literal"><span class="pre">cons</span></tt> 的变量也会在每个使用了 <tt class="docutils literal"><span class="pre">common-lisp</span></tt> 包里是可视的。如果包使你困惑，这就是主要的原因；因为包不是基于对象而是基于名字。</p>
</div>
<div class="section" id="loop-the-loop-facility">
<h2>14.5 Loop 宏 (The Loop Facility)<a class="headerlink" href="#loop-the-loop-facility" title="永久链接至标题">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">loop</span></tt> 宏最初是设计来帮助无经验的 Lisp 用户来写出迭代的代码。与其撰写 Lisp 代码，你用一种更接近英语的形式来表达你的程序，然后这个形式被翻译成 Lisp。不幸的是， <tt class="docutils literal"><span class="pre">loop</span></tt> 比原先设计者预期的更接近英语：你可以在简单的情况下使用它，而不需了解它是如何工作的，但想在抽象层面上理解它几乎是不可能的。</p>
<p>如果你是曾经计画某天要理解 <tt class="docutils literal"><span class="pre">loop</span></tt> 怎么工作的许多 Lisp 程序员之一，有一些好消息与坏消息。好消息是你并不孤单：几乎没有人理解它。坏消息是你永远不会理解它，因为 ANSI 标准实际上并没有给出它行为的正式规范。</p>
<p>这个宏唯一的实际定义是它的实现方式，而唯一可以理解它（如果有人可以理解的话）的方法是通过实例。ANSI 标准讨论 <tt class="docutils literal"><span class="pre">loop</span></tt> 的章节大部分由例子组成，而我们将会使用同样的方式来介绍相关的基础概念。</p>
<p>第一个关于 <tt class="docutils literal"><span class="pre">loop</span></tt> 宏我们要注意到的是语法 ( <em>syntax</em> )。一个 <tt class="docutils literal"><span class="pre">loop</span></tt> 表达式不是包含子表达式而是子句 (<em>clauses</em>)。這些子句不是由括号分隔出来；而是每种都有一个不同的语法。在这个方面上， <tt class="docutils literal"><span class="pre">loop</span></tt> 与传统的 Algol-like 语言相似。但其它 <tt class="docutils literal"><span class="pre">loop</span></tt> 独特的特性，使得它与 Algol 不同，也就是在 <tt class="docutils literal"><span class="pre">loop</span></tt> 宏里调换子句的顺序与会发生的事情没有太大的关联。</p>
<p>一个 <tt class="docutils literal"><span class="pre">loop</span></tt> 表达式的求值分为三个阶段，而一个给定的子句可以替多于一个的阶段贡献代码。这些阶段如下：</p>
<ol class="arabic simple">
<li><em>序幕</em> (<em>Prologue</em>)。 被求值一次来做为迭代过程的序幕。包括了将变量设至它们的初始值。</li>
<li><em>主体</em> (<em>Body</em>) 每一次迭代时都会被求值。</li>
<li><em>闭幕</em> (<em>Epilogue</em>) 当迭代结束时被求值。决定了 <tt class="docutils literal"><span class="pre">loop</span></tt> 表达式的返回值（可能返回多个值）。</li>
</ol>
<p>我们会看几个 <tt class="docutils literal"><span class="pre">loop</span></tt> 子句的例子，并考虑何种代码会贡献至何个阶段。</p>
<p>举例来说，最简单的 <tt class="docutils literal"><span class="pre">loop</span></tt> 表达式，我们可能会看到像是下列的代码：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">0</span> <span class="nv">to</span> <span class="mi">9</span>
        <span class="nb">do</span> <span class="p">(</span><span class="nb">princ</span> <span class="nv">x</span><span class="p">))</span>
<span class="mi">0123456789</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>这个 <tt class="docutils literal"><span class="pre">loop</span></tt> 表达式印出从 <tt class="docutils literal"><span class="pre">0</span></tt> 至 <tt class="docutils literal"><span class="pre">9</span></tt> 的整数，并返回 <tt class="docutils literal"><span class="pre">nil</span></tt> 。第一个子句，</p>
<p><tt class="docutils literal"><span class="pre">for</span> <span class="pre">x</span> <span class="pre">from</span> <span class="pre">0</span> <span class="pre">to</span> <span class="pre">9</span></tt></p>
<p>贡献代码至前两个阶段，导致 <tt class="docutils literal"><span class="pre">x</span></tt> 在序幕中被设为 <tt class="docutils literal"><span class="pre">0</span></tt> ，在主体开头与 <tt class="docutils literal"><span class="pre">9</span></tt> 来做比较，在主体结尾被递增。第二个子句，</p>
<p><tt class="docutils literal"><span class="pre">do</span> <span class="pre">(princ</span> <span class="pre">x)</span></tt></p>
<p>贡献代码给主体。</p>
<p>一个更通用的 <tt class="docutils literal"><span class="pre">for</span></tt> 子句说明了起始与更新的形式 (initial and update form)。停止迭代可以被像是 <tt class="docutils literal"><span class="pre">while</span></tt> 或 <tt class="docutils literal"><span class="pre">until</span></tt> 子句来控制。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nb">=</span> <span class="mi">8</span> <span class="nv">then</span> <span class="p">(</span><span class="nb">/</span> <span class="nv">x</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nv">until</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">do</span> <span class="p">(</span><span class="nb">princ</span> <span class="nv">x</span><span class="p">))</span>
<span class="mi">8421</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>你可以使用 <tt class="docutils literal"><span class="pre">and</span></tt> 来创建复合的 <tt class="docutils literal"><span class="pre">for</span></tt> 子句，同时初始及更新两个变量：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">4</span>
        <span class="nb">and</span> <span class="nv">y</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">4</span>
        <span class="nb">do</span> <span class="p">(</span><span class="nb">princ</span> <span class="p">(</span><span class="nb">list</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)))</span>
<span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">)(</span><span class="mi">2</span> <span class="mi">2</span><span class="p">)(</span><span class="mi">3</span> <span class="mi">3</span><span class="p">)(</span><span class="mi">4</span> <span class="mi">4</span><span class="p">)</span>
<span class="no">NIL</span>
</pre></div>
</td></tr></table></div>
<p>要不然有多重 <tt class="docutils literal"><span class="pre">for</span></tt> 子句时，变量会被循序更新。</p>
<p>另一件在迭代代码通常会做的事是累积某种值。举例来说：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nv">in</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
        <span class="nv">collect</span> <span class="p">(</span><span class="nb">1+</span> <span class="nv">x</span><span class="p">))</span>
<span class="p">(</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>在 <tt class="docutils literal"><span class="pre">for</span></tt> 子句使用 <tt class="docutils literal"><span class="pre">in</span></tt> 而不是 <tt class="docutils literal"><span class="pre">from</span></tt> ，导致变量被设为一个列表的后续元素，而不是连续的整数。</p>
<p>在这个情况里， <tt class="docutils literal"><span class="pre">collect</span></tt> 子句贡献代码至三个阶段。在序幕，一個匿名累加器 (anonymous accumulator)設為 <tt class="docutils literal"><span class="pre">nil</span></tt> ；在主体裡， <tt class="docutils literal"><span class="pre">(1+</span> <span class="pre">x)</span></tt> 被累加至這個累加器，而在闭幕时返回累加器的值。</p>
<p>这是返回一个特定值的第一个例子。有用来明确指定返回值的子句，但没有这些子句时，一个 <tt class="docutils literal"><span class="pre">collect</span></tt> 子句决定了返回值。所以我们在这里所做的其实是重复了 <tt class="docutils literal"><span class="pre">mapcar</span></tt> 。</p>
<p><tt class="docutils literal"><span class="pre">loop</span></tt> 最常见的用途大概是蒐集调用一个函数数次的结果：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">5</span>
        <span class="nv">collect</span> <span class="p">(</span><span class="nb">random</span> <span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">3</span> <span class="mi">8</span> <span class="mi">6</span> <span class="mi">5</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>这里我们获得了一个含五个随机数的列表。这跟我们定义过的 <tt class="docutils literal"><span class="pre">map-int</span></tt> 情况类似 (105 页「译注: 6.4 小节。」)。如果我们有了 <tt class="docutils literal"><span class="pre">loop</span></tt> ，为什么还需要 <tt class="docutils literal"><span class="pre">map-int</span></tt> ？另一个人也可以说，如果我们有了 <tt class="docutils literal"><span class="pre">map-int</span></tt> ，为什么还需要 <tt class="docutils literal"><span class="pre">loop</span></tt> ？</p>
<p>一个 <tt class="docutils literal"><span class="pre">collect</span></tt> 子句也可以累积值到一个有名字的变量上。下面的函数接受一个数字的列表并返回偶数与奇数列表：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">even/odd</span> <span class="p">(</span><span class="nv">ns</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">n</span> <span class="nv">in</span> <span class="nv">ns</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">evenp</span> <span class="nv">n</span><span class="p">)</span>
           <span class="nv">collect</span> <span class="nv">n</span> <span class="nv">into</span> <span class="nv">evens</span>
           <span class="nv">else</span> <span class="nv">collect</span> <span class="nv">n</span> <span class="nv">into</span> <span class="nv">odds</span>
        <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">evens</span> <span class="nv">odds</span><span class="p">))))</span>
</pre></div>
</td></tr></table></div>
<p>一个 <tt class="docutils literal"><span class="pre">finally</span></tt> 子句贡献代码至闭幕。在这个情况它指定了返回值。</p>
<p>一个 <tt class="docutils literal"><span class="pre">sum</span></tt> 子句和一个 <tt class="docutils literal"><span class="pre">collect</span></tt> 子句类似，但 <tt class="docutils literal"><span class="pre">sum</span></tt> 子句累积一个数字，而不是一个列表。要获得 <tt class="docutils literal"><span class="pre">1</span></tt> 至 <tt class="docutils literal"><span class="pre">n</span></tt> 的和，我们可以写：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">sum</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="nv">n</span>
        <span class="nv">sum</span> <span class="nv">x</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p><tt class="docutils literal"><span class="pre">loop</span></tt> 更进一步的细节在附录 D 讨论，从 325 页开始。举个例子，图 14.1 包含了先前章节的两个迭代函数，而图 14.2 演示了将同样的函数翻译成 <tt class="docutils literal"><span class="pre">loop</span></tt> 。</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">most</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">values</span> <span class="no">nil</span> <span class="no">nil</span><span class="p">)</span>
      <span class="p">(</span><span class="k">let*</span> <span class="p">((</span><span class="nv">wins</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">))</span>
             <span class="p">(</span><span class="nb">max</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">wins</span><span class="p">)))</span>
        <span class="p">(</span><span class="nb">dolist</span> <span class="p">(</span><span class="nv">obj</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">))</span>
          <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">score</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">obj</span><span class="p">)))</span>
            <span class="p">(</span><span class="nb">when</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">score</span> <span class="nb">max</span><span class="p">)</span>
              <span class="p">(</span><span class="nb">setf</span> <span class="nv">wins</span> <span class="nv">obj</span>
                    <span class="nb">max</span>  <span class="nv">score</span><span class="p">))))</span>
        <span class="p">(</span><span class="nb">values</span> <span class="nv">wins</span> <span class="nb">max</span><span class="p">))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">num-year</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">do*</span> <span class="p">((</span><span class="nv">y</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">yzero</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">d</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))))</span>
           <span class="p">((</span><span class="nb">&lt;=</span> <span class="nv">d</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">))))</span>
      <span class="p">(</span><span class="nb">do*</span> <span class="p">((</span><span class="nv">y</span> <span class="nv">yzero</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">))</span>
            <span class="p">(</span><span class="nv">prev</span> <span class="mi">0</span> <span class="nv">d</span><span class="p">)</span>
            <span class="p">(</span><span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">d</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))))</span>
           <span class="p">((</span><span class="nb">&gt;</span> <span class="nv">d</span> <span class="nv">n</span><span class="p">)</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">prev</span><span class="p">))))))</span>
</pre></div>
</td></tr></table></div>
<p><strong>图 14.1 不使用 loop 的迭代函数</strong></p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">most</span> <span class="p">(</span><span class="nv">fn</span> <span class="nv">lst</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null</span> <span class="nv">lst</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">values</span> <span class="no">nil</span> <span class="no">nil</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">loop</span> <span class="nv">with</span> <span class="nv">wins</span> <span class="nb">=</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">lst</span><span class="p">)</span>
            <span class="nv">with</span> <span class="nb">max</span> <span class="nb">=</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">wins</span><span class="p">)</span>
            <span class="nv">for</span> <span class="nv">obj</span> <span class="nv">in</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">lst</span><span class="p">)</span>
            <span class="nv">for</span> <span class="nv">score</span> <span class="nb">=</span> <span class="p">(</span><span class="nb">funcall</span> <span class="nv">fn</span> <span class="nv">obj</span><span class="p">)</span>
            <span class="nb">when</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">score</span> <span class="nb">max</span><span class="p">)</span>
                 <span class="p">(</span><span class="nb">do</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">wins</span> <span class="nv">obj</span>
                           <span class="nb">max</span> <span class="nv">score</span><span class="p">)</span>
            <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="p">(</span><span class="nb">values</span> <span class="nv">wins</span> <span class="nb">max</span><span class="p">))))))</span>

<span class="p">(</span><span class="nb">defun</span> <span class="nv">num-year</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
  <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">n</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">y</span> <span class="nv">downfrom</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">yzero</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nv">until</span> <span class="p">(</span><span class="nb">&lt;=</span> <span class="nv">d</span> <span class="nv">n</span><span class="p">)</span>
            <span class="nv">sum</span> <span class="p">(</span><span class="nb">-</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">into</span> <span class="nv">d</span>
            <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">d</span><span class="p">))))</span>
      <span class="p">(</span><span class="nb">loop</span> <span class="nv">with</span> <span class="nv">prev</span> <span class="nb">=</span> <span class="mi">0</span>
            <span class="nv">for</span> <span class="nv">y</span> <span class="nv">from</span> <span class="nv">yzero</span>
            <span class="nv">until</span> <span class="p">(</span><span class="nb">&gt;</span> <span class="nv">d</span> <span class="nv">n</span><span class="p">)</span>
            <span class="nb">do</span> <span class="p">(</span><span class="nb">setf</span> <span class="nv">prev</span> <span class="nv">d</span><span class="p">)</span>
            <span class="nv">sum</span> <span class="p">(</span><span class="nv">year-days</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">into</span> <span class="nv">d</span>
            <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="p">(</span><span class="nb">values</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">y</span> <span class="mi">1</span><span class="p">)</span>
                                    <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="nv">prev</span><span class="p">))))))</span>
</pre></div>
</td></tr></table></div>
<p><strong>图 14.2 使用 loop 的迭代函数</strong></p>
<p>一个 <tt class="docutils literal"><span class="pre">loop</span></tt> 的子句可以参照到由另一个子句所设置的变量。举例来说，在 <tt class="docutils literal"><span class="pre">even/odd</span></tt> 的定义里面， <tt class="docutils literal"><span class="pre">finally</span></tt> 子句参照到由两个 <tt class="docutils literal"><span class="pre">collect</span></tt> 子句所创建的变量。这些变量之间的关系，是 <tt class="docutils literal"><span class="pre">loop</span></tt> 定义最含糊不清的地方。考虑下列两个表达式：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">y</span> <span class="nb">=</span> <span class="mi">0</span> <span class="nv">then</span> <span class="nv">z</span>
      <span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">5</span>
      <span class="nv">sum</span> <span class="mi">1</span> <span class="nv">into</span> <span class="nv">z</span>
      <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>

<span class="p">(</span><span class="nb">loop</span> <span class="nv">for</span> <span class="nv">x</span> <span class="nv">from</span> <span class="mi">1</span> <span class="nv">to</span> <span class="mi">5</span>
      <span class="nv">for</span> <span class="nv">y</span> <span class="nb">=</span> <span class="mi">0</span> <span class="nv">then</span> <span class="nv">z</span>
      <span class="nv">sum</span> <span class="mi">1</span> <span class="nv">into</span> <span class="nv">z</span>
      <span class="nv">finally</span> <span class="p">(</span><span class="nb">return</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">))</span>
</pre></div>
</td></tr></table></div>
<p>它们看起来够简单 –– 每一个有四个子句。但它们返回同样的值吗？它们返回的值多少？你若试著在标准中想找答案将徒劳无功。每一个 <tt class="docutils literal"><span class="pre">loop</span></tt> 子句本身是够简单的。但它们组合起来的方式是极为复杂的 –– 而最终，甚至标准里也没有明确定义。</p>
<p>由于这类原因，使用 <tt class="docutils literal"><span class="pre">loop</span></tt> 是不推荐的。推荐 <tt class="docutils literal"><span class="pre">loop</span></tt> 的理由，你最多可以说，在像是图 14.2 这般经典的例子中， <tt class="docutils literal"><span class="pre">loop</span></tt> 让代码看起来更容易理解。</p>
</div>
<div class="section" id="conditions">
<h2>14.6 状况 (Conditions)<a class="headerlink" href="#conditions" title="永久链接至标题">¶</a></h2>
<p>在 Common Lisp 里，状况 (condition)包括了错误以及其它可能在执行期发生的情况。当一个状况被捕捉时 (signalled)，相应的处理程序 (handler)会被调用。处理错误状况的缺省处理程序通常会调用一个中断循环 (break-loop)。但 Common Lisp 提供了多样的操作符来捕捉及处理错误。要覆写缺省的处理程序，甚至是自己写一个新的处理程序也是有可能的。</p>
<p>多数的程序员不会直接处理状况。然而有许多更抽象的操作符使用了状况，而要了解这些操作符，知道背后的原理是很有用的。</p>
<p>Common lisp 有数个操作符用来捕捉错误。最基本的是 <tt class="docutils literal"><span class="pre">error</span></tt> 。一个调用它的方法是给入你会给 <tt class="docutils literal"><span class="pre">format</span></tt> 的相同参数：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">error</span> <span class="s">&quot;Your report uses ~A as a verb.&quot;</span> <span class="ss">&#39;status</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">Your</span> <span class="nv">report</span> <span class="nv">uses</span> <span class="nv">STATUS</span> <span class="nv">as</span> <span class="nv">a</span> <span class="nv">verb</span>
                         <span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace</span>
<span class="nv">&gt;&gt;</span>
</pre></div>
</td></tr></table></div>
<p>如上所示，除非这样的状况被处理好了，不然执行就会被打断。</p>
<p>用来捕捉错误的更抽象操作符包括了 <tt class="docutils literal"><span class="pre">ecase</span></tt> 、 <tt class="docutils literal"><span class="pre">check-type</span></tt> 以及 <tt class="docutils literal"><span class="pre">assert</span></tt> 。前者与 <tt class="docutils literal"><span class="pre">case</span></tt> 相似，要是没有键值匹配时会捕捉一个错误：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">ecase</span> <span class="mi">1</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
<span class="nv">Error:</span> <span class="nv">No</span> <span class="nv">applicable</span> <span class="nv">clause</span>
                         <span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace</span>
<span class="nv">&gt;&gt;</span>
</pre></div>
</td></tr></table></div>
<p>普通的 <tt class="docutils literal"><span class="pre">case</span></tt> 在没有键值匹配时会返回 <tt class="docutils literal"><span class="pre">nil</span></tt> ，但由于利用这个返回值是很差的编码风格，你或许会在当你没有 <tt class="docutils literal"><span class="pre">otherwise</span></tt> 子句时使用 <tt class="docutils literal"><span class="pre">ecase</span></tt> 。</p>
<p><tt class="docutils literal"><span class="pre">check-type</span></tt> 宏接受一个位置，一个类型名以及一个选择性字串，并在该位置的值不是预期的类型时，捕捉一个可修正的错误 (correctable error)。一个可修正错误的处理程序会给我们一个机会来提供一个新的值：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8
9</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span>
                <span class="p">(</span><span class="nb">check-type</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="nc">integer</span> <span class="s">&quot;an integer&quot;</span><span class="p">)</span>
                <span class="nv">x</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">The</span> <span class="nv">value</span> <span class="nv">of</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">X</span><span class="p">)</span><span class="o">,</span> <span class="nv">A,</span> <span class="nv">should</span> <span class="nv">be</span> <span class="nv">an</span> <span class="nv">integer.</span>
<span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace,</span> <span class="ss">:continue</span>
<span class="nv">&gt;&gt;</span> <span class="ss">:continue</span>
<span class="nv">New</span> <span class="nv">value</span> <span class="nv">of</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">X</span><span class="p">)</span><span class="nv">?</span> <span class="mi">99</span>
<span class="p">(</span><span class="mi">99</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
<span class="nb">&gt;</span>
</pre></div>
</td></tr></table></div>
<p>在这个例子里， <tt class="docutils literal"><span class="pre">(car</span> <span class="pre">x)</span></tt> 被设为我们提供的新值，并重新执行，返回了要是 <tt class="docutils literal"><span class="pre">(car</span> <span class="pre">x)</span></tt> 本来就包含我们所提供的值所会返回的结果。</p>
<p>这个宏是用更通用的 <tt class="docutils literal"><span class="pre">assert</span></tt> 所定义的， <tt class="docutils literal"><span class="pre">assert</span></tt> 接受一个测试表达式以及一个有著一个或多个位置的列表，办随著你可能传给 <tt class="docutils literal"><span class="pre">error</span></tt> 的参数：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="nb">&gt;</span> <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">sandwich</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">ham</span> <span class="nv">on</span> <span class="nv">rye</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">assert</span> <span class="p">(</span><span class="nb">eql</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">sandwich</span><span class="p">)</span> <span class="ss">&#39;chicken</span><span class="p">)</span>
            <span class="p">((</span><span class="nb">car</span> <span class="nv">sandwich</span><span class="p">))</span>
            <span class="s">&quot;I wanted a ~A sandwich.&quot;</span> <span class="ss">&#39;chicken</span><span class="p">)</span>
    <span class="nv">sandwich</span><span class="p">)</span>
<span class="nv">Error:</span> <span class="nv">I</span> <span class="nv">wanted</span> <span class="nv">a</span> <span class="nv">CHICKEN</span> <span class="nv">sandwich.</span>
<span class="nv">Options:</span> <span class="ss">:abort,</span> <span class="ss">:backtrace,</span> <span class="ss">:continue</span>
<span class="nv">&gt;&gt;</span> <span class="ss">:continue</span>
<span class="nv">New</span> <span class="nv">value</span> <span class="nv">of</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">SANDWICH</span><span class="p">)</span><span class="nv">?</span> <span class="ss">&#39;chicken</span>
<span class="p">(</span><span class="nv">CHICKEN</span> <span class="nv">ON</span> <span class="nv">RYE</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>要建立新的处理程序也是可能的，但大多数程序员只会间接的利用这个可能性，通过使用像是 <tt class="docutils literal"><span class="pre">ignore-errors</span></tt> 的宏。如果它的参数没产生错误时像在 <tt class="docutils literal"><span class="pre">progn</span></tt> 里求值一样，但要是在求值过程中，不管什么参数报错，执行是不会被打断的。取而代之的是， <tt class="docutils literal"><span class="pre">ignore-errors</span></tt> 表达式会直接返回两个值： <tt class="docutils literal"><span class="pre">nil</span></tt> 以及捕捉到的状况。</p>
<p>举例来说，如果在某个时候，你想要用户能够输入一个表达式，但你不想要在输入是语法上不合时中断执行，你可以这样写：</p>
<div class="highlight-cl"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">(</span><span class="nb">defun</span> <span class="nv">user-input</span> <span class="p">(</span><span class="nv">prompt</span><span class="p">)</span>
  <span class="p">(</span><span class="nb">format</span> <span class="no">t</span> <span class="nv">prompt</span><span class="p">)</span>
  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">str</span> <span class="p">(</span><span class="nb">read-line</span><span class="p">)))</span>
    <span class="p">(</span><span class="nb">or</span> <span class="p">(</span><span class="nb">ignore-errors</span> <span class="p">(</span><span class="nb">read-from-string</span> <span class="nv">str</span><span class="p">))</span>
        <span class="no">nil</span><span class="p">)))</span>
</pre></div>
</td></tr></table></div>
<p>若输入包含语法错误时，这个函数仅返回 <tt class="docutils literal"><span class="pre">nil</span></tt> :</p>
<div class="highlight-cl"><pre>&gt; (user-input "Please type an expression")
Please type an expression&gt; #%@#+!!
NIL</pre>
</div>
<p class="rubric">脚注</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>虽然标准没有提到这件事，你可以假定 <tt class="docutils literal"><span class="pre">and</span></tt> 以及 <tt class="docutils literal"><span class="pre">or</span></tt> 类型标示符仅考虑它们所要考虑的参数，与 <tt class="docutils literal"><span class="pre">or</span></tt> 及 <tt class="docutils literal"><span class="pre">and</span></tt> 宏类似。</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>某些 Common Lisp 实现，当我们不在用户包下时，会在顶层提示符前打印包的名字。</td></tr>
</tbody>
</table>
</div>
</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'acl-chinese';

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
                  </div></div>
              </article><div class="clearer"></div>
          </div><div class="span3">
                <div class="sphinxsidebar">
      <div id="sidenav" class="box sphinxsidebarwrapper">


<h4><a href="../index.html">內容目录</a></h4>
  <ul>
<li><a class="reference internal" href="#">第十四章：进阶议题</a><ul>
<li><a class="reference internal" href="#type-specifiers">14.1 类型标识符 (Type Specifiers)</a></li>
<li><a class="reference internal" href="#binary-streams">14.2 二进制流 (Binary Streams)</a></li>
<li><a class="reference internal" href="#read-macros">14.3 读取宏 (Read-Macros)</a></li>
<li><a class="reference internal" href="#packages">14.4 包 (Packages)</a></li>
<li><a class="reference internal" href="#loop-the-loop-facility">14.5 Loop 宏 (The Loop Facility)</a></li>
<li><a class="reference internal" href="#conditions">14.6 状况 (Conditions)</a></li>
</ul>
</li>
</ul>

  
    <h3>本页</h3>
    <ul class="this-page-menu">
      
      
        <li><a href="https://github.com/acl-translation/acl-chinese/blob/redirect-to-new-domain/zhCN/ch14-cn.rst">
          Show on GitHub</a></li>
        <li><a href="https://github.com/acl-translation/acl-chinese/edit/redirect-to-new-domain/zhCN/ch14-cn.rst">
          Edit on GitHub</a></li>
      
    </ul>
  
</div>
    </div>
              </div></div>
      </div>
<footer class="container-fluid">
        <hr />&copy; 版权所有 2012, Juanito Fatas Huang.最后更新日期是 Apr 22, 2013.使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.</footer>
 <!-- End original user content -->


<br>
<br>
<br>


<style type="text/css">
  .rtd-badge {
    position: fixed;
    display: block;
    bottom: 5px;
    height: 40px;
    text-indent: -9999em;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
    -moz-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
    -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 rgba(255, 255, 255, 0.2) inset;
  }
  #version_menu {
    position: fixed;
    display: none;
    bottom: 11px;
    right: 166px;
    list-style-type: none;
    margin: 0;
  }
  .footer_popout:hover #version_menu {
    display: block;
  }
  #version_menu li {
    display: block;
    float: right;
  }
  #version_menu li a {
    display: block;
    padding: 6px 10px 4px 10px;
    margin: 7px 7px 0 0;
    font-weight: bold;
    font-size: 14px;
    height: 20px;
    line-height: 17px;
    text-decoration: none;
    color: #fff;
    background: #8ca1af url(../images/gradient-light.png) bottom left repeat-x;
    border-radius: 3px;
    -moz-border-radius: 3px;
    -webkit-border-radius: 3px;
    box-shadow: 0 1px 1px #465158;
    -moz-box-shadow: 0 1px 1px #465158;
    -webkit-box-shadow: 0 1px 1px #465158;
    text-shadow: 0 1px 1px rgba(0, 0, 0, 0.5);
  }
  #version_menu li a:hover {
    text-decoration: none;
    background-color: #697983;
    box-shadow: 0 1px 0px #465158;
    -moz-box-shadow: 0 1px 0px #465158;
    -webkit-box-shadow: 0 1px 0px #465158;
  }
  .rtd-badge.rtd {
    background: #3b4449 url(//media.readthedocs.org//images/badge-rtd.png) scroll 0px -46px no-repeat;
    border: 1px solid #282E32;
    width: 41px;
    right: 5px;
  }
  .footer_popout:hover .rtd-badge.rtd {
    background-position: top left;
    width: 160px;
  }
  .rtd-badge.revsys { background: #465158 url(//media.readthedocs.org//images/badge-revsys.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 290px;
    right: 173px;
  }
  .rtd-badge.revsys-inline-sponsored {
    position: inherit;
    margin-left: auto;
    margin-right: 175px;
    margin-bottom: 5px;
    background: #465158 url(//media.readthedocs.org//images/badge-revsys.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 290px;
    right: 173px;
  }
  .rtd-badge.revsys-inline {
    position: inherit;
    margin-left: auto;
    margin-right: 175px;
    margin-bottom: 5px;
    background: #465158 url(//media.readthedocs.org//images/badge-revsys-sm.png) top left no-repeat;
    border: 1px solid #1C5871;
    width: 205px;
    right: 173px;
  }

</style>
<div class="rtd_doc_footer">
  <div class="footer_popout">
    <a href="//readthedocs.org/projects/ansi-common-lisp/?fromdocs=ansi-common-lisp" class="rtd-badge rtd"> Brought to you by Read the Docs</a>
    <ul id="version_menu">
      
        <li><a href="/en/latest/">latest</a></li>
      
    </ul>
  </div>
</div>
<!-- RTD Analytics Code -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-17997319-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


<!-- User Analytics Code -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-26995626-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>


</body>
</html>